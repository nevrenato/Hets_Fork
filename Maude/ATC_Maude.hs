{-# OPTIONS -w -O0 #-}
{- |
Module      :  Maude/ATC_Maude.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Maude.Sign.Sign'
'Maude.Morphism.Morphism'
'Maude.Sentence.Sentence'
'Maude.Symbol.Symbol'
'Maude.AS_Maude.MaudeText'
'Maude.AS_Maude.Spec'
'Maude.AS_Maude.Module'
'Maude.AS_Maude.View'
'Maude.AS_Maude.Parameter'
'Maude.AS_Maude.ModExp'
'Maude.AS_Maude.Renaming'
'Maude.AS_Maude.ToPartRenaming'
'Maude.AS_Maude.Statement'
'Maude.AS_Maude.Import'
'Maude.AS_Maude.SubsortDecl'
'Maude.AS_Maude.Operator'
'Maude.AS_Maude.Membership'
'Maude.AS_Maude.Equation'
'Maude.AS_Maude.Rule'
'Maude.AS_Maude.Condition'
'Maude.AS_Maude.Attr'
'Maude.AS_Maude.StmntAttr'
'Maude.AS_Maude.Hook'
'Maude.AS_Maude.Term'
'Maude.AS_Maude.Type'
'Maude.AS_Maude.Sort'
'Maude.AS_Maude.Kind'
'Maude.AS_Maude.ParamId'
'Maude.AS_Maude.ViewId'
'Maude.AS_Maude.ModId'
'Maude.AS_Maude.LabelId'
'Maude.AS_Maude.OpId'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Maude/Sign.hs
Maude/Morphism.hs
Maude/Sentence.hs
Maude/Symbol.hs
Maude/AS_Maude.hs
-}

module Maude.ATC_Maude () where

import ATC.AS_Annotation
import ATerm.Lib
import Common.Doc
import Common.Doc (specBraces, text)
import Common.Doc (vcat)
import Common.Doc hiding (empty)
import Common.DocUtils (Pretty (..))
import Common.DocUtils (Pretty(..))
import Common.Id (Id, mkId, mkSimpleId, GetRange, getRange, nullRange)
import Common.Id (mkSimpleId, GetRange)
import Common.Id hiding (Id)
import Common.Lib.Rel (Rel)
import Common.Result (Result)
import Data.List (partition)
import Data.Map (Map)
import Data.Maybe (fromJust)
import Data.Set (Set)
import Data.Typeable
import Maude.AS_Maude
import Maude.Meta
import Maude.Meta.HasName
import Maude.Morphism
import Maude.Printing ()
import Maude.Sentence
import Maude.Sentence (Sentence)
import Maude.Sign
import Maude.Sign (Sign, kindRel, KindRel)
import Maude.Symbol
import Maude.Util
import qualified Common.Doc as Doc
import qualified Common.Lib.Rel as Rel
import qualified Data.Foldable as Fold
import qualified Data.List as List
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Maude.Sentence as Sen
import qualified Maude.Sign as Sign

{-! for Maude.Sign.Sign derive : Typeable !-}
{-! for Maude.Morphism.Morphism derive : Typeable !-}
{-! for Maude.Sentence.Sentence derive : Typeable !-}
{-! for Maude.Symbol.Symbol derive : Typeable !-}
{-! for Maude.AS_Maude.MaudeText derive : Typeable !-}
{-! for Maude.AS_Maude.Spec derive : Typeable !-}
{-! for Maude.AS_Maude.Module derive : Typeable !-}
{-! for Maude.AS_Maude.View derive : Typeable !-}
{-! for Maude.AS_Maude.Parameter derive : Typeable !-}
{-! for Maude.AS_Maude.ModExp derive : Typeable !-}
{-! for Maude.AS_Maude.Renaming derive : Typeable !-}
{-! for Maude.AS_Maude.ToPartRenaming derive : Typeable !-}
{-! for Maude.AS_Maude.Statement derive : Typeable !-}
{-! for Maude.AS_Maude.Import derive : Typeable !-}
{-! for Maude.AS_Maude.SubsortDecl derive : Typeable !-}
{-! for Maude.AS_Maude.Operator derive : Typeable !-}
{-! for Maude.AS_Maude.Membership derive : Typeable !-}
{-! for Maude.AS_Maude.Equation derive : Typeable !-}
{-! for Maude.AS_Maude.Rule derive : Typeable !-}
{-! for Maude.AS_Maude.Condition derive : Typeable !-}
{-! for Maude.AS_Maude.Attr derive : Typeable !-}
{-! for Maude.AS_Maude.StmntAttr derive : Typeable !-}
{-! for Maude.AS_Maude.Hook derive : Typeable !-}
{-! for Maude.AS_Maude.Term derive : Typeable !-}
{-! for Maude.AS_Maude.Type derive : Typeable !-}
{-! for Maude.AS_Maude.Sort derive : Typeable !-}
{-! for Maude.AS_Maude.Kind derive : Typeable !-}
{-! for Maude.AS_Maude.ParamId derive : Typeable !-}
{-! for Maude.AS_Maude.ViewId derive : Typeable !-}
{-! for Maude.AS_Maude.ModId derive : Typeable !-}
{-! for Maude.AS_Maude.LabelId derive : Typeable !-}
{-! for Maude.AS_Maude.OpId derive : Typeable !-}

{-! for Maude.Sign.Sign derive : ShATermConvertible !-}
{-! for Maude.Morphism.Morphism derive : ShATermConvertible !-}
{-! for Maude.Sentence.Sentence derive : ShATermConvertible !-}
{-! for Maude.Symbol.Symbol derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.MaudeText derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Spec derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Module derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.View derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Parameter derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.ModExp derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Renaming derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.ToPartRenaming derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Statement derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Import derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.SubsortDecl derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Operator derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Membership derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Equation derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Rule derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Condition derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Attr derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.StmntAttr derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Hook derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Term derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Type derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Sort derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.Kind derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.ParamId derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.ViewId derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.ModId derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.LabelId derive : ShATermConvertible !-}
{-! for Maude.AS_Maude.OpId derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcMaudeTextTc :: TyCon
_tcMaudeTextTc = mkTyCon "Maude.AS_Maude.MaudeText"
instance Typeable MaudeText where
    typeOf _ = mkTyConApp _tcMaudeTextTc []

_tcSpecTc :: TyCon
_tcSpecTc = mkTyCon "Maude.AS_Maude.Spec"
instance Typeable Spec where
    typeOf _ = mkTyConApp _tcSpecTc []

_tcModuleTc :: TyCon
_tcModuleTc = mkTyCon "Maude.AS_Maude.Module"
instance Typeable Module where
    typeOf _ = mkTyConApp _tcModuleTc []

_tcViewTc :: TyCon
_tcViewTc = mkTyCon "Maude.AS_Maude.View"
instance Typeable View where
    typeOf _ = mkTyConApp _tcViewTc []

_tcParameterTc :: TyCon
_tcParameterTc = mkTyCon "Maude.AS_Maude.Parameter"
instance Typeable Parameter where
    typeOf _ = mkTyConApp _tcParameterTc []

_tcModExpTc :: TyCon
_tcModExpTc = mkTyCon "Maude.AS_Maude.ModExp"
instance Typeable ModExp where
    typeOf _ = mkTyConApp _tcModExpTc []

_tcRenamingTc :: TyCon
_tcRenamingTc = mkTyCon "Maude.AS_Maude.Renaming"
instance Typeable Renaming where
    typeOf _ = mkTyConApp _tcRenamingTc []

_tcToPartRenamingTc :: TyCon
_tcToPartRenamingTc = mkTyCon "Maude.AS_Maude.ToPartRenaming"
instance Typeable ToPartRenaming where
    typeOf _ = mkTyConApp _tcToPartRenamingTc []

_tcStatementTc :: TyCon
_tcStatementTc = mkTyCon "Maude.AS_Maude.Statement"
instance Typeable Statement where
    typeOf _ = mkTyConApp _tcStatementTc []

_tcImportTc :: TyCon
_tcImportTc = mkTyCon "Maude.AS_Maude.Import"
instance Typeable Import where
    typeOf _ = mkTyConApp _tcImportTc []

_tcSubsortDeclTc :: TyCon
_tcSubsortDeclTc = mkTyCon "Maude.AS_Maude.SubsortDecl"
instance Typeable SubsortDecl where
    typeOf _ = mkTyConApp _tcSubsortDeclTc []

_tcOperatorTc :: TyCon
_tcOperatorTc = mkTyCon "Maude.AS_Maude.Operator"
instance Typeable Operator where
    typeOf _ = mkTyConApp _tcOperatorTc []

_tcMembershipTc :: TyCon
_tcMembershipTc = mkTyCon "Maude.AS_Maude.Membership"
instance Typeable Membership where
    typeOf _ = mkTyConApp _tcMembershipTc []

_tcEquationTc :: TyCon
_tcEquationTc = mkTyCon "Maude.AS_Maude.Equation"
instance Typeable Equation where
    typeOf _ = mkTyConApp _tcEquationTc []

_tcRuleTc :: TyCon
_tcRuleTc = mkTyCon "Maude.AS_Maude.Rule"
instance Typeable Rule where
    typeOf _ = mkTyConApp _tcRuleTc []

_tcConditionTc :: TyCon
_tcConditionTc = mkTyCon "Maude.AS_Maude.Condition"
instance Typeable Condition where
    typeOf _ = mkTyConApp _tcConditionTc []

_tcAttrTc :: TyCon
_tcAttrTc = mkTyCon "Maude.AS_Maude.Attr"
instance Typeable Attr where
    typeOf _ = mkTyConApp _tcAttrTc []

_tcStmntAttrTc :: TyCon
_tcStmntAttrTc = mkTyCon "Maude.AS_Maude.StmntAttr"
instance Typeable StmntAttr where
    typeOf _ = mkTyConApp _tcStmntAttrTc []

_tcHookTc :: TyCon
_tcHookTc = mkTyCon "Maude.AS_Maude.Hook"
instance Typeable Hook where
    typeOf _ = mkTyConApp _tcHookTc []

_tcTermTc :: TyCon
_tcTermTc = mkTyCon "Maude.AS_Maude.Term"
instance Typeable Term where
    typeOf _ = mkTyConApp _tcTermTc []

_tcTypeTc :: TyCon
_tcTypeTc = mkTyCon "Maude.AS_Maude.Type"
instance Typeable Type where
    typeOf _ = mkTyConApp _tcTypeTc []

_tcSortTc :: TyCon
_tcSortTc = mkTyCon "Maude.AS_Maude.Sort"
instance Typeable Sort where
    typeOf _ = mkTyConApp _tcSortTc []

_tcKindTc :: TyCon
_tcKindTc = mkTyCon "Maude.AS_Maude.Kind"
instance Typeable Kind where
    typeOf _ = mkTyConApp _tcKindTc []

_tcParamIdTc :: TyCon
_tcParamIdTc = mkTyCon "Maude.AS_Maude.ParamId"
instance Typeable ParamId where
    typeOf _ = mkTyConApp _tcParamIdTc []

_tcViewIdTc :: TyCon
_tcViewIdTc = mkTyCon "Maude.AS_Maude.ViewId"
instance Typeable ViewId where
    typeOf _ = mkTyConApp _tcViewIdTc []

_tcModIdTc :: TyCon
_tcModIdTc = mkTyCon "Maude.AS_Maude.ModId"
instance Typeable ModId where
    typeOf _ = mkTyConApp _tcModIdTc []

_tcLabelIdTc :: TyCon
_tcLabelIdTc = mkTyCon "Maude.AS_Maude.LabelId"
instance Typeable LabelId where
    typeOf _ = mkTyConApp _tcLabelIdTc []

_tcOpIdTc :: TyCon
_tcOpIdTc = mkTyCon "Maude.AS_Maude.OpId"
instance Typeable OpId where
    typeOf _ = mkTyConApp _tcOpIdTc []

instance ShATermConvertible MaudeText where
  toShATermAux att0 xv = case xv of
    MaudeText a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MaudeText" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MaudeText" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MaudeText a') }
    u -> fromShATermError "MaudeText" u

instance ShATermConvertible Spec where
  toShATermAux att0 xv = case xv of
    SpecMod a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SpecMod" [a'] []) att1
    SpecTh a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SpecTh" [a'] []) att1
    SpecView a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SpecView" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SpecMod" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SpecMod a') }
    ShAAppl "SpecTh" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SpecTh a') }
    ShAAppl "SpecView" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SpecView a') }
    u -> fromShATermError "Spec" u

instance ShATermConvertible Module where
  toShATermAux att0 xv = case xv of
    Module a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Module" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Module" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Module a' b' c') }}}
    u -> fromShATermError "Module" u

instance ShATermConvertible View where
  toShATermAux att0 xv = case xv of
    View a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "View" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "View" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, View a' b' c' d') }}}}
    u -> fromShATermError "View" u

instance ShATermConvertible Parameter where
  toShATermAux att0 xv = case xv of
    Parameter a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Parameter" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Parameter" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Parameter a' b') }}
    u -> fromShATermError "Parameter" u

instance ShATermConvertible ModExp where
  toShATermAux att0 xv = case xv of
    ModExp a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ModExp" [a'] []) att1
    SummationModExp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SummationModExp" [a', b'] []) att2
    RenamingModExp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "RenamingModExp" [a', b'] []) att2
    InstantiationModExp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "InstantiationModExp" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ModExp" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ModExp a') }
    ShAAppl "SummationModExp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SummationModExp a' b') }}
    ShAAppl "RenamingModExp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, RenamingModExp a' b') }}
    ShAAppl "InstantiationModExp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, InstantiationModExp a' b') }}
    u -> fromShATermError "ModExp" u

instance ShATermConvertible Renaming where
  toShATermAux att0 xv = case xv of
    SortRenaming a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SortRenaming" [a', b'] []) att2
    LabelRenaming a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "LabelRenaming" [a', b'] []) att2
    OpRenaming1 a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "OpRenaming1" [a', b'] []) att2
    OpRenaming2 a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "OpRenaming2" [a', b', c', d'] []) att4
    TermMap a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TermMap" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SortRenaming" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SortRenaming a' b') }}
    ShAAppl "LabelRenaming" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, LabelRenaming a' b') }}
    ShAAppl "OpRenaming1" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, OpRenaming1 a' b') }}
    ShAAppl "OpRenaming2" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, OpRenaming2 a' b' c' d') }}}}
    ShAAppl "TermMap" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TermMap a' b') }}
    u -> fromShATermError "Renaming" u

instance ShATermConvertible ToPartRenaming where
  toShATermAux att0 xv = case xv of
    To a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "To" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "To" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, To a' b') }}
    u -> fromShATermError "ToPartRenaming" u

instance ShATermConvertible Statement where
  toShATermAux att0 xv = case xv of
    ImportStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ImportStmnt" [a'] []) att1
    SortStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SortStmnt" [a'] []) att1
    SubsortStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SubsortStmnt" [a'] []) att1
    OpStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpStmnt" [a'] []) att1
    EqStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EqStmnt" [a'] []) att1
    MbStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MbStmnt" [a'] []) att1
    RlStmnt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "RlStmnt" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ImportStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ImportStmnt a') }
    ShAAppl "SortStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SortStmnt a') }
    ShAAppl "SubsortStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SubsortStmnt a') }
    ShAAppl "OpStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpStmnt a') }
    ShAAppl "EqStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EqStmnt a') }
    ShAAppl "MbStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MbStmnt a') }
    ShAAppl "RlStmnt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, RlStmnt a') }
    u -> fromShATermError "Statement" u

instance ShATermConvertible Import where
  toShATermAux att0 xv = case xv of
    Including a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Including" [a'] []) att1
    Extending a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Extending" [a'] []) att1
    Protecting a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Protecting" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Including" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Including a') }
    ShAAppl "Extending" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Extending a') }
    ShAAppl "Protecting" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Protecting a') }
    u -> fromShATermError "Import" u

instance ShATermConvertible SubsortDecl where
  toShATermAux att0 xv = case xv of
    Subsort a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Subsort" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Subsort" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Subsort a' b') }}
    u -> fromShATermError "SubsortDecl" u

instance ShATermConvertible Operator where
  toShATermAux att0 xv = case xv of
    Op a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Op" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Op" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Op a' b' c' d') }}}}
    u -> fromShATermError "Operator" u

instance ShATermConvertible Membership where
  toShATermAux att0 xv = case xv of
    Mb a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Mb" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Mb" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Mb a' b' c' d') }}}}
    u -> fromShATermError "Membership" u

instance ShATermConvertible Equation where
  toShATermAux att0 xv = case xv of
    Eq a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Eq" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Eq" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Eq a' b' c' d') }}}}
    u -> fromShATermError "Equation" u

instance ShATermConvertible Rule where
  toShATermAux att0 xv = case xv of
    Rl a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Rl" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Rl" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Rl a' b' c' d') }}}}
    u -> fromShATermError "Rule" u

instance ShATermConvertible Condition where
  toShATermAux att0 xv = case xv of
    EqCond a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "EqCond" [a', b'] []) att2
    MbCond a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MbCond" [a', b'] []) att2
    MatchCond a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MatchCond" [a', b'] []) att2
    RwCond a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "RwCond" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EqCond" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, EqCond a' b') }}
    ShAAppl "MbCond" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MbCond a' b') }}
    ShAAppl "MatchCond" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MatchCond a' b') }}
    ShAAppl "RwCond" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, RwCond a' b') }}
    u -> fromShATermError "Condition" u

instance ShATermConvertible Attr where
  toShATermAux att0 xv = case xv of
    Assoc -> return $ addATerm (ShAAppl "Assoc" [] []) att0
    Comm -> return $ addATerm (ShAAppl "Comm" [] []) att0
    Idem -> return $ addATerm (ShAAppl "Idem" [] []) att0
    Iter -> return $ addATerm (ShAAppl "Iter" [] []) att0
    Id a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Id" [a'] []) att1
    LeftId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "LeftId" [a'] []) att1
    RightId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "RightId" [a'] []) att1
    Strat a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Strat" [a'] []) att1
    Memo -> return $ addATerm (ShAAppl "Memo" [] []) att0
    Prec a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Prec" [a'] []) att1
    Gather a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Gather" [a'] []) att1
    Format a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Format" [a'] []) att1
    Ctor -> return $ addATerm (ShAAppl "Ctor" [] []) att0
    Config -> return $ addATerm (ShAAppl "Config" [] []) att0
    Object -> return $ addATerm (ShAAppl "Object" [] []) att0
    Msg -> return $ addATerm (ShAAppl "Msg" [] []) att0
    Frozen a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Frozen" [a'] []) att1
    Poly a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Poly" [a'] []) att1
    Special a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Special" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Assoc" [] _ -> (att0, Assoc)
    ShAAppl "Comm" [] _ -> (att0, Comm)
    ShAAppl "Idem" [] _ -> (att0, Idem)
    ShAAppl "Iter" [] _ -> (att0, Iter)
    ShAAppl "Id" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Id a') }
    ShAAppl "LeftId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, LeftId a') }
    ShAAppl "RightId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, RightId a') }
    ShAAppl "Strat" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Strat a') }
    ShAAppl "Memo" [] _ -> (att0, Memo)
    ShAAppl "Prec" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Prec a') }
    ShAAppl "Gather" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Gather a') }
    ShAAppl "Format" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Format a') }
    ShAAppl "Ctor" [] _ -> (att0, Ctor)
    ShAAppl "Config" [] _ -> (att0, Config)
    ShAAppl "Object" [] _ -> (att0, Object)
    ShAAppl "Msg" [] _ -> (att0, Msg)
    ShAAppl "Frozen" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Frozen a') }
    ShAAppl "Poly" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Poly a') }
    ShAAppl "Special" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Special a') }
    u -> fromShATermError "Attr" u

instance ShATermConvertible StmntAttr where
  toShATermAux att0 xv = case xv of
    Label a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Label" [a'] []) att1
    Metadata a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Metadata" [a'] []) att1
    Owise -> return $ addATerm (ShAAppl "Owise" [] []) att0
    Nonexec -> return $ addATerm (ShAAppl "Nonexec" [] []) att0
    Print a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Print" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Label" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Label a') }
    ShAAppl "Metadata" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Metadata a') }
    ShAAppl "Owise" [] _ -> (att0, Owise)
    ShAAppl "Nonexec" [] _ -> (att0, Nonexec)
    ShAAppl "Print" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Print a') }
    u -> fromShATermError "StmntAttr" u

instance ShATermConvertible Hook where
  toShATermAux att0 xv = case xv of
    IdHook a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "IdHook" [a', b'] []) att2
    OpHook a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "OpHook" [a', b', c', d'] []) att4
    TermHook a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TermHook" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "IdHook" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, IdHook a' b') }}
    ShAAppl "OpHook" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, OpHook a' b' c' d') }}}}
    ShAAppl "TermHook" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TermHook a' b') }}
    u -> fromShATermError "Hook" u

instance ShATermConvertible Term where
  toShATermAux att0 xv = case xv of
    Const a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Const" [a', b'] []) att2
    Var a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Var" [a', b'] []) att2
    Apply a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Apply" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Const" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Const a' b') }}
    ShAAppl "Var" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Var a' b') }}
    ShAAppl "Apply" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Apply a' b' c') }}}
    u -> fromShATermError "Term" u

instance ShATermConvertible Type where
  toShATermAux att0 xv = case xv of
    TypeSort a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypeSort" [a'] []) att1
    TypeKind a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypeKind" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeSort" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypeSort a') }
    ShAAppl "TypeKind" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypeKind a') }
    u -> fromShATermError "Type" u

instance ShATermConvertible Sort where
  toShATermAux att0 xv = case xv of
    SortId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SortId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SortId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SortId a') }
    u -> fromShATermError "Sort" u

instance ShATermConvertible Kind where
  toShATermAux att0 xv = case xv of
    KindId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "KindId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "KindId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, KindId a') }
    u -> fromShATermError "Kind" u

instance ShATermConvertible ParamId where
  toShATermAux att0 xv = case xv of
    ParamId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ParamId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ParamId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ParamId a') }
    u -> fromShATermError "ParamId" u

instance ShATermConvertible ViewId where
  toShATermAux att0 xv = case xv of
    ViewId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ViewId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ViewId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ViewId a') }
    u -> fromShATermError "ViewId" u

instance ShATermConvertible ModId where
  toShATermAux att0 xv = case xv of
    ModId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ModId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ModId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ModId a') }
    u -> fromShATermError "ModId" u

instance ShATermConvertible LabelId where
  toShATermAux att0 xv = case xv of
    LabelId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "LabelId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "LabelId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, LabelId a') }
    u -> fromShATermError "LabelId" u

instance ShATermConvertible OpId where
  toShATermAux att0 xv = case xv of
    OpId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpId a') }
    u -> fromShATermError "OpId" u

instance ShATermConvertible Morphism where
  toShATermAux att0 xv = case xv of
    Morphism a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "Morphism" [a', b', c', d', e',
                                             f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, Morphism a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "Morphism" u

_tcMorphismTc :: TyCon
_tcMorphismTc = mkTyCon "Maude.Morphism.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tcMorphismTc []

instance ShATermConvertible Sentence where
  toShATermAux att0 xv = case xv of
    Membership a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Membership" [a'] []) att1
    Equation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Equation" [a'] []) att1
    Rule a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Rule" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Membership" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Membership a') }
    ShAAppl "Equation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Equation a') }
    ShAAppl "Rule" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Rule a') }
    u -> fromShATermError "Sentence" u

_tcSentenceTc :: TyCon
_tcSentenceTc = mkTyCon "Maude.Sentence.Sentence"
instance Typeable Sentence where
    typeOf _ = mkTyConApp _tcSentenceTc []

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "Sign" [a', b', c', d', e', f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, Sign a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "Sign" u

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "Maude.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Sort a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Sort" [a'] []) att1
    Kind a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Kind" [a'] []) att1
    Labl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Labl" [a'] []) att1
    Operator a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Operator" [a', b', c'] []) att3
    OpWildcard a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpWildcard" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sort" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Sort a') }
    ShAAppl "Kind" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Kind a') }
    ShAAppl "Labl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Labl a') }
    ShAAppl "Operator" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Operator a' b' c') }}}
    ShAAppl "OpWildcard" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpWildcard a') }
    u -> fromShATermError "Symbol" u

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "Maude.Symbol.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []
