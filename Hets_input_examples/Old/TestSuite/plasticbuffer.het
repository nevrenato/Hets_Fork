logic CASL.FOL

spec PlasticBuffer = 

sorts 
      ST;
      mem;
      elem 

ops
      fifo : ST;
      lifo : ST;
      new : ST -> mem;
      write:ST * mem* elem -> mem; 
      read : ST * mem -> elem;
      del: ST * mem -> mem

preds 
      shift : ST × ST;
      Def_mem : ST × mem;
      Def_elem : ST × elem; 
      D_mem:ST ×mem; 
      D_elem:ST × elem

forall  e:elem; w : ST; m : mem
	.Def_mem(w, new(w))
	.Def_mem(w, m) /\ Def_elem(w, e) <=> Def_mem(w, write(w, m, e))
	.Def_mem(w, del(w, m)) => Def_mem(w, m)
	.Def_elem(w, read(w, m)) => Def_mem(w, m)
	.D_mem(w, m)
	.D_elem(w, e)



forall  e : elem; w, v : ST; m : mem
	.new(w) = new(v)
	. write(w, m, e) = write(v, m, e)
	.Def_mem(w, del(w, m)) <=> Def_mem(v, del(v, m))
	. Def_elem(w, read(w, m)) <=> Def_elem(v, read(v, m))



forall  e : elem; m,n : mem; w, y, z : ST
	. (Def_mem(lifo,m) /\ Def_elem (lifo,e)) => (Def_mem(lifo,m) /\ del(lifo,write(lifo,m,e)) = m)
	. (Def_mem(lifo,m) /\ Def_elem (lifo,e)) => (Def_elem(lifo,e) /\ read(lifo,write(lifo,m,e)) = e)
	. Def_elem(fifo,e) => (Def_elem(fifo,e) /\ read(fifo,write(fifo,new(fifo),e)) = e)
	. Def_elem (fifo,e) => (Def_mem(fifo,new(fifo)) /\ del(fifo,write(fifo,new(fifo),e)) = new(fifo))
	. (Def_mem(fifo,m) /\ Def_elem(fifo,e)) => (Def_elem(fifo,read(fifo,m)) /\ read(fifo,m) = read(fifo,m) => Def_elem(fifo,read(fifo,m)) /\ read(fifo,write(fifo,m,e)) = read(fifo,m))
	. (Def_mem(fifo,m) /\ Def_elem(fifo,e)) =>(Def_elem(fifo,read(fifo,m)) /\ read(fifo,m) = read(fifo,m) => Def_mem(fifo,write(fifo,del(fifo,m),e)) /\ del(fifo,write(fifo,m,e)) = write(fifo,del(fifo,m),e)) 


%%        . exists  v,u: ST  . (shift(fifo,v) /\ fifo=v) /\(shift(lifo,u) /\ lifo=u)
        . exists  v: ST  . (shift(fifo,v) /\ fifo=v) /\ exists  u: ST .(shift(lifo,u) /\ lifo=u)

%%% First property

%% [shift] n=write(m,e) <=> n=write(m,e) 
   	  		
      . (shift(w,z) => (n = write(z, m,e))) => (n = write(w,m,e)) %implied
      	    %% SPASS result: time-out     	 
      .  (n = write(w,m,e))=>(shift(w,z) => (n = write(z, m,e)))  %implied
            %% SPASS result: proved      	 

%% <shift> n=write(m,e) <=> n=write(m,e) 

         . (exists  v:ST. shift(z,v) /\ n = write(z, m,e)) => n = write(w, m,e) %implied
	     %% SPASS result: proved      	 
         . n = write(w, m,e) => (exists  v:ST. shift(z,v) /\ n = write(z, m,e)) %implied
      	    %% SPASS result: time-out     	 






%%% Second property




%%forall m,n,o,p :mem; e:elem; z,s,t:ST 
   %%    . (n = del(z,o)) /\ (shift(z,s)=> o = del(s,m)) <=> (shift(z,t) =>(n = del(t,p)) /\ (p = del(z,m)) %implied


forall m,n,o,p :mem; e:elem; z,s,t:ST 
%%       . (n = del(z,o) /\ (shift(z,s)=> o = del(s,m)))  <=> ((shift(z,t) =>n = del(t,p)) /\ (p = del(z,m)))	%implied
            . (n = del(z,o) /\ (shift(z,s)=> o = del(s,m)))  => ((shift(z,t) =>n = del(t,p)) /\ (p = del(z,m)))	%implied
            . ((shift(z,t) =>n = del(t,p)) /\ (p = del(z,m)))  =>  (n = del(z,o) /\ (shift(z,s)=> o = del(s,m)))  	%implied

	    .n=del(fifo,o) /\ o=del(lifo, m) <=> n=del(lifo,p) /\ p=del(fifo,m) %implied
   .n=del(lifo,o) /\ o=del(fifo, m) <=> n=del(fifo,p) /\ p=del(lifo,m) %implied



end




