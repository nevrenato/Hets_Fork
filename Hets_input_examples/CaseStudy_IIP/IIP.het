
logic Hybrid

spec IIP_top =

        nominals On,Off,Test
        modalities Turn_on,Turn_off,AllOK

        %% the states are different from each other
        . @On not (Here Off \/ Here Test)
        . @Off not (Here On \/ Here Test)
        . @Test not (Here On \/ Here Off)

        %% need to restrict the existing states in the universe?
        
        %% Restricing the relations between states
        . @On (<Turn_off> Here Off) /\ ([Turn_off] Here Off)
        . @Off (<Turn_on> Here Test) /\ ([Turn_on] Here Test)
        . @Test (<AllOK> Here On) /\ ([AllOK] Here On)

        %% Giving to each modality the corresponding state 
        . <Turn_off> true => Here On
        . <Turn_on> true => Here Off
        . <AllOK> true => Here Test

        %% properties
        . @On <Turn_off> <Turn_on> <AllOK> Here On %implied %(cyclic)%
        . @On [Turn_off] [Turn_on] [AllOK] Here On  %implied %(deterministic)%

        %% The On state is ONLY reachable when ALL diagnostic tests sucessfully passed
        . ( <AllOK> Here On => Here Test ) /\ not (<Turn_off> Here On \/ <Turn_on> Here On) %implied %(OnOnlybyTest)%

end

spec IIP_mid =

        %% Note the overloading, where we use Sus as modality and nominal
        nominals Nor,Sus,Test,Error,Off
        modalities Turn_on,Turn_off,AllOK,NotAllOK,Sus,Res

        %% the states are different from each other
        . @Nor not (Here Sus \/ Here Test \/ Here Error \/ Here Off)
        . @Sus not (Here Test \/ Here Error \/ Here Off)
        . @Test not (Here Error \/ Here Off)
        . @Error not (Here Off)
        %% need to restrict the existing states in the universe?

        %% Restricing the relations between states
        . @Off (<Turn_on> Here Test) /\ ([Turn_on] Here Test)
        . @Test (<AllOK> Here Nor) /\ ([AllOK] Here Nor)
        . @Test (<NotAllOK> Here Error) /\ ([NotAllOK] Here Error)
        . @Nor (<Turn_off> Here Off) /\ ([Turn_off] Here Off) 
        . @Nor (<Sus> Here Sus) /\ ([Sus] Here Sus)
        . @Sus (<Res> Here Nor) /\ ([Res] Here Nor)

        %% Giving to each modality the corresponding state 
        . <Turn_on> true => Here Off
        . <NotAllOK> true => Here Test
        . <AllOK> true => Here Test
        . <Sus> true => Here Nor 
        . <Turn_off> true => Here Nor
        . <Res> true => Here Sus

        %% properties
        . @Off <Turn_on> <AllOK> <Sus> <Res> <Turn_off> Here Off %implied %(has a cyclic path)%
        . @Off [Turn_on] [AllOK] [Sus] [Res] [Turn_off] Here Off %implied %(whatever)%
        . (<Turn_on> true \/ <NotAllOK> true \/ 
           <AllOK> true \/ <Sus> true \/ <Turn_off> true \/ <Res> true) => not Here Error %implied %(error is final)%   

end

spec IIP_low_KripkeF =

nominals BnBo,BtBo,Su1,Su2,Bn,Bt
        modalities Sus,Res,Go_Bo,Go_Bt

        %% the states are different from each other, and are the only in the universe
        . @BnBo not (Here BtBo \/ Here Su1 \/ Here Su2 \/ Here Bn \/ Here Bt)
        . @BtBo not (Here Su1 \/ Here Su2 \/ Here Bn \/ Here Bt)
        . @Su1 not (Here Su2 \/ Here Bn \/ Here Bt)
        . @Su2 not (Here Bn \/ Here Bt)
        . @Bn not (Here Bt)
        . Here BnBo \/ Here BtBo \/ Here Su1 \/ Here Su2 \/ Here Bn \/ Here Bt

        %% specifying relations between states
        . @BnBo ((<Sus> Here Su1) /\ (<Res> Here Bn))
        . @BtBo ((<Sus> Here Su2) /\ (<Res> Here Bt))
        . @Su1 (<Res> Here Bn) /\ @Su2 (<Res> Here Bt)
        . @Bn ((<Sus> Here Su1) /\ (<Go_Bo> Here BnBo) /\ (<Go_Bt> Here Bt))
        . @Bt ((<Sus> Here Su2) /\ (<Res> Here Bn) /\ (<Go_Bo> Here BtBo)) 

        %% Cutting all other relations
        %% This, is fastidious, but follows a pattern
        %% First we need to restrict the origins. Then from the origins, restrict the destination
        %% Using this pattern we just need to replace nominals and modalities.
        %% Also need to throw disjunctions/conjunctions when more states share the modality
        %% Follows an example
        %% Restrict origin.
        . <Go_Bt> true => Here Bn
        %% From the origin restrict the destination
        . @Bn [Go_Bt] Here Bt

        %% Folows an example, with shared modalities
        %% Restricting the origin the destination in one sentence
        . (<Go_Bo> true => Here Bn \/ Here Bt) /\ (@Bn [Go_Bo] Here BnBo) /\ (@Bt [Go_Bo] Here BtBo)
        %% Because they share a modality we also need to restrict the modality among them
        . (<Go_Bo> Here BnBo => Here Bn) /\ (<Go_Bo> Here BtBo => Here Bt)

        %% Now for the others
        . (<Sus> true => Here Bn \/ Here BnBo \/ Here Bt \/ Here BtBo)
        . @Bn [Sus] Here Su1 /\ @BnBo [Sus] Here Su1 /\ @Bt [Sus] Here Su2 /\ @BtBo [Sus] Here Su2
        . (<Sus> Here Su1 => (Here Bn \/ Here BnBo)) /\ (<Sus> Here Su2 => (Here Bt \/ Here BtBo))

        . (<Res> true => Here Su1 \/ Here Su2 \/ Here BtBo \/ Here Bt \/ Here BnBo )
        . @Su1 [Res] Here Bn /\ @Su2 [Res] Here Bt /\ @BtBo [Res] Here Bt /\ @Bt [Res] Here Bn /\ @BnBo [Res] Here Bn
        . (<Res> Here Bt => (Here Su2 \/ Here BtBo)) /\ (<Res> Here Bn => (Here Bt \/ Here BnBo \/ Here Su1))

        %% Properties (relations between states)
        . not (Here Su1 \/ Here Su2) => <Sus> (Here Su1 \/ Here Su2) %implied %(alwaysSuspendable)%
        . (Here Su1 \/ Here Su2) => <Res> (Here Bn \/ Here Bt) %implied %(afterAnySuspensionBolusAreLost)%
        . (Here BnBo \/ Here BtBo) => not <Go_Bo> true %implied %(beingInBolusModeIsNotPossibleToActivateBolus)%
        . <Go_Bo> true => <Go_Bo> (Here BnBo \/ Here BtBo) %implied %(BolusModeIsOnlyAchiveableByRequestOfTheUser)%
        %% how do I say : going to Bt, all existing (infinitary) paths can achieve Bn again . 
        %% Controled Quantifications Modalities / Infinitary formulas 2nd part 

end

spec HNat =

         sort Nat

         rigid ops 
                  0 : Nat
                  suc : Nat -> Nat
         
         forall n,m : Nat
                  . n = 0 \/ exists n' : Nat . n = suc(n') /\ not n = n'
                  . not suc(n) = 0
                  . suc(n) = suc(m) => n = m
 
         forall n : Nat . not suc(n) = n %implied %(notreflexive)% %%passed
         
         . exists n : Nat . true %implied %(atLeastOne)% %%passed
        
         . exists n,n' : Nat . not n = n' %implied %(atLeastTwo)% 

         rigid ops    __+__ : Nat*Nat -> Nat
 
         forall n,n',n'' : Nat
         . n + 0 = n
         . n + suc(n') = suc(n + n')
         . n + n' = n' + n
         . n + ( n' + n'') = ( n + n') + n''
        
        
         . forall n : Nat . 0 + n = n %implied %(neutralCommu)%


        rigid pred __ < __ : Nat*Nat

        forall a,b,c : Nat
        . not a < a
        . a < b => not b < a
        . a < b /\ b < c => a < b
        . a < b <=> exists d : Nat . not d = 0 /\ a + d = b 
        
        . a < suc(a) %implied %(sucBigger)% %%proved with eprover 
        . a < b => (a + c) < (b + c) %%(sumAlwaysAdds)% %%can be proved in CASL
        . a < b => a < b + c %(sumAlwaysAdds2nd)% %%can be proved in CASL
        . a + c < b => a < b %(sumAlwaysAdds3rd)% %%can be proved in CASL
        . not a = 0 => 0 < a %implied %(0isthelowestNat)% %%can be proved here


        rigid pred __ > __ : Nat*Nat
        
        forall a,b : Nat
        . a < b <=> b > a

        rigid pred __ <= __ : Nat*Nat

        forall a,b : Nat
        . a <= b <=> a < b \/ a = b

        rigid pred __ >= __ : Nat*Nat
        
        forall a,b : Nat
        . a >= b <=> a > b \/ a = b

        forall a,b,c : Nat
        . a >= b <=> b <= a %implied %(BigEqAsTheSymOfLesEq)%
        . a >= b => not a < b %implied %(RelBigEqWithLes)%
        . a >= b => a+c >= b %implied %(sumAlwaysAdds4th)% 
        . a >= b /\ c > 0 => a+c > b %implied %(sumAlwaysAdds5th)%  


        rigid op __ - __ : Nat*Nat -> Nat

        forall a,b : Nat
        . a <= b <=> a - b = 0
        . a > b <=> exists c : Nat . a - b = c <=> a = b + c

        forall a : Nat
        . suc(a) = a + suc(0) %implied %(defSuc)% 
        . suc(a) - a = suc(0) %implied %(The2ndleastdifference)%
        . (a + a) - a = a %implied %(1stSubNeutral)%
        . a - 0 = a %implied %(2ndSubNeutral)%
end


spec IIP_low =

        %% requirements alread met with the imports : 1,2,3,10,17,18
        %% requirements met so far : 1,2,3,4,7,8,9,10(in kripke models above),12,13,11
        %% The requirements nº5 and 6, refer to external factors, hence we cannot model them in a natural way
        %% The requirements listed include the spec below

        HNat then
        IIP_low_KripkeF then
        

        rigid ops 

                  max_flow : Nat %% max flow of insulin permitted
                  max_time : Nat %% the maximum time the pump can be in basal temporary
                  basal : Nat -> Nat %% The basal application, in later instances we could turn it in a pred
                  %% requirements nº12 and 13 are met, because is a function (simple and total). 22 (rigid)

                  tbasal : Nat -> Nat %% The basal temporary, in later instances we could turn it in a pred
                  ext_bolus : Nat -> Nat %% The extended bolus profile
                  ins_bolus : Nat -> Nat %% The instant bolus profile
        ops 
                  cur_flow : Nat -> Nat %% the current flow of insulin

                        
        %% basal profile must be valid
        %% basal_temporary must be valid

        %% For each state, the insulin methods that are active
        %% Requirements met here : 7,8,9,14,15,19

        forall t : Nat 
            . @Bn cur_flow(t) = basal(t) + ins_bolus(t)
            . @BnBo cur_flow(t) = basal(t) + ext_bolus(t)
            . @Bt cur_flow(t) = tbasal(t) + ins_bolus(t)
            . @BtBo cur_flow(t) = tbasal(t) + ext_bolus(t)
            . @Su1 cur_flow(t) = 0
            . @Su2 cur_flow(t) = 0 

        
 
        %% A temporary basal cannot last more than x minutes nº16
        . forall t : Nat .
                 not ( exists t1,t2 : Nat . (t2 - t1 >= max_time) /\ (t >= t1 /\ t <= t2) /\
                          forall t' : Nat . (t' >= t1 /\ t' <= t2) => 
                                  cur_flow(t') = tbasal(t') + ins_bolus(t') \/
                                  cur_flow(t') = tbasal(t') + ext_bolus(t')) 


        %% The normal bolus must be instantaneous nº20
        . forall t : Nat . not (ins_bolus(suc(t)) = 0) => ins_bolus(suc(suc(t))) = 0 /\ ins_bolus(t) = 0 

        %% The extended bolus must be constant along time nº21
        . forall t : Nat . not ext_bolus(suc(t)) = 0 => ext_bolus(t) = 0 \/ ext_bolus(t) = ext_bolus(suc(t)) 
   
        %% At any time the accumulated rate, can never be superior to the maximum rate established nº23
        . forall t : Nat . cur_flow(t) <= max_flow 
       
        %% Properties 
        forall t : Nat
                . @Bn basal(t) <= max_flow %implied %(onlyBasal)%
                . @Bn ins_bolus(t) <= max_flow %implied %(onlyBolus)%
                . @Bn cur_flow(t) >= basal(t) %implied %(atleastbasal)%
                . @Bn ins_bolus(t) > 0 => cur_flow(t) > cur_flow(suc(t)) %implied %(afterInsBolus)%
                . exists n,n' : Nat. @Su1 ( cur_flow(t) = n /\ <Res> cur_flow(t) = n' /\ not n > n' ) %implied %(afterSus)%
                . forall n : Nat . @Su1 cur_flow(t) = n => cur_flow(t) >= n %implied %(theflowistheleastpossible)%
                . cur_flow(t) > max_flow %implied %(contradiction)%
end

spec IIP_low_Alarm =

        IIP_low then

        rigid ops
         
                  low_thres : Nat  %% low limit of the deposit
                  alarm : Nat -> Nat %% The alarm period along time. If 0 the alarm is off
                  res : Nat -> Nat %% reservoir sensor along time
                  max_timeS : Nat %% The maximum time, that the pump can be in a suspended state 

        %% when the insulin reservoir is low, a periodic alarm should be sound nº4
        %% requirement rewritten : only when the insulin reservoir is low ...
        %% This axiom assumes that the alarm triggers in the same instant, that the low_threshold is detected
        . forall t : Nat . (res (t) < low_thres => alarm(t) > 0) /\ not (res(t) < low_thres) => alarm(t) = 0         

        %% If the pump is more than x minutes in the suspended state, a periodic alarm should be sounded nº11
        . forall t : Nat . 
                 (exists t1,t2 : Nat . (t2 - t1 >= max_timeS) /\ (t >= t1 /\ t <= t2) /\ 
                          forall t' : Nat . (t' >= t1 /\ t' <= t2) => cur_flow(t') = 0) => alarm(t) > 0

        end
