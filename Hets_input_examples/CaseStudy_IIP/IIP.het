logic Hybrid

spec IIP_top =

        nominals On,Off,Test
        modalities Turn_on,Turn_off,AllOK

        %% the states are different from each other
        . @On not (Here Off \/ Here Test)
        . @Off not (Here On \/ Here Test)
        . @Test not (Here On \/ Here Off)

        %% need to restrict the existing states in the universe?
        
        %% Restricing the relations between states
        . @On (<Turn_off> Here Off) /\ ([Turn_off] Here Off)
        . @Off (<Turn_on> Here Test) /\ ([Turn_on] Here Test)
        . @Test (<AllOK> Here On) /\ ([AllOK] Here On)

        %% Giving to each modality the corresponding state 
        . <Turn_off> true => Here On
        . <Turn_on> true => Here Off
        . <AllOK> true => Here Test

        %% properties
        . @On <Turn_off> <Turn_on> <AllOK> Here On %implied %(cyclic)%
        . @On [Turn_off] [Turn_on] [AllOK] Here On  %implied %(deterministic)%

        %% The On state is ONLY reachable when ALL diagnostic tests sucessfully passed
        . ( <AllOK> Here On => Here Test ) /\ not (<Turn_off> Here On \/ <Turn_on> Here On) %implied %(OnOnlybyTest)%

end

spec IIP_mid =

        %% Note the overloading, where we use Sus as modality and nominal
        nominals Nor,Sus,Test,Error,Off
        modalities Turn_on,Turn_off,AllOK,NotAllOK,Sus,Res

        %% the states are different from each other
        . @Nor not (Here Sus \/ Here Test \/ Here Error \/ Here Off)
        . @Sus not (Here Test \/ Here Error \/ Here Off)
        . @Test not (Here Error \/ Here Off)
        . @Error not (Here Off)
        %% need to restrict the existing states in the universe?

        %% Restricing the relations between states
        . @Off (<Turn_on> Here Test) /\ ([Turn_on] Here Test)
        . @Test (<AllOK> Here Nor) /\ ([AllOK] Here Nor)
        . @Test (<NotAllOK> Here Error) /\ ([NotAllOK] Here Error)
        . @Nor (<Turn_off> Here Off) /\ ([Turn_off] Here Off) 
        . @Nor (<Sus> Here Sus) /\ ([Sus] Here Sus)
        . @Sus (<Res> Here Nor) /\ ([Res] Here Nor)

        %% Giving to each modality the corresponding state 
        . <Turn_on> true => Here Off
        . <NotAllOK> true => Here Test
        . <AllOK> true => Here Test
        . <Sus> true => Here Nor 
        . <Turn_off> true => Here Nor
        . <Res> true => Here Sus

        %% properties
        . @Off <Turn_on> <AllOK> <Sus> <Res> <Turn_off> Here Off %implied %(has a cyclic path)%
        . @Off [Turn_on] [AllOK] [Sus] [Res] [Turn_off] Here Off %implied %(whatever)%
        . (<Turn_on> true \/ <NotAllOK> true \/ 
           <AllOK> true \/ <Sus> true \/ <Turn_off> true \/ <Res> true) => not Here Error %implied %(error is final)%   

end

spec IIP_low_KripkeF =

nominals BnBo,BtBo,Su1,Su2,Bn,Bt
        modalities Sus,Res,Go_Bo,Go_Bt

        %% the states are different from each other, and are the only in the universe
        . @BnBo not (Here BtBo \/ Here Su1 \/ Here Su2 \/ Here Bn \/ Here Bt)
        . @BtBo not (Here Su1 \/ Here Su2 \/ Here Bn \/ Here Bt)
        . @Su1 not (Here Su2 \/ Here Bn \/ Here Bt)
        . @Su2 not (Here Bn \/ Here Bt)
        . @Bn not (Here Bt)
        . Here BnBo \/ Here BtBo \/ Here Su1 \/ Here Su2 \/ Here Bn \/ Here Bt

        %% specifying relations between states
        . @BnBo ((<Sus> Here Su1) /\ (<Res> Here Bn))
        . @BtBo ((<Sus> Here Su2) /\ (<Res> Here Bt))
        . @Su1 (<Res> Here Bn) /\ @Su2 (<Res> Here Bt)
        . @Bn ((<Sus> Here Su1) /\ (<Go_Bo> Here BnBo) /\ (<Go_Bt> Here Bt))
        . @Bt ((<Sus> Here Su2) /\ (<Res> Here Bn) /\ (<Go_Bo> Here BtBo)) 

        %% Cutting all other relations
        %% This, is fastidious, but follows a pattern
        %% First we need to restrict the origins. Then from the origins, restrict the destination
        %% Using this pattern we just need to replace nominals and modalities.
        %% Also need to throw disjunctions/conjunctions when more states share the modality
        %% Follows an example
        %% Restrict origin.
        . <Go_Bt> true => Here Bn
        %% From the origin restrict the destination
        . @Bn [Go_Bt] Here Bt

        %% Folows an example, with shared modalities
        %% Restricting the origin the destination in one sentence
        . (<Go_Bo> true => Here Bn \/ Here Bt) /\ (@Bn [Go_Bo] Here BnBo) /\ (@Bt [Go_Bo] Here BtBo)
        %% Because they share a modality we also need to restrict the modality among them
        . (<Go_Bo> Here BnBo => Here Bn) /\ (<Go_Bo> Here BtBo => Here Bt)

        %% Now for the others
        . (<Sus> true => Here Bn \/ Here BnBo \/ Here Bt \/ Here BtBo)
        . @Bn [Sus] Here Su1 /\ @BnBo [Sus] Here Su1 /\ @Bt [Sus] Here Su2 /\ @BtBo [Sus] Here Su2
        . (<Sus> Here Su1 => (Here Bn \/ Here BnBo)) /\ (<Sus> Here Su2 => (Here Bt \/ Here BtBo))

        . (<Res> true => Here Su1 \/ Here Su2 \/ Here BtBo \/ Here Bt \/ Here BnBo )
        . @Su1 [Res] Here Bn /\ @Su2 [Res] Here Bt /\ @BtBo [Res] Here Bt /\ @Bt [Res] Here Bn /\ @BnBo [Res] Here Bn
        . (<Res> Here Bt => (Here Su2 \/ Here BtBo)) /\ (<Res> Here Bn => (Here Bt \/ Here BnBo \/ Here Su1))

        %% Properties (relations between states)
        . not (Here Su1 \/ Here Su2) => <Sus> (Here Su1 \/ Here Su2) %implied %(alwaysSuspendable)%
        . (Here Su1 \/ Here Su2) => <Res> (Here Bn \/ Here Bt) %implied %(afterAnySuspensionBolusAreLost)%
        . (Here BnBo \/ Here BtBo) => not <Go_Bo> true %implied %(beingInBolusModeIsNotPossibleToActivateBolus)%
        . <Go_Bo> true => <Go_Bo> (Here BnBo \/ Here BtBo) %implied %(BolusModeIsOnlyAchiveableByRequestOfTheUser)%
        %% how do I say : going to Bt, all existing (infinitary) paths can achieve Bn again . 
        %% Controled Quantifications Modalities / Infinitary formulas 2nd part 

end

spec HNat =

         sort Nat

         rigid ops 
                  0 : Nat
                  suc : Nat -> Nat
         
         forall n,m : Nat
                  . n = 0 \/ exists n' : Nat . n = suc(n') /\ not n = n'
                  . not suc(n) = 0
                  . suc(n) = suc(m) => n = m
 
         forall n : Nat . not suc(n) = n %implied %(notreflexive)% %%passed
         
         . exists n : Nat . true %implied %(atLeastOne)% %%passed
        
         . exists n,n' : Nat . not n = n' %implied %(atLeastTwo)% 

         rigid ops    __+__ : Nat*Nat -> Nat
 
         forall n,n',n'' : Nat
         . n + 0 = n
         . n + suc(n') = suc(n + n')
         . n + n' = n' + n
         . n + ( n' + n'') = ( n + n') + n''
        
        
         . forall n : Nat . 0 + n = n %implied %(neutralCommu)%


        rigid pred __ < __ : Nat*Nat

        forall a,b,c : Nat
        . not a < a
        . a < b => not b < a
        . a < b /\ b < c => a < b
        . a < b <=> exists d : Nat . not d = 0 /\ a + d = b 
        
        . a < suc(a) %implied %(sucBigger)% %%proved with eprover 
        . a < b => (a + c) < (b + c) %%(sumAlwaysAdds)% %%can be proved in CASL
        . a < b => a < b + c %(sumAlwaysAdds2nd)% %%can be proved in CASL
        . a + c < b => a < b %(sumAlwaysAdds3rd)% %%can be proved in CASL
        . not a = 0 => 0 < a %implied %(0isthelowestNat)% %%can be proved here


        rigid pred __ > __ : Nat*Nat
        
        forall a,b : Nat
        . a < b <=> b > a

        rigid pred __ <= __ : Nat*Nat

        forall a,b : Nat
        . a <= b <=> a < b \/ a = b

        rigid pred __ >= __ : Nat*Nat
        
        forall a,b : Nat
        . a >= b <=> a > b \/ a = b

        forall a,b,c : Nat
        . a >= b <=> b <= a %implied %(BigEqAsTheSymOfLesEq)%
        . a >= b => not a < b %implied %(RelBigEqWithLes)%
        . a >= b => a+c >= b %implied %(sumAlwaysAdds4th)% 
        . a >= b /\ c > 0 => a+c > b %implied %(sumAlwaysAdds5th)%  


        rigid op __ - __ : Nat*Nat -> Nat

        forall a,b : Nat
        . a <= b <=> a - b = 0
        . a > b <=> (exists c : Nat . (a - b = c <=> a + c = b) /\ c > 0)
        
        forall a : Nat
        . suc(a) = a + suc(0) %implied %(defSuc)% 
        . suc(a) - a = suc(0) %implied %(The2ndleastdifference)%
        . (a + a) - a = a %implied %(1stSubNeutral)%
        . a - 0 = a %implied %(2ndSubNeutral)%

        forall a,b,c : Nat
        . a + b <= c => a <= c %implied %(Inclusion)%

end


spec IIP_low =


        HNat then
        IIP_low_KripkeF then
        

        rigid ops 

                  max_flow : Nat %% max flow of insulin permitted
                  max_time : Nat %% the maximum time the pump can be in basal temporary
                  basal : Nat -> Nat %% The basal application, in later instances we could turn it in a pred

                  tbasal : Nat -> Nat %% The basal temporary, in later instances we could turn it in a pred
                  ext_bolus : Nat -> Nat %% The extended bolus profile
                  ins_bolus : Nat -> Nat %% The instant bolus profile
        ops 
                  cur_flow : Nat -> Nat %% the current flow of insulin

                        
        forall t : Nat 
            . @Bn cur_flow(t) = basal(t) 
            . @BnBo cur_flow(t) = basal(t) + ext_bolus(t)
            . @Bt cur_flow(t) = tbasal(t) 
            . @BtBo cur_flow(t) = tbasal(t) + ext_bolus(t)
            . @Su1 cur_flow(t) = 0
            . @Su2 cur_flow(t) = 0 

        
 

        %% The normal bolus must be instantaneous nº20
%%        . forall t : Nat . not (ins_bolus(suc(t)) = 0) => ins_bolus(suc(suc(t))) = 0 /\ ins_bolus(t) = 0 

        %% The extended bolus must be constant along time nº21
%%        . forall t : Nat . not ext_bolus(suc(t)) = 0 => ext_bolus(t) = 0 \/ ext_bolus(t) = ext_bolus(suc(t)) 
   
        . forall t : Nat . cur_flow(t) <= max_flow 
       
        %% Properties 
        forall t : Nat
                . @Bn cur_flow(t) <= max_flow %implied %(helper1)%
                . @Bn basal(t) <= max_flow %implied %(onlyBasal)%
                . @Bn cur_flow(t) >= basal(t) %implied %(atleastbasal)%
                . exists n,n' : Nat. @Su1 ( cur_flow(t) = n /\ <Res> cur_flow(t) = n' /\ n' >= n ) %implied %(afterSus)%
                . forall n : Nat . @Su1 cur_flow(t) = n => cur_flow(t) >= n %implied %(theflowistheleastpossible)%
                . (Here Bn \/ Here BnBo) => cur_flow(t) >= basal(t) %(helper2)%
                . (Here Bt \/ Here BtBo) => cur_flow(t) >= tbasal(t) %(helper2a)%
                . @BnBo cur_flow(t) >= basal(t) %implied %(helper3)%
                . @Bt cur_flow(t) >= tbasal(t) %implied %(helper4)%
                . @BtBo cur_flow(t) >= tbasal(t) %implied %(helper5)%
                . not (Here Su1 \/ Here Su2) => cur_flow(t) >= basal(t) \/ cur_flow(t) >= tbasal(t) %implied %(mustbeworking)%
                . not ( cur_flow(t) = basal(t) ) => not (Here Bn) %implied %(contradiction)%

        . (forall t : Nat . ext_bolus(t) = 0) => @Bn cur_flow(t) = basal(t) /\ @BnBo cur_flow(t) = basal(t) %implied %(helper6)% 
        . (forall t : Nat . ext_bolus(t) = 0) => 
                (forall t : Nat . exists n : Nat . @Bn cur_flow(t) = n /\ @BnBo cur_flow(t) = n) %implied %(states_same_flow)%


        . forall t : Nat . exists n,n' : Nat . @Bn cur_flow(t) = n /\ @BnBo cur_flow(t) = n' /\ n' >= n %implied %(curflow_betw_states)% 
        
end

spec IIP_lowPar =
        
        HNat then
        IIP_low_KripkeF then
        

        ops 
                  cur_flow : Nat -> Nat;
                  basal : Nat ->? Nat; 
                  tbasal : Nat ->? Nat;
                  ext_bolus : Nat ->? Nat;
          

        %% presentation the axioms of defininig partiality
        forall t : Nat
                    . Here BnBo => basal(t) =e= basal(t) /\ ext_bolus(t) =e= ext_bolus(t) 
                    . Here BtBo => tbasal(t) =e= tbasal(t) /\ ext_bolus(t) =e= ext_bolus(t)  
                    . not (Here BnBo \/ Here BtBo) => not ext_bolus(t) =e= ext_bolus(t)
                    . (Here Bn) => (basal(t) =e= basal(t))
                    . (Here Bt) => (tbasal(t) =e= tbasal(t))
                    . not (Here Bn \/ Here BnBo) => not (basal(t) =e= basal(t))
                    . not (Here Bt \/ Here BtBo) => not (tbasal(t) =e= tbasal(t))               
        

          %% applying existential rigidification manually 
        forall t : Nat 
                  . exists n : Nat . @Bn basal(t) = n /\ @BnBo basal(t) = n
                  . exists n : Nat . @BnBo ext_bolus(t) = n /\ @BtBo ext_bolus(t) = n
                  . exists n : Nat . @Bt tbasal(t) = n /\ @BtBo tbasal(t) = n


          %% characterising the cur_flow
          forall t : Nat 
                    . not ext_bolus(t) =e= ext_bolus(t) /\ def(basal(t)) => cur_flow(t) = basal(t) 
                    . not (ext_bolus(t) =e= ext_bolus(t)) /\ def(tbasal(t)) => cur_flow(t) = tbasal(t)
                    . def(basal(t)) /\ def(ext_bolus(t)) => cur_flow(t) = basal(t) + ext_bolus(t) 
                    . def(tbasal(t)) /\ def(ext_bolus(t)) => cur_flow(t) = tbasal(t) + ext_bolus(t)


        %% properties to prove
          . forall t : Nat . def(ext_bolus(t)) => ext_bolus(t) > 0       
          . not (forall t : Nat . cur_flow(t) =e= basal(t)) <=> not (Here Bn) %implied %(state equiv)%  
          . forall t : Nat . basal(t) =e= basal(t) <=> (Here Bn \/ Here BnBo) %implied %(state equiv2)%
          . (Here Bn /\ Here Bt) %implied %(incon)%
          . forall t : Nat . not (ext_bolus(t) =e= ext_bolus(t)) /\ def(basal(t)) <=> Here Bn %implied %(test)%      

end
