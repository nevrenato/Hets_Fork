logic CASL

spec Nat =

         sort Nat

         ops 
                  0 : Nat
                  suc : Nat -> Nat
         
         forall n,m : Nat
                  . n = 0 \/ exists n' : Nat . n = suc(n') /\ not n = n'
                  . not suc(n) = 0
                  . suc(n) = suc(m) => n = m
 
         forall n : Nat . not suc(n) = n %implied %(notreflexive)% %%passed
         
         . exists n : Nat . n = n %implied %(atLeastOne)% %%passed
        
         . exists n,n' : Nat . not n = n' %implied %(atLeastTwo)% 

         ops    __+__ : Nat*Nat -> Nat
 
         forall n,n',n'' : Nat
         . n + 0 = n
         . n + suc(n') = suc(n + n')
         . n + n' = n' + n
         . n + ( n' + n'') = ( n + n') + n''
        
        
         . forall n : Nat . 0 + n = n %implied %(neutralCommu)%


        pred __ < __ : Nat*Nat

        forall a,b,c : Nat
        . not a < a
        . a < b => not b < a
        . a < b /\ b < c => a < b
        . a < b <=> exists d : Nat . not d = 0 /\ a + d = b 
        
        . a < suc(a) %implied %(sucBigger)% 
        . a < b => (a + c) < (b + c) %implied %(sumAlwaysAdds)%
        . a < b => a < b + c %implied %(sumAlwaysAdds2nd)%
        . a + c < b => a < b %implied %(sumAlwaysAdds3rd)%
        . not a = 0 => 0 < a %implied %(0isthelowestNat)%

          pred __ > __ : Nat*Nat
  
          forall a,b : Nat
          . a < b <=> b > a
 
          pred __ <= __ : Nat*Nat
  
          forall a,b : Nat
          . a <= b <=> a < b \/ a = b
 
          pred __ >= __ : Nat*Nat
         
          forall a,b : Nat
          . a >= b <=> a > b \/ a = b

          forall a,b,c : Nat
          . a >= b <=> b <= a %implied %(BigEqAsTheSymOfLesEq)% 
          . a >= b => not a < b %implied %(RelBigEqWithLes)%
          . a >= b => a+c >= b %implied %(sumAlwaysAdds4th)%
          . a >= b /\ c > 0 => a+c > b %implied %(sumAlwaysAdds5th)% 
          . not ((a > b) /\ (a <= b)) %implied %(onlyoneHypo)%      
        
          op __ - __ : Nat*Nat -> Nat

          forall a,b : Nat
          . a <= b <=> a - b = 0
          . a > b <=> (exists c : Nat . (a - b = c <=> a + c = b) /\ c > 0)

          forall a : Nat
          . suc(a) = a + suc(0) %implied %(defSuc)% 
          . suc(a) - a = suc(0) %implied %(The2ndleastdifference)%
          . (a + a) - a = a %implied %(1stSubNeutral)%
          . a - 0 = a %implied %(2ndSubNeutral)%
 
end

logic Hybrid

spec HNat =

         sort Nat

         rigid ops 
                  0 : Nat
                  suc : Nat -> Nat
         
         forall n,m : Nat
                  . n = 0 \/ exists n' : Nat . n = suc(n') /\ not n = n'
                  . not suc(n) = 0
                  . suc(n) = suc(m) => n = m
 
         forall n : Nat . not suc(n) = n %implied %(notreflexive)% %%passed
         
         . exists n : Nat . true %implied %(atLeastOne)% %%passed
        
         . exists n,n' : Nat . not n = n' %implied %(atLeastTwo)% 

         rigid ops    __+__ : Nat*Nat -> Nat
 
         forall n,n',n'' : Nat
         . n + 0 = n
         . n + suc(n') = suc(n + n')
         . n + n' = n' + n
         . n + ( n' + n'') = ( n + n') + n''
        
        
         . forall n : Nat . 0 + n = n %implied %(neutralCommu)%


        rigid pred __ < __ : Nat*Nat

        forall a,b,c : Nat
        . not a < a
        . a < b => not b < a
        . a < b /\ b < c => a < b
        . a < b <=> exists d : Nat . not d = 0 /\ a + d = b 
        
        . a < suc(a) %implied %(sucBigger)% %%proved with eprover 
        . a < b => (a + c) < (b + c) %%(sumAlwaysAdds)% %%can be proved in CASL
        . a < b => a < b + c %(sumAlwaysAdds2nd)% %%can be proved in CASL
        . a + c < b => a < b %(sumAlwaysAdds3rd)% %%can be proved in CASL
        . not a = 0 => 0 < a %implied %(0isthelowestNat)% %%can be proved here


        rigid pred __ > __ : Nat*Nat
        
        forall a,b : Nat
        . a < b <=> b > a

        rigid pred __ <= __ : Nat*Nat

        forall a,b : Nat
        . a <= b <=> a < b \/ a = b

        rigid pred __ >= __ : Nat*Nat
        
        forall a,b : Nat
        . a >= b <=> a > b \/ a = b

        forall a,b,c : Nat
        . a >= b <=> b <= a %implied %(BigEqAsTheSymOfLesEq)%
        . a >= b => not a < b %implied %(RelBigEqWithLes)%
        . a >= b => a+c >= b %implied %(sumAlwaysAdds4th)% 
        . a >= b /\ c > 0 => a+c > b %implied %(sumAlwaysAdds5th)%  


        rigid op __ - __ : Nat*Nat -> Nat

        forall a,b : Nat
        . a <= b <=> a - b = 0
        . a > b <=> (exists c : Nat . (a - b = c <=> a + c = b) /\ c > 0)
        
        forall a : Nat
        . suc(a) = a + suc(0) %implied %(defSuc)% 
        . suc(a) - a = suc(0) %implied %(The2ndleastdifference)%
        . (a + a) - a = a %implied %(1stSubNeutral)%
        . a - 0 = a %implied %(2ndSubNeutral)%

end

