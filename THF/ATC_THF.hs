{-# OPTIONS -w -O0 #-}
{- |
Module      :  THF/ATC_THF.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'THF.As.TPTP_THF'
'THF.As.Comment'
'THF.As.DefinedComment'
'THF.As.SystemComment'
'THF.As.Include'
'THF.As.Annotations'
'THF.As.FormulaRole'
'THF.As.THFFormula'
'THF.As.THFLogicFormula'
'THF.As.THFBinaryFormula'
'THF.As.THFBinaryTuple'
'THF.As.THFUnitaryFormula'
'THF.As.THFQuantifiedFormula'
'THF.As.THFVariable'
'THF.As.THFTypedConst'
'THF.As.THFTypeFormula'
'THF.As.THFTypeableFormula'
'THF.As.THFSubType'
'THF.As.THFTopLevelType'
'THF.As.THFUnitaryType'
'THF.As.THFBinaryType'
'THF.As.THFAtom'
'THF.As.THFDefinedVar'
'THF.As.THFSequent'
'THF.As.THFConnTerm'
'THF.As.THFQuantifier'
'THF.As.Quantifier'
'THF.As.THFPairConnective'
'THF.As.THFUnaryConnective'
'THF.As.AssocConnective'
'THF.As.DefinedType'
'THF.As.DefinedPlainFormula'
'THF.As.DefinedProp'
'THF.As.DefinedPred'
'THF.As.Term'
'THF.As.FunctionTerm'
'THF.As.PlainTerm'
'THF.As.DefinedTerm'
'THF.As.DefinedAtom'
'THF.As.DefinedPlainTerm'
'THF.As.DefinedFunctor'
'THF.As.SystemTerm'
'THF.As.PrincipalSymbol'
'THF.As.Source'
'THF.As.DagSource'
'THF.As.ParentInfo'
'THF.As.IntroType'
'THF.As.ExternalSource'
'THF.As.FileSource'
'THF.As.TheoryName'
'THF.As.InfoItem'
'THF.As.FormulaItem'
'THF.As.InferenceItem'
'THF.As.InferenceStatus'
'THF.As.StatusValue'
'THF.As.GeneralTerm'
'THF.As.GeneralData'
'THF.As.GeneralFunction'
'THF.As.FormulaData'
'THF.As.Name'
'THF.As.AtomicWord'
'THF.As.Number'
'THF.Cons.THFBS'
'THF.Cons.BasicSpecTHF'
'THF.Cons.SentenceTHF'
'THF.Cons.SymbolTHF'
'THF.Cons.SymbolType'
'THF.Cons.Type'
'THF.Cons.Kind'
'THF.Sign.SignTHF'
'THF.Sign.TypeInfo'
'THF.Sign.ConstInfo'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
THF/As.hs
THF/Cons.hs
THF/Sign.hs
-}

module THF.ATC_THF () where

import ATC.GlobalAnnotations
import ATC.Id
import ATerm.Lib
import Common.DefaultMorphism
import Common.Id
import Common.Id hiding (typeId)
import Common.Result
import Data.Typeable
import THF.As
import THF.Cons
import THF.ParseTHF
import THF.ParseTHF0
import THF.Sign
import Text.ParserCombinators.Parsec
import qualified Data.Map as Map

{-! for THF.As.TPTP_THF derive : Typeable !-}
{-! for THF.As.Comment derive : Typeable !-}
{-! for THF.As.DefinedComment derive : Typeable !-}
{-! for THF.As.SystemComment derive : Typeable !-}
{-! for THF.As.Include derive : Typeable !-}
{-! for THF.As.Annotations derive : Typeable !-}
{-! for THF.As.FormulaRole derive : Typeable !-}
{-! for THF.As.THFFormula derive : Typeable !-}
{-! for THF.As.THFLogicFormula derive : Typeable !-}
{-! for THF.As.THFBinaryFormula derive : Typeable !-}
{-! for THF.As.THFBinaryTuple derive : Typeable !-}
{-! for THF.As.THFUnitaryFormula derive : Typeable !-}
{-! for THF.As.THFQuantifiedFormula derive : Typeable !-}
{-! for THF.As.THFVariable derive : Typeable !-}
{-! for THF.As.THFTypedConst derive : Typeable !-}
{-! for THF.As.THFTypeFormula derive : Typeable !-}
{-! for THF.As.THFTypeableFormula derive : Typeable !-}
{-! for THF.As.THFSubType derive : Typeable !-}
{-! for THF.As.THFTopLevelType derive : Typeable !-}
{-! for THF.As.THFUnitaryType derive : Typeable !-}
{-! for THF.As.THFBinaryType derive : Typeable !-}
{-! for THF.As.THFAtom derive : Typeable !-}
{-! for THF.As.THFDefinedVar derive : Typeable !-}
{-! for THF.As.THFSequent derive : Typeable !-}
{-! for THF.As.THFConnTerm derive : Typeable !-}
{-! for THF.As.THFQuantifier derive : Typeable !-}
{-! for THF.As.Quantifier derive : Typeable !-}
{-! for THF.As.THFPairConnective derive : Typeable !-}
{-! for THF.As.THFUnaryConnective derive : Typeable !-}
{-! for THF.As.AssocConnective derive : Typeable !-}
{-! for THF.As.DefinedType derive : Typeable !-}
{-! for THF.As.DefinedPlainFormula derive : Typeable !-}
{-! for THF.As.DefinedProp derive : Typeable !-}
{-! for THF.As.DefinedPred derive : Typeable !-}
{-! for THF.As.Term derive : Typeable !-}
{-! for THF.As.FunctionTerm derive : Typeable !-}
{-! for THF.As.PlainTerm derive : Typeable !-}
{-! for THF.As.DefinedTerm derive : Typeable !-}
{-! for THF.As.DefinedAtom derive : Typeable !-}
{-! for THF.As.DefinedPlainTerm derive : Typeable !-}
{-! for THF.As.DefinedFunctor derive : Typeable !-}
{-! for THF.As.SystemTerm derive : Typeable !-}
{-! for THF.As.PrincipalSymbol derive : Typeable !-}
{-! for THF.As.Source derive : Typeable !-}
{-! for THF.As.DagSource derive : Typeable !-}
{-! for THF.As.ParentInfo derive : Typeable !-}
{-! for THF.As.IntroType derive : Typeable !-}
{-! for THF.As.ExternalSource derive : Typeable !-}
{-! for THF.As.FileSource derive : Typeable !-}
{-! for THF.As.TheoryName derive : Typeable !-}
{-! for THF.As.InfoItem derive : Typeable !-}
{-! for THF.As.FormulaItem derive : Typeable !-}
{-! for THF.As.InferenceItem derive : Typeable !-}
{-! for THF.As.InferenceStatus derive : Typeable !-}
{-! for THF.As.StatusValue derive : Typeable !-}
{-! for THF.As.GeneralTerm derive : Typeable !-}
{-! for THF.As.GeneralData derive : Typeable !-}
{-! for THF.As.GeneralFunction derive : Typeable !-}
{-! for THF.As.FormulaData derive : Typeable !-}
{-! for THF.As.Name derive : Typeable !-}
{-! for THF.As.AtomicWord derive : Typeable !-}
{-! for THF.As.Number derive : Typeable !-}
{-! for THF.Cons.THFBS derive : Typeable !-}
{-! for THF.Cons.BasicSpecTHF derive : Typeable !-}
{-! for THF.Cons.SentenceTHF derive : Typeable !-}
{-! for THF.Cons.SymbolTHF derive : Typeable !-}
{-! for THF.Cons.SymbolType derive : Typeable !-}
{-! for THF.Cons.Type derive : Typeable !-}
{-! for THF.Cons.Kind derive : Typeable !-}
{-! for THF.Sign.SignTHF derive : Typeable !-}
{-! for THF.Sign.TypeInfo derive : Typeable !-}
{-! for THF.Sign.ConstInfo derive : Typeable !-}

{-! for THF.As.TPTP_THF derive : ShATermConvertible !-}
{-! for THF.As.Comment derive : ShATermConvertible !-}
{-! for THF.As.DefinedComment derive : ShATermConvertible !-}
{-! for THF.As.SystemComment derive : ShATermConvertible !-}
{-! for THF.As.Include derive : ShATermConvertible !-}
{-! for THF.As.Annotations derive : ShATermConvertible !-}
{-! for THF.As.FormulaRole derive : ShATermConvertible !-}
{-! for THF.As.THFFormula derive : ShATermConvertible !-}
{-! for THF.As.THFLogicFormula derive : ShATermConvertible !-}
{-! for THF.As.THFBinaryFormula derive : ShATermConvertible !-}
{-! for THF.As.THFBinaryTuple derive : ShATermConvertible !-}
{-! for THF.As.THFUnitaryFormula derive : ShATermConvertible !-}
{-! for THF.As.THFQuantifiedFormula derive : ShATermConvertible !-}
{-! for THF.As.THFVariable derive : ShATermConvertible !-}
{-! for THF.As.THFTypedConst derive : ShATermConvertible !-}
{-! for THF.As.THFTypeFormula derive : ShATermConvertible !-}
{-! for THF.As.THFTypeableFormula derive : ShATermConvertible !-}
{-! for THF.As.THFSubType derive : ShATermConvertible !-}
{-! for THF.As.THFTopLevelType derive : ShATermConvertible !-}
{-! for THF.As.THFUnitaryType derive : ShATermConvertible !-}
{-! for THF.As.THFBinaryType derive : ShATermConvertible !-}
{-! for THF.As.THFAtom derive : ShATermConvertible !-}
{-! for THF.As.THFDefinedVar derive : ShATermConvertible !-}
{-! for THF.As.THFSequent derive : ShATermConvertible !-}
{-! for THF.As.THFConnTerm derive : ShATermConvertible !-}
{-! for THF.As.THFQuantifier derive : ShATermConvertible !-}
{-! for THF.As.Quantifier derive : ShATermConvertible !-}
{-! for THF.As.THFPairConnective derive : ShATermConvertible !-}
{-! for THF.As.THFUnaryConnective derive : ShATermConvertible !-}
{-! for THF.As.AssocConnective derive : ShATermConvertible !-}
{-! for THF.As.DefinedType derive : ShATermConvertible !-}
{-! for THF.As.DefinedPlainFormula derive : ShATermConvertible !-}
{-! for THF.As.DefinedProp derive : ShATermConvertible !-}
{-! for THF.As.DefinedPred derive : ShATermConvertible !-}
{-! for THF.As.Term derive : ShATermConvertible !-}
{-! for THF.As.FunctionTerm derive : ShATermConvertible !-}
{-! for THF.As.PlainTerm derive : ShATermConvertible !-}
{-! for THF.As.DefinedTerm derive : ShATermConvertible !-}
{-! for THF.As.DefinedAtom derive : ShATermConvertible !-}
{-! for THF.As.DefinedPlainTerm derive : ShATermConvertible !-}
{-! for THF.As.DefinedFunctor derive : ShATermConvertible !-}
{-! for THF.As.SystemTerm derive : ShATermConvertible !-}
{-! for THF.As.PrincipalSymbol derive : ShATermConvertible !-}
{-! for THF.As.Source derive : ShATermConvertible !-}
{-! for THF.As.DagSource derive : ShATermConvertible !-}
{-! for THF.As.ParentInfo derive : ShATermConvertible !-}
{-! for THF.As.IntroType derive : ShATermConvertible !-}
{-! for THF.As.ExternalSource derive : ShATermConvertible !-}
{-! for THF.As.FileSource derive : ShATermConvertible !-}
{-! for THF.As.TheoryName derive : ShATermConvertible !-}
{-! for THF.As.InfoItem derive : ShATermConvertible !-}
{-! for THF.As.FormulaItem derive : ShATermConvertible !-}
{-! for THF.As.InferenceItem derive : ShATermConvertible !-}
{-! for THF.As.InferenceStatus derive : ShATermConvertible !-}
{-! for THF.As.StatusValue derive : ShATermConvertible !-}
{-! for THF.As.GeneralTerm derive : ShATermConvertible !-}
{-! for THF.As.GeneralData derive : ShATermConvertible !-}
{-! for THF.As.GeneralFunction derive : ShATermConvertible !-}
{-! for THF.As.FormulaData derive : ShATermConvertible !-}
{-! for THF.As.Name derive : ShATermConvertible !-}
{-! for THF.As.AtomicWord derive : ShATermConvertible !-}
{-! for THF.As.Number derive : ShATermConvertible !-}
{-! for THF.Cons.THFBS derive : ShATermConvertible !-}
{-! for THF.Cons.BasicSpecTHF derive : ShATermConvertible !-}
{-! for THF.Cons.SentenceTHF derive : ShATermConvertible !-}
{-! for THF.Cons.SymbolTHF derive : ShATermConvertible !-}
{-! for THF.Cons.SymbolType derive : ShATermConvertible !-}
{-! for THF.Cons.Type derive : ShATermConvertible !-}
{-! for THF.Cons.Kind derive : ShATermConvertible !-}
{-! for THF.Sign.SignTHF derive : ShATermConvertible !-}
{-! for THF.Sign.TypeInfo derive : ShATermConvertible !-}
{-! for THF.Sign.ConstInfo derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcTPTP_THFTc :: TyCon
_tcTPTP_THFTc = mkTyCon "THF.As.TPTP_THF"
instance Typeable TPTP_THF where
    typeOf _ = mkTyConApp _tcTPTP_THFTc []

_tcCommentTc :: TyCon
_tcCommentTc = mkTyCon "THF.As.Comment"
instance Typeable Comment where
    typeOf _ = mkTyConApp _tcCommentTc []

_tcDefinedCommentTc :: TyCon
_tcDefinedCommentTc = mkTyCon "THF.As.DefinedComment"
instance Typeable DefinedComment where
    typeOf _ = mkTyConApp _tcDefinedCommentTc []

_tcSystemCommentTc :: TyCon
_tcSystemCommentTc = mkTyCon "THF.As.SystemComment"
instance Typeable SystemComment where
    typeOf _ = mkTyConApp _tcSystemCommentTc []

_tcIncludeTc :: TyCon
_tcIncludeTc = mkTyCon "THF.As.Include"
instance Typeable Include where
    typeOf _ = mkTyConApp _tcIncludeTc []

_tcAnnotationsTc :: TyCon
_tcAnnotationsTc = mkTyCon "THF.As.Annotations"
instance Typeable Annotations where
    typeOf _ = mkTyConApp _tcAnnotationsTc []

_tcFormulaRoleTc :: TyCon
_tcFormulaRoleTc = mkTyCon "THF.As.FormulaRole"
instance Typeable FormulaRole where
    typeOf _ = mkTyConApp _tcFormulaRoleTc []

_tcTHFFormulaTc :: TyCon
_tcTHFFormulaTc = mkTyCon "THF.As.THFFormula"
instance Typeable THFFormula where
    typeOf _ = mkTyConApp _tcTHFFormulaTc []

_tcTHFLogicFormulaTc :: TyCon
_tcTHFLogicFormulaTc = mkTyCon "THF.As.THFLogicFormula"
instance Typeable THFLogicFormula where
    typeOf _ = mkTyConApp _tcTHFLogicFormulaTc []

_tcTHFBinaryFormulaTc :: TyCon
_tcTHFBinaryFormulaTc = mkTyCon "THF.As.THFBinaryFormula"
instance Typeable THFBinaryFormula where
    typeOf _ = mkTyConApp _tcTHFBinaryFormulaTc []

_tcTHFBinaryTupleTc :: TyCon
_tcTHFBinaryTupleTc = mkTyCon "THF.As.THFBinaryTuple"
instance Typeable THFBinaryTuple where
    typeOf _ = mkTyConApp _tcTHFBinaryTupleTc []

_tcTHFUnitaryFormulaTc :: TyCon
_tcTHFUnitaryFormulaTc = mkTyCon "THF.As.THFUnitaryFormula"
instance Typeable THFUnitaryFormula where
    typeOf _ = mkTyConApp _tcTHFUnitaryFormulaTc []

_tcTHFQuantifiedFormulaTc :: TyCon
_tcTHFQuantifiedFormulaTc = mkTyCon "THF.As.THFQuantifiedFormula"
instance Typeable THFQuantifiedFormula where
    typeOf _ = mkTyConApp _tcTHFQuantifiedFormulaTc []

_tcTHFVariableTc :: TyCon
_tcTHFVariableTc = mkTyCon "THF.As.THFVariable"
instance Typeable THFVariable where
    typeOf _ = mkTyConApp _tcTHFVariableTc []

_tcTHFTypedConstTc :: TyCon
_tcTHFTypedConstTc = mkTyCon "THF.As.THFTypedConst"
instance Typeable THFTypedConst where
    typeOf _ = mkTyConApp _tcTHFTypedConstTc []

_tcTHFTypeFormulaTc :: TyCon
_tcTHFTypeFormulaTc = mkTyCon "THF.As.THFTypeFormula"
instance Typeable THFTypeFormula where
    typeOf _ = mkTyConApp _tcTHFTypeFormulaTc []

_tcTHFTypeableFormulaTc :: TyCon
_tcTHFTypeableFormulaTc = mkTyCon "THF.As.THFTypeableFormula"
instance Typeable THFTypeableFormula where
    typeOf _ = mkTyConApp _tcTHFTypeableFormulaTc []

_tcTHFSubTypeTc :: TyCon
_tcTHFSubTypeTc = mkTyCon "THF.As.THFSubType"
instance Typeable THFSubType where
    typeOf _ = mkTyConApp _tcTHFSubTypeTc []

_tcTHFTopLevelTypeTc :: TyCon
_tcTHFTopLevelTypeTc = mkTyCon "THF.As.THFTopLevelType"
instance Typeable THFTopLevelType where
    typeOf _ = mkTyConApp _tcTHFTopLevelTypeTc []

_tcTHFUnitaryTypeTc :: TyCon
_tcTHFUnitaryTypeTc = mkTyCon "THF.As.THFUnitaryType"
instance Typeable THFUnitaryType where
    typeOf _ = mkTyConApp _tcTHFUnitaryTypeTc []

_tcTHFBinaryTypeTc :: TyCon
_tcTHFBinaryTypeTc = mkTyCon "THF.As.THFBinaryType"
instance Typeable THFBinaryType where
    typeOf _ = mkTyConApp _tcTHFBinaryTypeTc []

_tcTHFAtomTc :: TyCon
_tcTHFAtomTc = mkTyCon "THF.As.THFAtom"
instance Typeable THFAtom where
    typeOf _ = mkTyConApp _tcTHFAtomTc []

_tcTHFDefinedVarTc :: TyCon
_tcTHFDefinedVarTc = mkTyCon "THF.As.THFDefinedVar"
instance Typeable THFDefinedVar where
    typeOf _ = mkTyConApp _tcTHFDefinedVarTc []

_tcTHFSequentTc :: TyCon
_tcTHFSequentTc = mkTyCon "THF.As.THFSequent"
instance Typeable THFSequent where
    typeOf _ = mkTyConApp _tcTHFSequentTc []

_tcTHFConnTermTc :: TyCon
_tcTHFConnTermTc = mkTyCon "THF.As.THFConnTerm"
instance Typeable THFConnTerm where
    typeOf _ = mkTyConApp _tcTHFConnTermTc []

_tcTHFQuantifierTc :: TyCon
_tcTHFQuantifierTc = mkTyCon "THF.As.THFQuantifier"
instance Typeable THFQuantifier where
    typeOf _ = mkTyConApp _tcTHFQuantifierTc []

_tcQuantifierTc :: TyCon
_tcQuantifierTc = mkTyCon "THF.As.Quantifier"
instance Typeable Quantifier where
    typeOf _ = mkTyConApp _tcQuantifierTc []

_tcTHFPairConnectiveTc :: TyCon
_tcTHFPairConnectiveTc = mkTyCon "THF.As.THFPairConnective"
instance Typeable THFPairConnective where
    typeOf _ = mkTyConApp _tcTHFPairConnectiveTc []

_tcTHFUnaryConnectiveTc :: TyCon
_tcTHFUnaryConnectiveTc = mkTyCon "THF.As.THFUnaryConnective"
instance Typeable THFUnaryConnective where
    typeOf _ = mkTyConApp _tcTHFUnaryConnectiveTc []

_tcAssocConnectiveTc :: TyCon
_tcAssocConnectiveTc = mkTyCon "THF.As.AssocConnective"
instance Typeable AssocConnective where
    typeOf _ = mkTyConApp _tcAssocConnectiveTc []

_tcDefinedTypeTc :: TyCon
_tcDefinedTypeTc = mkTyCon "THF.As.DefinedType"
instance Typeable DefinedType where
    typeOf _ = mkTyConApp _tcDefinedTypeTc []

_tcDefinedPlainFormulaTc :: TyCon
_tcDefinedPlainFormulaTc = mkTyCon "THF.As.DefinedPlainFormula"
instance Typeable DefinedPlainFormula where
    typeOf _ = mkTyConApp _tcDefinedPlainFormulaTc []

_tcDefinedPropTc :: TyCon
_tcDefinedPropTc = mkTyCon "THF.As.DefinedProp"
instance Typeable DefinedProp where
    typeOf _ = mkTyConApp _tcDefinedPropTc []

_tcDefinedPredTc :: TyCon
_tcDefinedPredTc = mkTyCon "THF.As.DefinedPred"
instance Typeable DefinedPred where
    typeOf _ = mkTyConApp _tcDefinedPredTc []

_tcTermTc :: TyCon
_tcTermTc = mkTyCon "THF.As.Term"
instance Typeable Term where
    typeOf _ = mkTyConApp _tcTermTc []

_tcFunctionTermTc :: TyCon
_tcFunctionTermTc = mkTyCon "THF.As.FunctionTerm"
instance Typeable FunctionTerm where
    typeOf _ = mkTyConApp _tcFunctionTermTc []

_tcPlainTermTc :: TyCon
_tcPlainTermTc = mkTyCon "THF.As.PlainTerm"
instance Typeable PlainTerm where
    typeOf _ = mkTyConApp _tcPlainTermTc []

_tcDefinedTermTc :: TyCon
_tcDefinedTermTc = mkTyCon "THF.As.DefinedTerm"
instance Typeable DefinedTerm where
    typeOf _ = mkTyConApp _tcDefinedTermTc []

_tcDefinedAtomTc :: TyCon
_tcDefinedAtomTc = mkTyCon "THF.As.DefinedAtom"
instance Typeable DefinedAtom where
    typeOf _ = mkTyConApp _tcDefinedAtomTc []

_tcDefinedPlainTermTc :: TyCon
_tcDefinedPlainTermTc = mkTyCon "THF.As.DefinedPlainTerm"
instance Typeable DefinedPlainTerm where
    typeOf _ = mkTyConApp _tcDefinedPlainTermTc []

_tcDefinedFunctorTc :: TyCon
_tcDefinedFunctorTc = mkTyCon "THF.As.DefinedFunctor"
instance Typeable DefinedFunctor where
    typeOf _ = mkTyConApp _tcDefinedFunctorTc []

_tcSystemTermTc :: TyCon
_tcSystemTermTc = mkTyCon "THF.As.SystemTerm"
instance Typeable SystemTerm where
    typeOf _ = mkTyConApp _tcSystemTermTc []

_tcPrincipalSymbolTc :: TyCon
_tcPrincipalSymbolTc = mkTyCon "THF.As.PrincipalSymbol"
instance Typeable PrincipalSymbol where
    typeOf _ = mkTyConApp _tcPrincipalSymbolTc []

_tcSourceTc :: TyCon
_tcSourceTc = mkTyCon "THF.As.Source"
instance Typeable Source where
    typeOf _ = mkTyConApp _tcSourceTc []

_tcDagSourceTc :: TyCon
_tcDagSourceTc = mkTyCon "THF.As.DagSource"
instance Typeable DagSource where
    typeOf _ = mkTyConApp _tcDagSourceTc []

_tcParentInfoTc :: TyCon
_tcParentInfoTc = mkTyCon "THF.As.ParentInfo"
instance Typeable ParentInfo where
    typeOf _ = mkTyConApp _tcParentInfoTc []

_tcIntroTypeTc :: TyCon
_tcIntroTypeTc = mkTyCon "THF.As.IntroType"
instance Typeable IntroType where
    typeOf _ = mkTyConApp _tcIntroTypeTc []

_tcExternalSourceTc :: TyCon
_tcExternalSourceTc = mkTyCon "THF.As.ExternalSource"
instance Typeable ExternalSource where
    typeOf _ = mkTyConApp _tcExternalSourceTc []

_tcFileSourceTc :: TyCon
_tcFileSourceTc = mkTyCon "THF.As.FileSource"
instance Typeable FileSource where
    typeOf _ = mkTyConApp _tcFileSourceTc []

_tcTheoryNameTc :: TyCon
_tcTheoryNameTc = mkTyCon "THF.As.TheoryName"
instance Typeable TheoryName where
    typeOf _ = mkTyConApp _tcTheoryNameTc []

_tcInfoItemTc :: TyCon
_tcInfoItemTc = mkTyCon "THF.As.InfoItem"
instance Typeable InfoItem where
    typeOf _ = mkTyConApp _tcInfoItemTc []

_tcFormulaItemTc :: TyCon
_tcFormulaItemTc = mkTyCon "THF.As.FormulaItem"
instance Typeable FormulaItem where
    typeOf _ = mkTyConApp _tcFormulaItemTc []

_tcInferenceItemTc :: TyCon
_tcInferenceItemTc = mkTyCon "THF.As.InferenceItem"
instance Typeable InferenceItem where
    typeOf _ = mkTyConApp _tcInferenceItemTc []

_tcInferenceStatusTc :: TyCon
_tcInferenceStatusTc = mkTyCon "THF.As.InferenceStatus"
instance Typeable InferenceStatus where
    typeOf _ = mkTyConApp _tcInferenceStatusTc []

_tcStatusValueTc :: TyCon
_tcStatusValueTc = mkTyCon "THF.As.StatusValue"
instance Typeable StatusValue where
    typeOf _ = mkTyConApp _tcStatusValueTc []

_tcGeneralTermTc :: TyCon
_tcGeneralTermTc = mkTyCon "THF.As.GeneralTerm"
instance Typeable GeneralTerm where
    typeOf _ = mkTyConApp _tcGeneralTermTc []

_tcGeneralDataTc :: TyCon
_tcGeneralDataTc = mkTyCon "THF.As.GeneralData"
instance Typeable GeneralData where
    typeOf _ = mkTyConApp _tcGeneralDataTc []

_tcGeneralFunctionTc :: TyCon
_tcGeneralFunctionTc = mkTyCon "THF.As.GeneralFunction"
instance Typeable GeneralFunction where
    typeOf _ = mkTyConApp _tcGeneralFunctionTc []

_tcFormulaDataTc :: TyCon
_tcFormulaDataTc = mkTyCon "THF.As.FormulaData"
instance Typeable FormulaData where
    typeOf _ = mkTyConApp _tcFormulaDataTc []

_tcNameTc :: TyCon
_tcNameTc = mkTyCon "THF.As.Name"
instance Typeable Name where
    typeOf _ = mkTyConApp _tcNameTc []

_tcAtomicWordTc :: TyCon
_tcAtomicWordTc = mkTyCon "THF.As.AtomicWord"
instance Typeable AtomicWord where
    typeOf _ = mkTyConApp _tcAtomicWordTc []

_tcNumberTc :: TyCon
_tcNumberTc = mkTyCon "THF.As.Number"
instance Typeable Number where
    typeOf _ = mkTyConApp _tcNumberTc []

instance ShATermConvertible TPTP_THF where
  toShATermAux att0 xv = case xv of
    TPTP_THF_Annotated_Formula a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "TPTP_THF_Annotated_Formula" [a', b',
                                                               c', d'] []) att4
    TPTP_Include a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TPTP_Include" [a'] []) att1
    TPTP_Comment a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TPTP_Comment" [a'] []) att1
    TPTP_Defined_Comment a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TPTP_Defined_Comment" [a'] []) att1
    TPTP_System_Comment a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TPTP_System_Comment" [a'] []) att1
    TPTP_Header a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TPTP_Header" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TPTP_THF_Annotated_Formula" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, TPTP_THF_Annotated_Formula a' b' c' d') }}}}
    ShAAppl "TPTP_Include" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TPTP_Include a') }
    ShAAppl "TPTP_Comment" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TPTP_Comment a') }
    ShAAppl "TPTP_Defined_Comment" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TPTP_Defined_Comment a') }
    ShAAppl "TPTP_System_Comment" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TPTP_System_Comment a') }
    ShAAppl "TPTP_Header" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TPTP_Header a') }
    u -> fromShATermError "TPTP_THF" u

instance ShATermConvertible Comment where
  toShATermAux att0 xv = case xv of
    Comment_Line a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Comment_Line" [a'] []) att1
    Comment_Block a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Comment_Block" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Comment_Line" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Comment_Line a') }
    ShAAppl "Comment_Block" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Comment_Block a') }
    u -> fromShATermError "Comment" u

instance ShATermConvertible DefinedComment where
  toShATermAux att0 xv = case xv of
    Defined_Comment_Line a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Defined_Comment_Line" [a'] []) att1
    Defined_Comment_Block a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Defined_Comment_Block" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Defined_Comment_Line" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Defined_Comment_Line a') }
    ShAAppl "Defined_Comment_Block" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Defined_Comment_Block a') }
    u -> fromShATermError "DefinedComment" u

instance ShATermConvertible SystemComment where
  toShATermAux att0 xv = case xv of
    System_Comment_Line a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "System_Comment_Line" [a'] []) att1
    System_Comment_Block a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "System_Comment_Block" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "System_Comment_Line" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, System_Comment_Line a') }
    ShAAppl "System_Comment_Block" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, System_Comment_Block a') }
    u -> fromShATermError "SystemComment" u

instance ShATermConvertible Include where
  toShATermAux att0 xv = case xv of
    I_Include a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "I_Include" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "I_Include" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, I_Include a' b') }}
    u -> fromShATermError "Include" u

instance ShATermConvertible Annotations where
  toShATermAux att0 xv = case xv of
    Annotations a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Annotations" [a', b'] []) att2
    Null -> return $ addATerm (ShAAppl "Null" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Annotations" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Annotations a' b') }}
    ShAAppl "Null" [] _ -> (att0, Null)
    u -> fromShATermError "Annotations" u

instance ShATermConvertible FormulaRole where
  toShATermAux att0 xv = case xv of
    Axiom -> return $ addATerm (ShAAppl "Axiom" [] []) att0
    Hypothesis -> return $ addATerm (ShAAppl "Hypothesis" [] []) att0
    Definition -> return $ addATerm (ShAAppl "Definition" [] []) att0
    Assumption -> return $ addATerm (ShAAppl "Assumption" [] []) att0
    Lemma -> return $ addATerm (ShAAppl "Lemma" [] []) att0
    Theorem -> return $ addATerm (ShAAppl "Theorem" [] []) att0
    Conjecture -> return $ addATerm (ShAAppl "Conjecture" [] []) att0
    Negated_Conjecture ->
      return $ addATerm (ShAAppl "Negated_Conjecture" [] []) att0
    Plain -> return $ addATerm (ShAAppl "Plain" [] []) att0
    Fi_Domain -> return $ addATerm (ShAAppl "Fi_Domain" [] []) att0
    Fi_Functors -> return $ addATerm (ShAAppl "Fi_Functors" [] []) att0
    Fi_Predicates -> return $ addATerm (ShAAppl "Fi_Predicates" [] []) att0
    Type -> return $ addATerm (ShAAppl "Type" [] []) att0
    Unknown -> return $ addATerm (ShAAppl "Unknown" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Axiom" [] _ -> (att0, Axiom)
    ShAAppl "Hypothesis" [] _ -> (att0, Hypothesis)
    ShAAppl "Definition" [] _ -> (att0, Definition)
    ShAAppl "Assumption" [] _ -> (att0, Assumption)
    ShAAppl "Lemma" [] _ -> (att0, Lemma)
    ShAAppl "Theorem" [] _ -> (att0, Theorem)
    ShAAppl "Conjecture" [] _ -> (att0, Conjecture)
    ShAAppl "Negated_Conjecture" [] _ -> (att0, Negated_Conjecture)
    ShAAppl "Plain" [] _ -> (att0, Plain)
    ShAAppl "Fi_Domain" [] _ -> (att0, Fi_Domain)
    ShAAppl "Fi_Functors" [] _ -> (att0, Fi_Functors)
    ShAAppl "Fi_Predicates" [] _ -> (att0, Fi_Predicates)
    ShAAppl "Type" [] _ -> (att0, Type)
    ShAAppl "Unknown" [] _ -> (att0, Unknown)
    u -> fromShATermError "FormulaRole" u

instance ShATermConvertible THFFormula where
  toShATermAux att0 xv = case xv of
    TF_THF_Logic_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TF_THF_Logic_Formula" [a'] []) att1
    TF_THF_Sequent a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TF_THF_Sequent" [a'] []) att1
    T0F_THF_Typed_Const a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0F_THF_Typed_Const" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TF_THF_Logic_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TF_THF_Logic_Formula a') }
    ShAAppl "TF_THF_Sequent" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TF_THF_Sequent a') }
    ShAAppl "T0F_THF_Typed_Const" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0F_THF_Typed_Const a') }
    u -> fromShATermError "THFFormula" u

instance ShATermConvertible THFLogicFormula where
  toShATermAux att0 xv = case xv of
    TLF_THF_Binary_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TLF_THF_Binary_Formula" [a'] []) att1
    TLF_THF_Unitary_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TLF_THF_Unitary_Formula" [a'] []) att1
    TLF_THF_Type_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TLF_THF_Type_Formula" [a'] []) att1
    TLF_THF_Sub_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TLF_THF_Sub_Type" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TLF_THF_Binary_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TLF_THF_Binary_Formula a') }
    ShAAppl "TLF_THF_Unitary_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TLF_THF_Unitary_Formula a') }
    ShAAppl "TLF_THF_Type_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TLF_THF_Type_Formula a') }
    ShAAppl "TLF_THF_Sub_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TLF_THF_Sub_Type a') }
    u -> fromShATermError "THFLogicFormula" u

instance ShATermConvertible THFBinaryFormula where
  toShATermAux att0 xv = case xv of
    TBF_THF_Binary_Pair a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TBF_THF_Binary_Pair" [a', b',
                                                        c'] []) att3
    TBF_THF_Binary_Tuple a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBF_THF_Binary_Tuple" [a'] []) att1
    TBF_THF_Binary_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBF_THF_Binary_Type" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TBF_THF_Binary_Pair" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TBF_THF_Binary_Pair a' b' c') }}}
    ShAAppl "TBF_THF_Binary_Tuple" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBF_THF_Binary_Tuple a') }
    ShAAppl "TBF_THF_Binary_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBF_THF_Binary_Type a') }
    u -> fromShATermError "THFBinaryFormula" u

instance ShATermConvertible THFBinaryTuple where
  toShATermAux att0 xv = case xv of
    TBT_THF_Or_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBT_THF_Or_Formula" [a'] []) att1
    TBT_THF_And_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBT_THF_And_Formula" [a'] []) att1
    TBT_THF_Apply_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBT_THF_Apply_Formula" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TBT_THF_Or_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBT_THF_Or_Formula a') }
    ShAAppl "TBT_THF_And_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBT_THF_And_Formula a') }
    ShAAppl "TBT_THF_Apply_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBT_THF_Apply_Formula a') }
    u -> fromShATermError "THFBinaryTuple" u

instance ShATermConvertible THFUnitaryFormula where
  toShATermAux att0 xv = case xv of
    TUF_THF_Quantified_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TUF_THF_Quantified_Formula" [a'] []) att1
    TUF_THF_Unary_Formula a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TUF_THF_Unary_Formula" [a',
                                                          b'] []) att2
    TUF_THF_Atom a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TUF_THF_Atom" [a'] []) att1
    TUF_THF_Tuple a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TUF_THF_Tuple" [a'] []) att1
    TUF_THF_Let a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TUF_THF_Let" [a', b'] []) att2
    TUF_THF_Conditional a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TUF_THF_Conditional" [a', b',
                                                        c'] []) att3
    TUF_THF_Logic_Formula_Par a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TUF_THF_Logic_Formula_Par" [a'] []) att1
    T0UF_THF_Abstraction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "T0UF_THF_Abstraction" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TUF_THF_Quantified_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TUF_THF_Quantified_Formula a') }
    ShAAppl "TUF_THF_Unary_Formula" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TUF_THF_Unary_Formula a' b') }}
    ShAAppl "TUF_THF_Atom" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TUF_THF_Atom a') }
    ShAAppl "TUF_THF_Tuple" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TUF_THF_Tuple a') }
    ShAAppl "TUF_THF_Let" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TUF_THF_Let a' b') }}
    ShAAppl "TUF_THF_Conditional" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TUF_THF_Conditional a' b' c') }}}
    ShAAppl "TUF_THF_Logic_Formula_Par" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TUF_THF_Logic_Formula_Par a') }
    ShAAppl "T0UF_THF_Abstraction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, T0UF_THF_Abstraction a' b') }}
    u -> fromShATermError "THFUnitaryFormula" u

instance ShATermConvertible THFQuantifiedFormula where
  toShATermAux att0 xv = case xv of
    TQF_THF_Quantified_Formula a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TQF_THF_Quantified_Formula" [a', b',
                                                               c'] []) att3
    T0QF_THF_Quantified_Var a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "T0QF_THF_Quantified_Var" [a', b',
                                                            c'] []) att3
    T0QF_THF_Quantified_Novar a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "T0QF_THF_Quantified_Novar" [a',
                                                              b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TQF_THF_Quantified_Formula" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TQF_THF_Quantified_Formula a' b' c') }}}
    ShAAppl "T0QF_THF_Quantified_Var" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, T0QF_THF_Quantified_Var a' b' c') }}}
    ShAAppl "T0QF_THF_Quantified_Novar" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, T0QF_THF_Quantified_Novar a' b') }}
    u -> fromShATermError "THFQuantifiedFormula" u

instance ShATermConvertible THFVariable where
  toShATermAux att0 xv = case xv of
    TV_THF_Typed_Variable a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TV_THF_Typed_Variable" [a',
                                                          b'] []) att2
    TV_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TV_Variable" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TV_THF_Typed_Variable" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TV_THF_Typed_Variable a' b') }}
    ShAAppl "TV_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TV_Variable a') }
    u -> fromShATermError "THFVariable" u

instance ShATermConvertible THFTypedConst where
  toShATermAux att0 xv = case xv of
    T0TC_Typed_Const a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "T0TC_Typed_Const" [a', b'] []) att2
    T0TC_THF_TypedConst_Par a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0TC_THF_TypedConst_Par" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "T0TC_Typed_Const" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, T0TC_Typed_Const a' b') }}
    ShAAppl "T0TC_THF_TypedConst_Par" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0TC_THF_TypedConst_Par a') }
    u -> fromShATermError "THFTypedConst" u

instance ShATermConvertible THFTypeFormula where
  toShATermAux att0 xv = case xv of
    TTF_THF_Type_Formula a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TTF_THF_Type_Formula" [a', b'] []) att2
    TTF_THF_Typed_Const a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TTF_THF_Typed_Const" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TTF_THF_Type_Formula" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TTF_THF_Type_Formula a' b') }}
    ShAAppl "TTF_THF_Typed_Const" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TTF_THF_Typed_Const a' b') }}
    u -> fromShATermError "THFTypeFormula" u

instance ShATermConvertible THFTypeableFormula where
  toShATermAux att0 xv = case xv of
    TTyF_THF_Atom a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TTyF_THF_Atom" [a'] []) att1
    TTyF_THF_Tuple a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TTyF_THF_Tuple" [a'] []) att1
    TTyF_THF_Logic_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TTyF_THF_Logic_Formula" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TTyF_THF_Atom" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TTyF_THF_Atom a') }
    ShAAppl "TTyF_THF_Tuple" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TTyF_THF_Tuple a') }
    ShAAppl "TTyF_THF_Logic_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TTyF_THF_Logic_Formula a') }
    u -> fromShATermError "THFTypeableFormula" u

instance ShATermConvertible THFSubType where
  toShATermAux att0 xv = case xv of
    TST_THF_Sub_Type a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TST_THF_Sub_Type" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TST_THF_Sub_Type" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TST_THF_Sub_Type a' b') }}
    u -> fromShATermError "THFSubType" u

instance ShATermConvertible THFTopLevelType where
  toShATermAux att0 xv = case xv of
    TTLT_THF_Logic_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TTLT_THF_Logic_Formula" [a'] []) att1
    T0TLT_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0TLT_Constant" [a'] []) att1
    T0TLT_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0TLT_Variable" [a'] []) att1
    T0TLT_Defined_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0TLT_Defined_Type" [a'] []) att1
    T0TLT_System_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0TLT_System_Type" [a'] []) att1
    T0TLT_THF_Binary_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0TLT_THF_Binary_Type" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TTLT_THF_Logic_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TTLT_THF_Logic_Formula a') }
    ShAAppl "T0TLT_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0TLT_Constant a') }
    ShAAppl "T0TLT_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0TLT_Variable a') }
    ShAAppl "T0TLT_Defined_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0TLT_Defined_Type a') }
    ShAAppl "T0TLT_System_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0TLT_System_Type a') }
    ShAAppl "T0TLT_THF_Binary_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0TLT_THF_Binary_Type a') }
    u -> fromShATermError "THFTopLevelType" u

instance ShATermConvertible THFUnitaryType where
  toShATermAux att0 xv = case xv of
    TUT_THF_Unitary_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TUT_THF_Unitary_Formula" [a'] []) att1
    T0UT_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0UT_Constant" [a'] []) att1
    T0UT_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0UT_Variable" [a'] []) att1
    T0UT_Defined_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0UT_Defined_Type" [a'] []) att1
    T0UT_System_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0UT_System_Type" [a'] []) att1
    T0UT_THF_Binary_Type_Par a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0UT_THF_Binary_Type_Par" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TUT_THF_Unitary_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TUT_THF_Unitary_Formula a') }
    ShAAppl "T0UT_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0UT_Constant a') }
    ShAAppl "T0UT_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0UT_Variable a') }
    ShAAppl "T0UT_Defined_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0UT_Defined_Type a') }
    ShAAppl "T0UT_System_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0UT_System_Type a') }
    ShAAppl "T0UT_THF_Binary_Type_Par" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0UT_THF_Binary_Type_Par a') }
    u -> fromShATermError "THFUnitaryType" u

instance ShATermConvertible THFBinaryType where
  toShATermAux att0 xv = case xv of
    TBT_THF_Mapping_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBT_THF_Mapping_Type" [a'] []) att1
    TBT_THF_Xprod_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBT_THF_Xprod_Type" [a'] []) att1
    TBT_THF_Union_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TBT_THF_Union_Type" [a'] []) att1
    T0BT_THF_Binary_Type_Par a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0BT_THF_Binary_Type_Par" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TBT_THF_Mapping_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBT_THF_Mapping_Type a') }
    ShAAppl "TBT_THF_Xprod_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBT_THF_Xprod_Type a') }
    ShAAppl "TBT_THF_Union_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TBT_THF_Union_Type a') }
    ShAAppl "T0BT_THF_Binary_Type_Par" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0BT_THF_Binary_Type_Par a') }
    u -> fromShATermError "THFBinaryType" u

instance ShATermConvertible THFAtom where
  toShATermAux att0 xv = case xv of
    TA_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TA_Term" [a'] []) att1
    TA_THF_Conn_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TA_THF_Conn_Term" [a'] []) att1
    TA_Defined_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TA_Defined_Type" [a'] []) att1
    TA_Defined_Plain_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TA_Defined_Plain_Formula" [a'] []) att1
    TA_System_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TA_System_Type" [a'] []) att1
    TA_System_Atomic_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TA_System_Atomic_Formula" [a'] []) att1
    T0A_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0A_Constant" [a'] []) att1
    T0A_Defined_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0A_Defined_Constant" [a'] []) att1
    T0A_System_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0A_System_Constant" [a'] []) att1
    T0A_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0A_Variable" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TA_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TA_Term a') }
    ShAAppl "TA_THF_Conn_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TA_THF_Conn_Term a') }
    ShAAppl "TA_Defined_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TA_Defined_Type a') }
    ShAAppl "TA_Defined_Plain_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TA_Defined_Plain_Formula a') }
    ShAAppl "TA_System_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TA_System_Type a') }
    ShAAppl "TA_System_Atomic_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TA_System_Atomic_Formula a') }
    ShAAppl "T0A_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0A_Constant a') }
    ShAAppl "T0A_Defined_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0A_Defined_Constant a') }
    ShAAppl "T0A_System_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0A_System_Constant a') }
    ShAAppl "T0A_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0A_Variable a') }
    u -> fromShATermError "THFAtom" u

instance ShATermConvertible THFDefinedVar where
  toShATermAux att0 xv = case xv of
    TDV_THF_Defined_Var a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TDV_THF_Defined_Var" [a', b'] []) att2
    TDV_THF_Defined_Var_Par a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TDV_THF_Defined_Var_Par" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TDV_THF_Defined_Var" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TDV_THF_Defined_Var a' b') }}
    ShAAppl "TDV_THF_Defined_Var_Par" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TDV_THF_Defined_Var_Par a') }
    u -> fromShATermError "THFDefinedVar" u

instance ShATermConvertible THFSequent where
  toShATermAux att0 xv = case xv of
    TS_THF_Sequent a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TS_THF_Sequent" [a', b'] []) att2
    TS_THF_Sequent_Par a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TS_THF_Sequent_Par" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TS_THF_Sequent" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TS_THF_Sequent a' b') }}
    ShAAppl "TS_THF_Sequent_Par" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TS_THF_Sequent_Par a') }
    u -> fromShATermError "THFSequent" u

instance ShATermConvertible THFConnTerm where
  toShATermAux att0 xv = case xv of
    TCT_THF_Pair_Connective a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TCT_THF_Pair_Connective" [a'] []) att1
    TCT_Assoc_Connective a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TCT_Assoc_Connective" [a'] []) att1
    TCT_THF_Unary_Connective a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TCT_THF_Unary_Connective" [a'] []) att1
    T0CT_THF_Quantifier a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0CT_THF_Quantifier" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TCT_THF_Pair_Connective" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TCT_THF_Pair_Connective a') }
    ShAAppl "TCT_Assoc_Connective" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TCT_Assoc_Connective a') }
    ShAAppl "TCT_THF_Unary_Connective" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TCT_THF_Unary_Connective a') }
    ShAAppl "T0CT_THF_Quantifier" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0CT_THF_Quantifier a') }
    u -> fromShATermError "THFConnTerm" u

instance ShATermConvertible THFQuantifier where
  toShATermAux att0 xv = case xv of
    TQ_ForAll -> return $ addATerm (ShAAppl "TQ_ForAll" [] []) att0
    TQ_Exists -> return $ addATerm (ShAAppl "TQ_Exists" [] []) att0
    TQ_Lambda_Binder ->
      return $ addATerm (ShAAppl "TQ_Lambda_Binder" [] []) att0
    TQ_Dependent_Product ->
      return $ addATerm (ShAAppl "TQ_Dependent_Product" [] []) att0
    TQ_Dependent_Sum ->
      return $ addATerm (ShAAppl "TQ_Dependent_Sum" [] []) att0
    TQ_Indefinite_Description ->
      return $ addATerm (ShAAppl "TQ_Indefinite_Description" [] []) att0
    TQ_Definite_Description ->
      return $ addATerm (ShAAppl "TQ_Definite_Description" [] []) att0
    T0Q_PiForAll -> return $ addATerm (ShAAppl "T0Q_PiForAll" [] []) att0
    T0Q_SigmaExists -> return $ addATerm (ShAAppl "T0Q_SigmaExists" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TQ_ForAll" [] _ -> (att0, TQ_ForAll)
    ShAAppl "TQ_Exists" [] _ -> (att0, TQ_Exists)
    ShAAppl "TQ_Lambda_Binder" [] _ -> (att0, TQ_Lambda_Binder)
    ShAAppl "TQ_Dependent_Product" [] _ -> (att0, TQ_Dependent_Product)
    ShAAppl "TQ_Dependent_Sum" [] _ -> (att0, TQ_Dependent_Sum)
    ShAAppl "TQ_Indefinite_Description" [] _ -> (att0, TQ_Indefinite_Description)
    ShAAppl "TQ_Definite_Description" [] _ -> (att0, TQ_Definite_Description)
    ShAAppl "T0Q_PiForAll" [] _ -> (att0, T0Q_PiForAll)
    ShAAppl "T0Q_SigmaExists" [] _ -> (att0, T0Q_SigmaExists)
    u -> fromShATermError "THFQuantifier" u

instance ShATermConvertible Quantifier where
  toShATermAux att0 xv = case xv of
    T0Q_ForAll -> return $ addATerm (ShAAppl "T0Q_ForAll" [] []) att0
    T0Q_Exists -> return $ addATerm (ShAAppl "T0Q_Exists" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "T0Q_ForAll" [] _ -> (att0, T0Q_ForAll)
    ShAAppl "T0Q_Exists" [] _ -> (att0, T0Q_Exists)
    u -> fromShATermError "Quantifier" u

instance ShATermConvertible THFPairConnective where
  toShATermAux att0 xv = case xv of
    Infix_Equality -> return $ addATerm (ShAAppl "Infix_Equality" [] []) att0
    Infix_Inequality ->
      return $ addATerm (ShAAppl "Infix_Inequality" [] []) att0
    Equivalent -> return $ addATerm (ShAAppl "Equivalent" [] []) att0
    Implication -> return $ addATerm (ShAAppl "Implication" [] []) att0
    IF -> return $ addATerm (ShAAppl "IF" [] []) att0
    XOR -> return $ addATerm (ShAAppl "XOR" [] []) att0
    NOR -> return $ addATerm (ShAAppl "NOR" [] []) att0
    NAND -> return $ addATerm (ShAAppl "NAND" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Infix_Equality" [] _ -> (att0, Infix_Equality)
    ShAAppl "Infix_Inequality" [] _ -> (att0, Infix_Inequality)
    ShAAppl "Equivalent" [] _ -> (att0, Equivalent)
    ShAAppl "Implication" [] _ -> (att0, Implication)
    ShAAppl "IF" [] _ -> (att0, IF)
    ShAAppl "XOR" [] _ -> (att0, XOR)
    ShAAppl "NOR" [] _ -> (att0, NOR)
    ShAAppl "NAND" [] _ -> (att0, NAND)
    u -> fromShATermError "THFPairConnective" u

instance ShATermConvertible THFUnaryConnective where
  toShATermAux att0 xv = case xv of
    Negation -> return $ addATerm (ShAAppl "Negation" [] []) att0
    PiForAll -> return $ addATerm (ShAAppl "PiForAll" [] []) att0
    SigmaExists -> return $ addATerm (ShAAppl "SigmaExists" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Negation" [] _ -> (att0, Negation)
    ShAAppl "PiForAll" [] _ -> (att0, PiForAll)
    ShAAppl "SigmaExists" [] _ -> (att0, SigmaExists)
    u -> fromShATermError "THFUnaryConnective" u

instance ShATermConvertible AssocConnective where
  toShATermAux att0 xv = case xv of
    OR -> return $ addATerm (ShAAppl "OR" [] []) att0
    AND -> return $ addATerm (ShAAppl "AND" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OR" [] _ -> (att0, OR)
    ShAAppl "AND" [] _ -> (att0, AND)
    u -> fromShATermError "AssocConnective" u

instance ShATermConvertible DefinedType where
  toShATermAux att0 xv = case xv of
    DT_oType -> return $ addATerm (ShAAppl "DT_oType" [] []) att0
    DT_o -> return $ addATerm (ShAAppl "DT_o" [] []) att0
    DT_iType -> return $ addATerm (ShAAppl "DT_iType" [] []) att0
    DT_i -> return $ addATerm (ShAAppl "DT_i" [] []) att0
    DT_tType -> return $ addATerm (ShAAppl "DT_tType" [] []) att0
    DT_real -> return $ addATerm (ShAAppl "DT_real" [] []) att0
    DT_rat -> return $ addATerm (ShAAppl "DT_rat" [] []) att0
    DT_int -> return $ addATerm (ShAAppl "DT_int" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DT_oType" [] _ -> (att0, DT_oType)
    ShAAppl "DT_o" [] _ -> (att0, DT_o)
    ShAAppl "DT_iType" [] _ -> (att0, DT_iType)
    ShAAppl "DT_i" [] _ -> (att0, DT_i)
    ShAAppl "DT_tType" [] _ -> (att0, DT_tType)
    ShAAppl "DT_real" [] _ -> (att0, DT_real)
    ShAAppl "DT_rat" [] _ -> (att0, DT_rat)
    ShAAppl "DT_int" [] _ -> (att0, DT_int)
    u -> fromShATermError "DefinedType" u

instance ShATermConvertible DefinedPlainFormula where
  toShATermAux att0 xv = case xv of
    DPF_Defined_Prop a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DPF_Defined_Prop" [a'] []) att1
    DPF_Defined_Formula a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DPF_Defined_Formula" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DPF_Defined_Prop" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DPF_Defined_Prop a') }
    ShAAppl "DPF_Defined_Formula" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DPF_Defined_Formula a' b') }}
    u -> fromShATermError "DefinedPlainFormula" u

instance ShATermConvertible DefinedProp where
  toShATermAux att0 xv = case xv of
    DP_True -> return $ addATerm (ShAAppl "DP_True" [] []) att0
    DP_False -> return $ addATerm (ShAAppl "DP_False" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DP_True" [] _ -> (att0, DP_True)
    ShAAppl "DP_False" [] _ -> (att0, DP_False)
    u -> fromShATermError "DefinedProp" u

instance ShATermConvertible DefinedPred where
  toShATermAux att0 xv = case xv of
    Equal -> return $ addATerm (ShAAppl "Equal" [] []) att0
    Disrinct -> return $ addATerm (ShAAppl "Disrinct" [] []) att0
    Itef -> return $ addATerm (ShAAppl "Itef" [] []) att0
    Less -> return $ addATerm (ShAAppl "Less" [] []) att0
    Lesseq -> return $ addATerm (ShAAppl "Lesseq" [] []) att0
    Greater -> return $ addATerm (ShAAppl "Greater" [] []) att0
    Greatereq -> return $ addATerm (ShAAppl "Greatereq" [] []) att0
    Evaleq -> return $ addATerm (ShAAppl "Evaleq" [] []) att0
    Is_int -> return $ addATerm (ShAAppl "Is_int" [] []) att0
    Is_rat -> return $ addATerm (ShAAppl "Is_rat" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Equal" [] _ -> (att0, Equal)
    ShAAppl "Disrinct" [] _ -> (att0, Disrinct)
    ShAAppl "Itef" [] _ -> (att0, Itef)
    ShAAppl "Less" [] _ -> (att0, Less)
    ShAAppl "Lesseq" [] _ -> (att0, Lesseq)
    ShAAppl "Greater" [] _ -> (att0, Greater)
    ShAAppl "Greatereq" [] _ -> (att0, Greatereq)
    ShAAppl "Evaleq" [] _ -> (att0, Evaleq)
    ShAAppl "Is_int" [] _ -> (att0, Is_int)
    ShAAppl "Is_rat" [] _ -> (att0, Is_rat)
    u -> fromShATermError "DefinedPred" u

instance ShATermConvertible Term where
  toShATermAux att0 xv = case xv of
    T_Function_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T_Function_Term" [a'] []) att1
    T_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T_Variable" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "T_Function_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T_Function_Term a') }
    ShAAppl "T_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T_Variable a') }
    u -> fromShATermError "Term" u

instance ShATermConvertible FunctionTerm where
  toShATermAux att0 xv = case xv of
    FT_Plain_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FT_Plain_Term" [a'] []) att1
    FT_Defined_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FT_Defined_Term" [a'] []) att1
    FT_System_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FT_System_Term" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FT_Plain_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FT_Plain_Term a') }
    ShAAppl "FT_Defined_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FT_Defined_Term a') }
    ShAAppl "FT_System_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FT_System_Term a') }
    u -> fromShATermError "FunctionTerm" u

instance ShATermConvertible PlainTerm where
  toShATermAux att0 xv = case xv of
    PT_Plain_Term a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "PT_Plain_Term" [a', b'] []) att2
    PT_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PT_Constant" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PT_Plain_Term" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, PT_Plain_Term a' b') }}
    ShAAppl "PT_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PT_Constant a') }
    u -> fromShATermError "PlainTerm" u

instance ShATermConvertible DefinedTerm where
  toShATermAux att0 xv = case xv of
    DT_Defined_Atom a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DT_Defined_Atom" [a'] []) att1
    DT_Defined_Atomic_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DT_Defined_Atomic_Term" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DT_Defined_Atom" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DT_Defined_Atom a') }
    ShAAppl "DT_Defined_Atomic_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DT_Defined_Atomic_Term a') }
    u -> fromShATermError "DefinedTerm" u

instance ShATermConvertible DefinedAtom where
  toShATermAux att0 xv = case xv of
    DA_Number a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DA_Number" [a'] []) att1
    DA_Distinct_Object a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DA_Distinct_Object" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DA_Number" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DA_Number a') }
    ShAAppl "DA_Distinct_Object" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DA_Distinct_Object a') }
    u -> fromShATermError "DefinedAtom" u

instance ShATermConvertible DefinedPlainTerm where
  toShATermAux att0 xv = case xv of
    DPT_Defined_Function a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DPT_Defined_Function" [a', b'] []) att2
    DPT_Defined_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DPT_Defined_Constant" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DPT_Defined_Function" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DPT_Defined_Function a' b') }}
    ShAAppl "DPT_Defined_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DPT_Defined_Constant a') }
    u -> fromShATermError "DefinedPlainTerm" u

instance ShATermConvertible DefinedFunctor where
  toShATermAux att0 xv = case xv of
    Itett -> return $ addATerm (ShAAppl "Itett" [] []) att0
    Uminus -> return $ addATerm (ShAAppl "Uminus" [] []) att0
    Sum -> return $ addATerm (ShAAppl "Sum" [] []) att0
    Difference -> return $ addATerm (ShAAppl "Difference" [] []) att0
    Product -> return $ addATerm (ShAAppl "Product" [] []) att0
    To_int -> return $ addATerm (ShAAppl "To_int" [] []) att0
    To_rat -> return $ addATerm (ShAAppl "To_rat" [] []) att0
    To_real -> return $ addATerm (ShAAppl "To_real" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Itett" [] _ -> (att0, Itett)
    ShAAppl "Uminus" [] _ -> (att0, Uminus)
    ShAAppl "Sum" [] _ -> (att0, Sum)
    ShAAppl "Difference" [] _ -> (att0, Difference)
    ShAAppl "Product" [] _ -> (att0, Product)
    ShAAppl "To_int" [] _ -> (att0, To_int)
    ShAAppl "To_rat" [] _ -> (att0, To_rat)
    ShAAppl "To_real" [] _ -> (att0, To_real)
    u -> fromShATermError "DefinedFunctor" u

instance ShATermConvertible SystemTerm where
  toShATermAux att0 xv = case xv of
    ST_System_Term a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ST_System_Term" [a', b'] []) att2
    ST_System_Constant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ST_System_Constant" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ST_System_Term" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ST_System_Term a' b') }}
    ShAAppl "ST_System_Constant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ST_System_Constant a') }
    u -> fromShATermError "SystemTerm" u

instance ShATermConvertible PrincipalSymbol where
  toShATermAux att0 xv = case xv of
    PS_Functor a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PS_Functor" [a'] []) att1
    PS_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PS_Variable" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PS_Functor" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PS_Functor a') }
    ShAAppl "PS_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PS_Variable a') }
    u -> fromShATermError "PrincipalSymbol" u

instance ShATermConvertible Source where
  toShATermAux att0 xv = case xv of
    S_Dag_Source a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "S_Dag_Source" [a'] []) att1
    S_Internal_Source a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "S_Internal_Source" [a', b'] []) att2
    S_External_Source a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "S_External_Source" [a'] []) att1
    S_Sources a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "S_Sources" [a'] []) att1
    S_Unknown -> return $ addATerm (ShAAppl "S_Unknown" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "S_Dag_Source" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, S_Dag_Source a') }
    ShAAppl "S_Internal_Source" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, S_Internal_Source a' b') }}
    ShAAppl "S_External_Source" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, S_External_Source a') }
    ShAAppl "S_Sources" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, S_Sources a') }
    ShAAppl "S_Unknown" [] _ -> (att0, S_Unknown)
    u -> fromShATermError "Source" u

instance ShATermConvertible DagSource where
  toShATermAux att0 xv = case xv of
    DS_Name a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DS_Name" [a'] []) att1
    DS_Inference_Record a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "DS_Inference_Record" [a', b',
                                                        c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DS_Name" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DS_Name a') }
    ShAAppl "DS_Inference_Record" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, DS_Inference_Record a' b' c') }}}
    u -> fromShATermError "DagSource" u

instance ShATermConvertible ParentInfo where
  toShATermAux att0 xv = case xv of
    PI_Parent_Info a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "PI_Parent_Info" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PI_Parent_Info" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, PI_Parent_Info a' b') }}
    u -> fromShATermError "ParentInfo" u

instance ShATermConvertible IntroType where
  toShATermAux att0 xv = case xv of
    IT_definition -> return $ addATerm (ShAAppl "IT_definition" [] []) att0
    IT_axiom_of_choice ->
      return $ addATerm (ShAAppl "IT_axiom_of_choice" [] []) att0
    IT_tautology -> return $ addATerm (ShAAppl "IT_tautology" [] []) att0
    IT_assumption -> return $ addATerm (ShAAppl "IT_assumption" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "IT_definition" [] _ -> (att0, IT_definition)
    ShAAppl "IT_axiom_of_choice" [] _ -> (att0, IT_axiom_of_choice)
    ShAAppl "IT_tautology" [] _ -> (att0, IT_tautology)
    ShAAppl "IT_assumption" [] _ -> (att0, IT_assumption)
    u -> fromShATermError "IntroType" u

instance ShATermConvertible ExternalSource where
  toShATermAux att0 xv = case xv of
    ES_File_Source a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ES_File_Source" [a'] []) att1
    ES_Theory a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ES_Theory" [a', b'] []) att2
    ES_Creator_Source a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ES_Creator_Source" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ES_File_Source" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ES_File_Source a') }
    ShAAppl "ES_Theory" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ES_Theory a' b') }}
    ShAAppl "ES_Creator_Source" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ES_Creator_Source a' b') }}
    u -> fromShATermError "ExternalSource" u

instance ShATermConvertible FileSource where
  toShATermAux att0 xv = case xv of
    FS_File a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FS_File" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FS_File" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FS_File a' b') }}
    u -> fromShATermError "FileSource" u

instance ShATermConvertible TheoryName where
  toShATermAux att0 xv = case xv of
    Equality -> return $ addATerm (ShAAppl "Equality" [] []) att0
    Ac -> return $ addATerm (ShAAppl "Ac" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Equality" [] _ -> (att0, Equality)
    ShAAppl "Ac" [] _ -> (att0, Ac)
    u -> fromShATermError "TheoryName" u

instance ShATermConvertible InfoItem where
  toShATermAux att0 xv = case xv of
    II_Formula_Item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "II_Formula_Item" [a'] []) att1
    II_Inference_Item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "II_Inference_Item" [a'] []) att1
    II_General_Function a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "II_General_Function" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "II_Formula_Item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, II_Formula_Item a') }
    ShAAppl "II_Inference_Item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, II_Inference_Item a') }
    ShAAppl "II_General_Function" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, II_General_Function a') }
    u -> fromShATermError "InfoItem" u

instance ShATermConvertible FormulaItem where
  toShATermAux att0 xv = case xv of
    FI_Description_Item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FI_Description_Item" [a'] []) att1
    FI_Iquote_Item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FI_Iquote_Item" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FI_Description_Item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FI_Description_Item a') }
    ShAAppl "FI_Iquote_Item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FI_Iquote_Item a') }
    u -> fromShATermError "FormulaItem" u

instance ShATermConvertible InferenceItem where
  toShATermAux att0 xv = case xv of
    II_Inference_Status a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "II_Inference_Status" [a'] []) att1
    II_Assumptions_Record a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "II_Assumptions_Record" [a'] []) att1
    II_New_Symbol_Record a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "II_New_Symbol_Record" [a', b'] []) att2
    II_Refutation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "II_Refutation" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "II_Inference_Status" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, II_Inference_Status a') }
    ShAAppl "II_Assumptions_Record" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, II_Assumptions_Record a') }
    ShAAppl "II_New_Symbol_Record" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, II_New_Symbol_Record a' b') }}
    ShAAppl "II_Refutation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, II_Refutation a') }
    u -> fromShATermError "InferenceItem" u

instance ShATermConvertible InferenceStatus where
  toShATermAux att0 xv = case xv of
    IS_Status a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "IS_Status" [a'] []) att1
    IS_Inference_Info a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "IS_Inference_Info" [a', b',
                                                      c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "IS_Status" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, IS_Status a') }
    ShAAppl "IS_Inference_Info" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, IS_Inference_Info a' b' c') }}}
    u -> fromShATermError "InferenceStatus" u

instance ShATermConvertible StatusValue where
  toShATermAux att0 xv = case xv of
    Suc -> return $ addATerm (ShAAppl "Suc" [] []) att0
    Unp -> return $ addATerm (ShAAppl "Unp" [] []) att0
    Sap -> return $ addATerm (ShAAppl "Sap" [] []) att0
    Esa -> return $ addATerm (ShAAppl "Esa" [] []) att0
    Sat -> return $ addATerm (ShAAppl "Sat" [] []) att0
    Fsa -> return $ addATerm (ShAAppl "Fsa" [] []) att0
    Thm -> return $ addATerm (ShAAppl "Thm" [] []) att0
    Eqv -> return $ addATerm (ShAAppl "Eqv" [] []) att0
    Tac -> return $ addATerm (ShAAppl "Tac" [] []) att0
    Wec -> return $ addATerm (ShAAppl "Wec" [] []) att0
    Eth -> return $ addATerm (ShAAppl "Eth" [] []) att0
    Tau -> return $ addATerm (ShAAppl "Tau" [] []) att0
    Wtc -> return $ addATerm (ShAAppl "Wtc" [] []) att0
    Wth -> return $ addATerm (ShAAppl "Wth" [] []) att0
    Cax -> return $ addATerm (ShAAppl "Cax" [] []) att0
    Sca -> return $ addATerm (ShAAppl "Sca" [] []) att0
    Tca -> return $ addATerm (ShAAppl "Tca" [] []) att0
    Wca -> return $ addATerm (ShAAppl "Wca" [] []) att0
    Cup -> return $ addATerm (ShAAppl "Cup" [] []) att0
    Csp -> return $ addATerm (ShAAppl "Csp" [] []) att0
    Ecs -> return $ addATerm (ShAAppl "Ecs" [] []) att0
    Csa -> return $ addATerm (ShAAppl "Csa" [] []) att0
    Cth -> return $ addATerm (ShAAppl "Cth" [] []) att0
    Ceq -> return $ addATerm (ShAAppl "Ceq" [] []) att0
    Unc -> return $ addATerm (ShAAppl "Unc" [] []) att0
    Wcc -> return $ addATerm (ShAAppl "Wcc" [] []) att0
    Ect -> return $ addATerm (ShAAppl "Ect" [] []) att0
    Fun -> return $ addATerm (ShAAppl "Fun" [] []) att0
    Uns -> return $ addATerm (ShAAppl "Uns" [] []) att0
    Wuc -> return $ addATerm (ShAAppl "Wuc" [] []) att0
    Wct -> return $ addATerm (ShAAppl "Wct" [] []) att0
    Scc -> return $ addATerm (ShAAppl "Scc" [] []) att0
    Uca -> return $ addATerm (ShAAppl "Uca" [] []) att0
    Noc -> return $ addATerm (ShAAppl "Noc" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Suc" [] _ -> (att0, Suc)
    ShAAppl "Unp" [] _ -> (att0, Unp)
    ShAAppl "Sap" [] _ -> (att0, Sap)
    ShAAppl "Esa" [] _ -> (att0, Esa)
    ShAAppl "Sat" [] _ -> (att0, Sat)
    ShAAppl "Fsa" [] _ -> (att0, Fsa)
    ShAAppl "Thm" [] _ -> (att0, Thm)
    ShAAppl "Eqv" [] _ -> (att0, Eqv)
    ShAAppl "Tac" [] _ -> (att0, Tac)
    ShAAppl "Wec" [] _ -> (att0, Wec)
    ShAAppl "Eth" [] _ -> (att0, Eth)
    ShAAppl "Tau" [] _ -> (att0, Tau)
    ShAAppl "Wtc" [] _ -> (att0, Wtc)
    ShAAppl "Wth" [] _ -> (att0, Wth)
    ShAAppl "Cax" [] _ -> (att0, Cax)
    ShAAppl "Sca" [] _ -> (att0, Sca)
    ShAAppl "Tca" [] _ -> (att0, Tca)
    ShAAppl "Wca" [] _ -> (att0, Wca)
    ShAAppl "Cup" [] _ -> (att0, Cup)
    ShAAppl "Csp" [] _ -> (att0, Csp)
    ShAAppl "Ecs" [] _ -> (att0, Ecs)
    ShAAppl "Csa" [] _ -> (att0, Csa)
    ShAAppl "Cth" [] _ -> (att0, Cth)
    ShAAppl "Ceq" [] _ -> (att0, Ceq)
    ShAAppl "Unc" [] _ -> (att0, Unc)
    ShAAppl "Wcc" [] _ -> (att0, Wcc)
    ShAAppl "Ect" [] _ -> (att0, Ect)
    ShAAppl "Fun" [] _ -> (att0, Fun)
    ShAAppl "Uns" [] _ -> (att0, Uns)
    ShAAppl "Wuc" [] _ -> (att0, Wuc)
    ShAAppl "Wct" [] _ -> (att0, Wct)
    ShAAppl "Scc" [] _ -> (att0, Scc)
    ShAAppl "Uca" [] _ -> (att0, Uca)
    ShAAppl "Noc" [] _ -> (att0, Noc)
    u -> fromShATermError "StatusValue" u

instance ShATermConvertible GeneralTerm where
  toShATermAux att0 xv = case xv of
    GT_General_Data a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GT_General_Data" [a'] []) att1
    GT_General_Data_Term a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "GT_General_Data_Term" [a', b'] []) att2
    GT_General_List a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GT_General_List" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "GT_General_Data" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GT_General_Data a') }
    ShAAppl "GT_General_Data_Term" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, GT_General_Data_Term a' b') }}
    ShAAppl "GT_General_List" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GT_General_List a') }
    u -> fromShATermError "GeneralTerm" u

instance ShATermConvertible GeneralData where
  toShATermAux att0 xv = case xv of
    GD_Atomic_Word a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GD_Atomic_Word" [a'] []) att1
    GD_Variable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GD_Variable" [a'] []) att1
    GD_Number a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GD_Number" [a'] []) att1
    GD_Distinct_Object a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GD_Distinct_Object" [a'] []) att1
    GD_Formula_Data a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GD_Formula_Data" [a'] []) att1
    GD_Bind a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "GD_Bind" [a', b'] []) att2
    GD_General_Function a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GD_General_Function" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "GD_Atomic_Word" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GD_Atomic_Word a') }
    ShAAppl "GD_Variable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GD_Variable a') }
    ShAAppl "GD_Number" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GD_Number a') }
    ShAAppl "GD_Distinct_Object" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GD_Distinct_Object a') }
    ShAAppl "GD_Formula_Data" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GD_Formula_Data a') }
    ShAAppl "GD_Bind" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, GD_Bind a' b') }}
    ShAAppl "GD_General_Function" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GD_General_Function a') }
    u -> fromShATermError "GeneralData" u

instance ShATermConvertible GeneralFunction where
  toShATermAux att0 xv = case xv of
    GF_General_Function a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "GF_General_Function" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "GF_General_Function" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, GF_General_Function a' b') }}
    u -> fromShATermError "GeneralFunction" u

instance ShATermConvertible FormulaData where
  toShATermAux att0 xv = case xv of
    THF_Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "THF_Formula" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "THF_Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, THF_Formula a') }
    u -> fromShATermError "FormulaData" u

instance ShATermConvertible Name where
  toShATermAux att0 xv = case xv of
    N_Atomic_Word a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "N_Atomic_Word" [a'] []) att1
    N_Integer a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "N_Integer" [a'] []) att1
    T0N_Unsigned_Integer a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "T0N_Unsigned_Integer" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "N_Atomic_Word" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, N_Atomic_Word a') }
    ShAAppl "N_Integer" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, N_Integer a') }
    ShAAppl "T0N_Unsigned_Integer" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, T0N_Unsigned_Integer a') }
    u -> fromShATermError "Name" u

instance ShATermConvertible AtomicWord where
  toShATermAux att0 xv = case xv of
    A_Lower_Word a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "A_Lower_Word" [a'] []) att1
    A_Single_Quoted a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "A_Single_Quoted" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "A_Lower_Word" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, A_Lower_Word a') }
    ShAAppl "A_Single_Quoted" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, A_Single_Quoted a') }
    u -> fromShATermError "AtomicWord" u

instance ShATermConvertible Number where
  toShATermAux att0 xv = case xv of
    Num_Integer a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Num_Integer" [a'] []) att1
    Num_Rational a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Num_Rational" [a'] []) att1
    Num_Real a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Num_Real" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Num_Integer" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Num_Integer a') }
    ShAAppl "Num_Rational" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Num_Rational a') }
    ShAAppl "Num_Real" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Num_Real a') }
    u -> fromShATermError "Number" u

instance ShATermConvertible Kind where
  toShATermAux att0 xv = case xv of
    Kind -> return $ addATerm (ShAAppl "Kind" [] []) att0
    MapKind a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "MapKind" [a', b', c'] []) att3
    SysType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SysType" [a'] []) att1
    VKind a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "VKind" [a'] []) att1
    ParKind a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ParKind" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Kind" [] _ -> (att0, Kind)
    ShAAppl "MapKind" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, MapKind a' b' c') }}}
    ShAAppl "SysType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SysType a') }
    ShAAppl "VKind" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, VKind a') }
    ShAAppl "ParKind" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ParKind a') }
    u -> fromShATermError "Kind" u

instance ShATermConvertible Type where
  toShATermAux att0 xv = case xv of
    TType -> return $ addATerm (ShAAppl "TType" [] []) att0
    OType -> return $ addATerm (ShAAppl "OType" [] []) att0
    IType -> return $ addATerm (ShAAppl "IType" [] []) att0
    MapType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MapType" [a', b'] []) att2
    CType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CType" [a'] []) att1
    SType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SType" [a'] []) att1
    VType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "VType" [a'] []) att1
    ParType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ParType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TType" [] _ -> (att0, TType)
    ShAAppl "OType" [] _ -> (att0, OType)
    ShAAppl "IType" [] _ -> (att0, IType)
    ShAAppl "MapType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MapType a' b') }}
    ShAAppl "CType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CType a') }
    ShAAppl "SType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SType a') }
    ShAAppl "VType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, VType a') }
    ShAAppl "ParType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ParType a') }
    u -> fromShATermError "Type" u

instance ShATermConvertible SymbolType where
  toShATermAux att0 xv = case xv of
    ST_Const a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ST_Const" [a'] []) att1
    ST_Type a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ST_Type" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ST_Const" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ST_Const a') }
    ShAAppl "ST_Type" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ST_Type a') }
    u -> fromShATermError "SymbolType" u

instance ShATermConvertible SymbolTHF where
  toShATermAux att0 xv = case xv of
    Symbol a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Symbol" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Symbol a' b' c') }}}
    u -> fromShATermError "SymbolTHF" u

instance ShATermConvertible SentenceTHF where
  toShATermAux att0 xv = case xv of
    Sentence a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Sentence" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sentence" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Sentence a' b' c') }}}
    u -> fromShATermError "SentenceTHF" u

instance ShATermConvertible BasicSpecTHF where
  toShATermAux att0 xv = case xv of
    BasicSpecTHF a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "BasicSpecTHF" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "BasicSpecTHF" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, BasicSpecTHF a' b') }}
    u -> fromShATermError "BasicSpecTHF" u

instance ShATermConvertible THFBS where
  toShATermAux att0 xv = case xv of
    BSTHF0 -> return $ addATerm (ShAAppl "BSTHF0" [] []) att0
    BSTHF -> return $ addATerm (ShAAppl "BSTHF" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "BSTHF0" [] _ -> (att0, BSTHF0)
    ShAAppl "BSTHF" [] _ -> (att0, BSTHF)
    u -> fromShATermError "THFBS" u

_tcKindTc :: TyCon
_tcKindTc = mkTyCon "THF.Cons.Kind"
instance Typeable Kind where
    typeOf _ = mkTyConApp _tcKindTc []

_tcTypeTc :: TyCon
_tcTypeTc = mkTyCon "THF.Cons.Type"
instance Typeable Type where
    typeOf _ = mkTyConApp _tcTypeTc []

_tcSymbolTypeTc :: TyCon
_tcSymbolTypeTc = mkTyCon "THF.Cons.SymbolType"
instance Typeable SymbolType where
    typeOf _ = mkTyConApp _tcSymbolTypeTc []

_tcSymbolTHFTc :: TyCon
_tcSymbolTHFTc = mkTyCon "THF.Cons.SymbolTHF"
instance Typeable SymbolTHF where
    typeOf _ = mkTyConApp _tcSymbolTHFTc []

_tcSentenceTHFTc :: TyCon
_tcSentenceTHFTc = mkTyCon "THF.Cons.SentenceTHF"
instance Typeable SentenceTHF where
    typeOf _ = mkTyConApp _tcSentenceTHFTc []

_tcBasicSpecTHFTc :: TyCon
_tcBasicSpecTHFTc = mkTyCon "THF.Cons.BasicSpecTHF"
instance Typeable BasicSpecTHF where
    typeOf _ = mkTyConApp _tcBasicSpecTHFTc []

_tcTHFBSTc :: TyCon
_tcTHFBSTc = mkTyCon "THF.Cons.THFBS"
instance Typeable THFBS where
    typeOf _ = mkTyConApp _tcTHFBSTc []

_tcSignTHFTc :: TyCon
_tcSignTHFTc = mkTyCon "THF.Sign.SignTHF"
instance Typeable SignTHF where
    typeOf _ = mkTyConApp _tcSignTHFTc []

_tcTypeInfoTc :: TyCon
_tcTypeInfoTc = mkTyCon "THF.Sign.TypeInfo"
instance Typeable TypeInfo where
    typeOf _ = mkTyConApp _tcTypeInfoTc []

_tcConstInfoTc :: TyCon
_tcConstInfoTc = mkTyCon "THF.Sign.ConstInfo"
instance Typeable ConstInfo where
    typeOf _ = mkTyConApp _tcConstInfoTc []

instance ShATermConvertible SignTHF where
  toShATermAux att0 xv = case xv of
    Sign a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Sign" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Sign a' b' c') }}}
    u -> fromShATermError "SignTHF" u

instance ShATermConvertible TypeInfo where
  toShATermAux att0 xv = case xv of
    TypeInfo a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "TypeInfo" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeInfo" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, TypeInfo a' b' c' d' e') }}}}}
    u -> fromShATermError "TypeInfo" u

instance ShATermConvertible ConstInfo where
  toShATermAux att0 xv = case xv of
    ConstInfo a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "ConstInfo" [a', b', c', d',
                                              e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ConstInfo" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, ConstInfo a' b' c' d' e') }}}}}
    u -> fromShATermError "ConstInfo" u
