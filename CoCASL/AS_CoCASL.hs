{- |
Module      :  $Header$
Description :  Abstract syntax for CoCASL
Copyright   :  (c) T.Mossakowski, C.Maeder, Uni Bremen 2004-2006
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  hausmann@informatik.uni-bremen.de
Stability   :  provisional
Portability :  portable

Abstract syntax for CoCASL, the coalgebraic extension of CASL
  Only the added syntax is specified
-}

module CoCASL.AS_CoCASL where

import Common.Id
import Common.AS_Annotation
import CASL.AS_Basic_CASL

-- DrIFT command
{-! global: GetRange !-}

type C_BASIC_SPEC = BASIC_SPEC C_BASIC_ITEM C_SIG_ITEM C_FORMULA

type AnModFORM = Annoted (FORMULA C_FORMULA)

data C_BASIC_ITEM = CoFree_datatype [Annoted CODATATYPE_DECL] Range
                   -- pos: free, type, semi colons
                  | CoSort_gen [Annoted (SIG_ITEMS C_SIG_ITEM C_FORMULA)] Range
                   -- pos: generated, opt. braces
                  deriving Show

data C_SIG_ITEM = CoDatatype_items [Annoted CODATATYPE_DECL] Range
                 -- type, semi colons
                  deriving Show

data CODATATYPE_DECL = CoDatatype_decl SORT [Annoted COALTERNATIVE] Range
                     -- pos: "::=", "|"s
                       deriving Show

data COALTERNATIVE = Co_construct OpKind (Maybe OP_NAME) [COCOMPONENTS] Range
                   -- True if Total, pos: "(", semi colons, ")"
                 | CoSubsorts [SORT] Range
                   -- pos: sort, commas
                  deriving Show

data COCOMPONENTS = CoSelect [OP_NAME] OP_TYPE Range
                  -- pos: commas, colon
                  deriving Show

data MODALITY = Simple_mod SIMPLE_ID | Term_mod (TERM C_FORMULA)
             deriving (Eq, Ord, Show)

data C_FORMULA = BoxOrDiamond Bool MODALITY (FORMULA C_FORMULA) Range
               -- The identifier and the term specify the kind of the modality
               -- pos: "[]" or  "<>", True if Box, False if Diamond
               | CoSort_gen_ax [SORT] [OP_SYMB] Bool
               -- flag: belongs to a cofree type and hence is cofreeness axiom?
             deriving (Eq, Ord, Show)

-- Generated by DrIFT, look but don't touch!

instance GetRange C_BASIC_ITEM where
  getRange x = case x of
    CoFree_datatype _ p -> p
    CoSort_gen _ p -> p
  rangeSpan x = case x of
    CoFree_datatype a b -> joinRanges [rangeSpan a, rangeSpan b]
    CoSort_gen a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange C_SIG_ITEM where
  getRange x = case x of
    CoDatatype_items _ p -> p
  rangeSpan x = case x of
    CoDatatype_items a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange CODATATYPE_DECL where
  getRange x = case x of
    CoDatatype_decl _ _ p -> p
  rangeSpan x = case x of
    CoDatatype_decl a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                         rangeSpan c]

instance GetRange COALTERNATIVE where
  getRange x = case x of
    Co_construct _ _ _ p -> p
    CoSubsorts _ p -> p
  rangeSpan x = case x of
    Co_construct a b c d -> joinRanges [rangeSpan a, rangeSpan b,
                                        rangeSpan c, rangeSpan d]
    CoSubsorts a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange COCOMPONENTS where
  getRange x = case x of
    CoSelect _ _ p -> p
  rangeSpan x = case x of
    CoSelect a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                  rangeSpan c]

instance GetRange MODALITY where
  getRange = const nullRange
  rangeSpan x = case x of
    Simple_mod a -> joinRanges [rangeSpan a]
    Term_mod a -> joinRanges [rangeSpan a]

instance GetRange C_FORMULA where
  getRange x = case x of
    BoxOrDiamond _ _ _ p -> p
    CoSort_gen_ax _ _ _ -> nullRange
  rangeSpan x = case x of
    BoxOrDiamond a b c d -> joinRanges [rangeSpan a, rangeSpan b,
                                        rangeSpan c, rangeSpan d]
    CoSort_gen_ax a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                       rangeSpan c]
