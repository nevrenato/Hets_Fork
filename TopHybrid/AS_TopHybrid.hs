{-# LANGUAGE StandaloneDeriving, ExistentialQuantification, DeriveDataTypeable #-}
{- |
Module      :  $Header$
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  nevrenato@gmail.com
Stability   :  experimental
Portability :  portable

Description :
Abstract syntax for hybrid logic with an arbitrary logic
below. 
-}

module TopHybrid.AS_TopHybrid where

import Common.Id
import Data.Typeable
import ATerm.Lib
import Logic.Logic
-- DrIFT command
{-! global: GetRange !-}

data TH_BSPEC s = Bspec { bitems :: [TH_BASIC_ITEM],  und :: s } deriving Show

data TH_BASIC_ITEM = Simple_mod_decl [MODALITY] Range
                   | Simple_nom_decl [NOMINAL] Range 
                     deriving Show

type MODALITY = SIMPLE_ID
type NOMINAL = SIMPLE_ID

data TH_FORMULA f = At NOMINAL (TH_FORMULA f) Range 
                  | Box MODALITY (TH_FORMULA f) Range
                  | Dia MODALITY (TH_FORMULA f) Range
                  | UnderLogic f
                  | Conjunction (TH_FORMULA f) (TH_FORMULA f)
                  | Disjunction (TH_FORMULA f) (TH_FORMULA f)
                  | Implication (TH_FORMULA f) (TH_FORMULA f)
                  | BiImplication (TH_FORMULA f) (TH_FORMULA f) -- ??
                  | Here NOMINAL f Range  
                    deriving (Show, Eq, Ord)

data Form_Wrapper = forall f. (Show f, GetRange f, ShATermConvertible f) 
                                => Form_Wrapper (TH_FORMULA f)


data Spec_Wrapper = forall s. (Show s, GetRange s, ShATermConvertible s) 
                                => Spec_Wrapper AnyLogic (TH_BSPEC s) [Form_Wrapper]

data Mor = Mor 
deriving instance Ord Mor
deriving instance Eq Mor
deriving instance Show Mor

----- Boring instances needed for a valid program, that DriFT cannot generate
deriving instance Show Form_Wrapper
deriving instance Show Spec_Wrapper
deriving instance Typeable Form_Wrapper
deriving instance Typeable Spec_Wrapper

instance Ord Form_Wrapper where
       compare _ _ = EQ 
instance Eq Form_Wrapper where
       (==) _ _ = False 

instance Ord Spec_Wrapper where
        compare _ _  = EQ 
instance Eq Spec_Wrapper where
       (==) _ _  = False 

instance GetRange Form_Wrapper where
        getRange (Form_Wrapper f) = getRange f
        rangeSpan (Form_Wrapper f) = rangeSpan f

instance GetRange Spec_Wrapper where
        getRange (Spec_Wrapper _ s _) = getRange s
        rangeSpan (Spec_Wrapper _ s _) = rangeSpan s

-- Generated by DrIFT, look but don't touch!

instance GetRange s => GetRange (TH_BSPEC s) where
  getRange = const nullRange
  rangeSpan x = case x of
    Bspec a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange TH_BASIC_ITEM where
  getRange x = case x of
    Simple_mod_decl _ p -> p
    Simple_nom_decl _ p -> p
  rangeSpan x = case x of
    Simple_mod_decl a b -> joinRanges [rangeSpan a, rangeSpan b]
    Simple_nom_decl a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange f => GetRange (TH_FORMULA f) where
  getRange x = case x of
    At _ _ p -> p
    Box _ _ p -> p
    Dia _ _ p -> p
    UnderLogic _ -> nullRange
    Conjunction _ _ -> nullRange
    Disjunction _ _ -> nullRange
    Implication _ _ -> nullRange
    BiImplication _ _ -> nullRange
    Here _ _ p -> p
  rangeSpan x = case x of
    At a b c -> joinRanges [rangeSpan a, rangeSpan b, rangeSpan c]
    Box a b c -> joinRanges [rangeSpan a, rangeSpan b, rangeSpan c]
    Dia a b c -> joinRanges [rangeSpan a, rangeSpan b, rangeSpan c]
    UnderLogic a -> joinRanges [rangeSpan a]
    Conjunction a b -> joinRanges [rangeSpan a, rangeSpan b]
    Disjunction a b -> joinRanges [rangeSpan a, rangeSpan b]
    Implication a b -> joinRanges [rangeSpan a, rangeSpan b]
    BiImplication a b -> joinRanges [rangeSpan a, rangeSpan b]
    Here a b c -> joinRanges [rangeSpan a, rangeSpan b, rangeSpan c]

instance GetRange Mor where
  getRange = const nullRange
  rangeSpan x = case x of
    Mor -> []
