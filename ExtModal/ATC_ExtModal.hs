{-# OPTIONS -w -O0 #-}
{- |
Module      :  ExtModal/ATC_ExtModal.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'ExtModal.AS_ExtModal.ModDefn'
'ExtModal.AS_ExtModal.EM_BASIC_ITEM'
'ExtModal.AS_ExtModal.ModOp'
'ExtModal.AS_ExtModal.MODALITY'
'ExtModal.AS_ExtModal.EM_SIG_ITEM'
'ExtModal.AS_ExtModal.EM_FORMULA'
'ExtModal.ExtModalSign.EModalSign'
'ExtModal.MorphismExtension.MorphExtension'
'ExtModal.Sublogic.Frequency'
'ExtModal.Sublogic.Sublogic'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
ExtModal/AS_ExtModal.hs
ExtModal/ExtModalSign.hs
ExtModal/MorphismExtension.hs
ExtModal/Sublogic.hs
-}

module ExtModal.ATC_ExtModal () where

import ATerm.Lib
import CASL.AS_Basic_CASL
import CASL.ATC_CASL
import CASL.MapSentence
import CASL.Morphism
import CASL.Sign
import Common.AS_Annotation
import Common.Doc
import Common.DocUtils
import Common.Id
import Common.Utils
import Data.Typeable
import ExtModal.AS_ExtModal
import ExtModal.ExtModalSign
import ExtModal.MorphismExtension
import ExtModal.Print_AS ()
import ExtModal.Sublogic
import qualified Common.Lib.MapSet as MapSet
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for ExtModal.AS_ExtModal.ModDefn derive : Typeable !-}
{-! for ExtModal.AS_ExtModal.EM_BASIC_ITEM derive : Typeable !-}
{-! for ExtModal.AS_ExtModal.ModOp derive : Typeable !-}
{-! for ExtModal.AS_ExtModal.MODALITY derive : Typeable !-}
{-! for ExtModal.AS_ExtModal.EM_SIG_ITEM derive : Typeable !-}
{-! for ExtModal.AS_ExtModal.EM_FORMULA derive : Typeable !-}
{-! for ExtModal.ExtModalSign.EModalSign derive : Typeable !-}
{-! for ExtModal.MorphismExtension.MorphExtension derive : Typeable !-}
{-! for ExtModal.Sublogic.Frequency derive : Typeable !-}
{-! for ExtModal.Sublogic.Sublogic derive : Typeable !-}

{-! for ExtModal.AS_ExtModal.ModDefn derive : ShATermConvertible !-}
{-! for ExtModal.AS_ExtModal.EM_BASIC_ITEM derive : ShATermConvertible !-}
{-! for ExtModal.AS_ExtModal.ModOp derive : ShATermConvertible !-}
{-! for ExtModal.AS_ExtModal.MODALITY derive : ShATermConvertible !-}
{-! for ExtModal.AS_ExtModal.EM_SIG_ITEM derive : ShATermConvertible !-}
{-! for ExtModal.AS_ExtModal.EM_FORMULA derive : ShATermConvertible !-}
{-! for ExtModal.ExtModalSign.EModalSign derive : ShATermConvertible !-}
{-! for ExtModal.MorphismExtension.MorphExtension derive : ShATermConvertible !-}
{-! for ExtModal.Sublogic.Frequency derive : ShATermConvertible !-}
{-! for ExtModal.Sublogic.Sublogic derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcModDefnTc :: TyCon
_tcModDefnTc = mkTyCon "ExtModal.AS_ExtModal.ModDefn"
instance Typeable ModDefn where
    typeOf _ = mkTyConApp _tcModDefnTc []

_tcEM_BASIC_ITEMTc :: TyCon
_tcEM_BASIC_ITEMTc = mkTyCon "ExtModal.AS_ExtModal.EM_BASIC_ITEM"
instance Typeable EM_BASIC_ITEM where
    typeOf _ = mkTyConApp _tcEM_BASIC_ITEMTc []

_tcModOpTc :: TyCon
_tcModOpTc = mkTyCon "ExtModal.AS_ExtModal.ModOp"
instance Typeable ModOp where
    typeOf _ = mkTyConApp _tcModOpTc []

_tcMODALITYTc :: TyCon
_tcMODALITYTc = mkTyCon "ExtModal.AS_ExtModal.MODALITY"
instance Typeable MODALITY where
    typeOf _ = mkTyConApp _tcMODALITYTc []

_tcEM_SIG_ITEMTc :: TyCon
_tcEM_SIG_ITEMTc = mkTyCon "ExtModal.AS_ExtModal.EM_SIG_ITEM"
instance Typeable EM_SIG_ITEM where
    typeOf _ = mkTyConApp _tcEM_SIG_ITEMTc []

_tcEM_FORMULATc :: TyCon
_tcEM_FORMULATc = mkTyCon "ExtModal.AS_ExtModal.EM_FORMULA"
instance Typeable EM_FORMULA where
    typeOf _ = mkTyConApp _tcEM_FORMULATc []

instance ShATermConvertible ModDefn where
  toShATermAux att0 xv = case xv of
    ModDefn a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "ModDefn" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ModDefn" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, ModDefn a' b' c' d' e') }}}}}
    u -> fromShATermError "ModDefn" u

instance ShATermConvertible EM_BASIC_ITEM where
  toShATermAux att0 xv = case xv of
    ModItem a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ModItem" [a'] []) att1
    Nominal_decl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Nominal_decl" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ModItem" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ModItem a') }
    ShAAppl "Nominal_decl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Nominal_decl a' b') }}
    u -> fromShATermError "EM_BASIC_ITEM" u

instance ShATermConvertible ModOp where
  toShATermAux att0 xv = case xv of
    Composition -> return $ addATerm (ShAAppl "Composition" [] []) att0
    Intersection -> return $ addATerm (ShAAppl "Intersection" [] []) att0
    Union -> return $ addATerm (ShAAppl "Union" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Composition" [] _ -> (att0, Composition)
    ShAAppl "Intersection" [] _ -> (att0, Intersection)
    ShAAppl "Union" [] _ -> (att0, Union)
    u -> fromShATermError "ModOp" u

instance ShATermConvertible MODALITY where
  toShATermAux att0 xv = case xv of
    SimpleMod a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SimpleMod" [a'] []) att1
    TermMod a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TermMod" [a'] []) att1
    ModOp a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ModOp" [a', b', c'] []) att3
    TransClos a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TransClos" [a'] []) att1
    Guard a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Guard" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SimpleMod" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SimpleMod a') }
    ShAAppl "TermMod" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TermMod a') }
    ShAAppl "ModOp" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ModOp a' b' c') }}}
    ShAAppl "TransClos" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TransClos a') }
    ShAAppl "Guard" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Guard a') }
    u -> fromShATermError "MODALITY" u

instance ShATermConvertible EM_SIG_ITEM where
  toShATermAux att0 xv = case xv of
    Rigid_op_items a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Rigid_op_items" [a', b', c'] []) att3
    Rigid_pred_items a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Rigid_pred_items" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Rigid_op_items" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Rigid_op_items a' b' c') }}}
    ShAAppl "Rigid_pred_items" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Rigid_pred_items a' b' c') }}}
    u -> fromShATermError "EM_SIG_ITEM" u

instance ShATermConvertible EM_FORMULA where
  toShATermAux att0 xv = case xv of
    BoxOrDiamond a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "BoxOrDiamond" [a', b', c', d', e',
                                                 f'] []) att6
    Hybrid a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Hybrid" [a', b', c', d'] []) att4
    UntilSince a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "UntilSince" [a', b', c', d'] []) att4
    PathQuantification a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "PathQuantification" [a', b',
                                                       c'] []) att3
    NextY a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "NextY" [a', b', c'] []) att3
    StateQuantification a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "StateQuantification" [a', b', c',
                                                        d'] []) att4
    FixedPoint a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "FixedPoint" [a', b', c', d'] []) att4
    ModForm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ModForm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "BoxOrDiamond" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, BoxOrDiamond a' b' c' d' e' f') }}}}}}
    ShAAppl "Hybrid" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Hybrid a' b' c' d') }}}}
    ShAAppl "UntilSince" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, UntilSince a' b' c' d') }}}}
    ShAAppl "PathQuantification" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, PathQuantification a' b' c') }}}
    ShAAppl "NextY" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, NextY a' b' c') }}}
    ShAAppl "StateQuantification" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, StateQuantification a' b' c' d') }}}}
    ShAAppl "FixedPoint" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, FixedPoint a' b' c' d') }}}}
    ShAAppl "ModForm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ModForm a') }
    u -> fromShATermError "EM_FORMULA" u

instance ShATermConvertible EModalSign where
  toShATermAux att0 xv = case xv of
    EModalSign a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "EModalSign" [a', b', c', d', e',
                                               f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EModalSign" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, EModalSign a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "EModalSign" u

_tcEModalSignTc :: TyCon
_tcEModalSignTc = mkTyCon "ExtModal.ExtModalSign.EModalSign"
instance Typeable EModalSign where
    typeOf _ = mkTyConApp _tcEModalSignTc []

_tcMorphExtensionTc :: TyCon
_tcMorphExtensionTc = mkTyCon "ExtModal.MorphismExtension.MorphExtension"
instance Typeable MorphExtension where
    typeOf _ = mkTyConApp _tcMorphExtensionTc []

instance ShATermConvertible MorphExtension where
  toShATermAux att0 xv = case xv of
    MorphExtension a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MorphExtension" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MorphExtension" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MorphExtension a' b') }}
    u -> fromShATermError "MorphExtension" u

_tcFrequencyTc :: TyCon
_tcFrequencyTc = mkTyCon "ExtModal.Sublogic.Frequency"
instance Typeable Frequency where
    typeOf _ = mkTyConApp _tcFrequencyTc []

_tcSublogicTc :: TyCon
_tcSublogicTc = mkTyCon "ExtModal.Sublogic.Sublogic"
instance Typeable Sublogic where
    typeOf _ = mkTyConApp _tcSublogicTc []

instance ShATermConvertible Frequency where
  toShATermAux att0 xv = case xv of
    None -> return $ addATerm (ShAAppl "None" [] []) att0
    One -> return $ addATerm (ShAAppl "One" [] []) att0
    Many -> return $ addATerm (ShAAppl "Many" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "None" [] _ -> (att0, None)
    ShAAppl "One" [] _ -> (att0, One)
    ShAAppl "Many" [] _ -> (att0, Many)
    u -> fromShATermError "Frequency" u

instance ShATermConvertible Sublogic where
  toShATermAux att0 xv = case xv of
    Sublogic a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "Sublogic" [a', b', c', d', e',
                                             f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sublogic" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, Sublogic a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "Sublogic" u
