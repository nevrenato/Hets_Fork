{-# OPTIONS -w -O0 #-}
{- |
Module      :  ATC/Prover.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Logic.Prover.ThmStatus'
'Logic.Prover.Theory'
'Logic.Prover.TacticScript'
'Logic.Prover.Reason'
'Logic.Prover.GoalStatus'
'Logic.Prover.ProofStatus'
'Logic.Prover.ProverKind'
'Logic.Prover.FreeDefMorphism'
'Logic.Prover.TheoryMorphism'
'Logic.Prover.CCStatus'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Logic/Prover.hs
-}

module ATC.Prover () where

import ATC.AS_Annotation
import ATC.OrderedMap
import ATerm.Lib
import Common.AS_Annotation as AS_Anno
import Common.Doc
import Common.DocUtils
import Common.ProofUtils
import Common.Result
import Control.Monad
import Data.List
import Data.Maybe (isJust)
import Data.Time (TimeOfDay, midnight)
import Data.Typeable
import Logic.Prover
import qualified Common.OrderedMap as OMap
import qualified Control.Concurrent as Concurrent
import qualified Data.Map as Map

{-! for Logic.Prover.ThmStatus derive : Typeable !-}
{-! for Logic.Prover.Theory derive : Typeable !-}
{-! for Logic.Prover.TacticScript derive : Typeable !-}
{-! for Logic.Prover.Reason derive : Typeable !-}
{-! for Logic.Prover.GoalStatus derive : Typeable !-}
{-! for Logic.Prover.ProofStatus derive : Typeable !-}
{-! for Logic.Prover.ProverKind derive : Typeable !-}
{-! for Logic.Prover.FreeDefMorphism derive : Typeable !-}
{-! for Logic.Prover.TheoryMorphism derive : Typeable !-}
{-! for Logic.Prover.CCStatus derive : Typeable !-}

{-! for Logic.Prover.ThmStatus derive : ShATermConvertible !-}
{-! for Logic.Prover.Theory derive : ShATermConvertible !-}
{-! for Logic.Prover.TacticScript derive : ShATermConvertible !-}
{-! for Logic.Prover.Reason derive : ShATermConvertible !-}
{-! for Logic.Prover.GoalStatus derive : ShATermConvertible !-}
{-! for Logic.Prover.ProofStatus derive : ShATermConvertible !-}
{-! for Logic.Prover.ProverKind derive : ShATermConvertible !-}
{-! for Logic.Prover.FreeDefMorphism derive : ShATermConvertible !-}
{-! for Logic.Prover.TheoryMorphism derive : ShATermConvertible !-}
{-! for Logic.Prover.CCStatus derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible proof_tree => ShATermConvertible (CCStatus proof_tree) where
  toShATermAux att0 xv = case xv of
    CCStatus a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "CCStatus" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CCStatus" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, CCStatus a' b' c') }}}
    u -> fromShATermError "CCStatus" u

instance (ShATermConvertible sign, ShATermConvertible sen,
          ShATermConvertible mor,
          ShATermConvertible proof_tree) => ShATermConvertible (TheoryMorphism sign sen mor proof_tree) where
  toShATermAux att0 xv = case xv of
    TheoryMorphism a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TheoryMorphism" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TheoryMorphism" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TheoryMorphism a' b' c') }}}
    u -> fromShATermError "TheoryMorphism" u

instance (ShATermConvertible sentence,
          ShATermConvertible morphism) => ShATermConvertible (FreeDefMorphism sentence morphism) where
  toShATermAux att0 xv = case xv of
    FreeDefMorphism a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "FreeDefMorphism" [a', b', c',
                                                    d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FreeDefMorphism" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, FreeDefMorphism a' b' c' d') }}}}
    u -> fromShATermError "FreeDefMorphism" u

instance ShATermConvertible ProverKind where
  toShATermAux att0 xv = case xv of
    ProveGUI -> return $ addATerm (ShAAppl "ProveGUI" [] []) att0
    ProveCMDLautomatic ->
      return $ addATerm (ShAAppl "ProveCMDLautomatic" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ProveGUI" [] _ -> (att0, ProveGUI)
    ShAAppl "ProveCMDLautomatic" [] _ -> (att0, ProveCMDLautomatic)
    u -> fromShATermError "ProverKind" u

instance ShATermConvertible proof_tree => ShATermConvertible (ProofStatus proof_tree) where
  toShATermAux att0 xv = case xv of
    ProofStatus a b c d e f g -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      return $ addATerm (ShAAppl "ProofStatus" [a', b', c', d', e', f',
                                                g'] []) att7
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ProofStatus" [a, b, c, d, e, f, g] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      (att7, ProofStatus a' b' c' d' e' f' g') }}}}}}}
    u -> fromShATermError "ProofStatus" u

instance ShATermConvertible GoalStatus where
  toShATermAux att0 xv = case xv of
    Open a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Open" [a'] []) att1
    Disproved -> return $ addATerm (ShAAppl "Disproved" [] []) att0
    Proved a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Proved" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Open" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Open a') }
    ShAAppl "Disproved" [] _ -> (att0, Disproved)
    ShAAppl "Proved" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Proved a') }
    u -> fromShATermError "GoalStatus" u

instance ShATermConvertible Reason where
  toShATermAux att0 xv = case xv of
    Reason a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Reason" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Reason" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Reason a') }
    u -> fromShATermError "Reason" u

instance ShATermConvertible TacticScript where
  toShATermAux att0 xv = case xv of
    TacticScript a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TacticScript" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TacticScript" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TacticScript a') }
    u -> fromShATermError "TacticScript" u

instance (ShATermConvertible sign, ShATermConvertible sen,
          ShATermConvertible proof_tree) => ShATermConvertible (Theory sign sen proof_tree) where
  toShATermAux att0 xv = case xv of
    Theory a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Theory" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Theory" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Theory a' b') }}
    u -> fromShATermError "Theory" u

instance ShATermConvertible a => ShATermConvertible (ThmStatus a) where
  toShATermAux att0 xv = case xv of
    ThmStatus a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ThmStatus" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ThmStatus" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ThmStatus a') }
    u -> fromShATermError "ThmStatus" u

_tcCCStatusTc :: TyCon
_tcCCStatusTc = mkTyCon "Logic.Prover.CCStatus"
instance Typeable1 CCStatus where
    typeOf1 _ = mkTyConApp _tcCCStatusTc []

_tcTheoryMorphismTc :: TyCon
_tcTheoryMorphismTc = mkTyCon "Logic.Prover.TheoryMorphism"
instance Typeable4 TheoryMorphism where
    typeOf4 _ = mkTyConApp _tcTheoryMorphismTc []

_tcFreeDefMorphismTc :: TyCon
_tcFreeDefMorphismTc = mkTyCon "Logic.Prover.FreeDefMorphism"
instance Typeable2 FreeDefMorphism where
    typeOf2 _ = mkTyConApp _tcFreeDefMorphismTc []

_tcProverKindTc :: TyCon
_tcProverKindTc = mkTyCon "Logic.Prover.ProverKind"
instance Typeable ProverKind where
    typeOf _ = mkTyConApp _tcProverKindTc []

_tcProofStatusTc :: TyCon
_tcProofStatusTc = mkTyCon "Logic.Prover.ProofStatus"
instance Typeable1 ProofStatus where
    typeOf1 _ = mkTyConApp _tcProofStatusTc []

_tcGoalStatusTc :: TyCon
_tcGoalStatusTc = mkTyCon "Logic.Prover.GoalStatus"
instance Typeable GoalStatus where
    typeOf _ = mkTyConApp _tcGoalStatusTc []

_tcReasonTc :: TyCon
_tcReasonTc = mkTyCon "Logic.Prover.Reason"
instance Typeable Reason where
    typeOf _ = mkTyConApp _tcReasonTc []

_tcTacticScriptTc :: TyCon
_tcTacticScriptTc = mkTyCon "Logic.Prover.TacticScript"
instance Typeable TacticScript where
    typeOf _ = mkTyConApp _tcTacticScriptTc []

_tcTheoryTc :: TyCon
_tcTheoryTc = mkTyCon "Logic.Prover.Theory"
instance Typeable3 Theory where
    typeOf3 _ = mkTyConApp _tcTheoryTc []

_tcThmStatusTc :: TyCon
_tcThmStatusTc = mkTyCon "Logic.Prover.ThmStatus"
instance Typeable1 ThmStatus where
    typeOf1 _ = mkTyConApp _tcThmStatusTc []
