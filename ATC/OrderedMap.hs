{-# OPTIONS -w -O0 #-}
{- |
Module      :  ATC/OrderedMap.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Common.OrderedMap.ElemWOrd'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Common/OrderedMap.hs
-}

module ATC.OrderedMap () where

import ATerm.Lib
import Common.OrderedMap
import Data.Ord
import Data.Typeable
import Prelude hiding (lookup, map, filter, null)
import qualified Data.List as List
import qualified Data.Map as Map

{-! for Common.OrderedMap.ElemWOrd derive : Typeable !-}

{-! for Common.OrderedMap.ElemWOrd derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcElemWOrdTc :: TyCon
_tcElemWOrdTc = mkTyCon "Common.OrderedMap.ElemWOrd"
instance Typeable1 ElemWOrd where
    typeOf1 _ = mkTyConApp _tcElemWOrdTc []

instance ShATermConvertible a => ShATermConvertible (ElemWOrd a) where
  toShATermAux att0 xv = case xv of
    EWOrd a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "EWOrd" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EWOrd" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, EWOrd a' b') }}
    u -> fromShATermError "ElemWOrd" u
