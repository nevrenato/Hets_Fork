{-# OPTIONS -w -O0 #-}
{- |
Module      :  ATC/AS_Structured.der.hs
Description :  generated Typeable, ShATermLG instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermLG
  for the type(s):
'Syntax.AS_Structured.SPEC'
'Syntax.AS_Structured.RENAMING'
'Syntax.AS_Structured.RESTRICTION'
'Syntax.AS_Structured.G_mapping'
'Syntax.AS_Structured.G_hiding'
'Syntax.AS_Structured.FIT_ARG'
'Syntax.AS_Structured.Logic_code'
'Syntax.AS_Structured.Logic_name'
'Syntax.AS_Structured.CORRESPONDENCE'
'Syntax.AS_Structured.TERM_OR_ENTITY_REF'
'Syntax.AS_Structured.RELATION_REF'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Syntax/AS_Structured.der.hs
-}

module ATC.AS_Structured () where

import ATC.Grothendieck
import ATerm.Lib
import Common.AS_Annotation
import Common.IRI
import Common.Id
import Data.Typeable
import Logic.Grothendieck (G_basic_spec
    , G_symb_items_list
    , G_symb_map_items_list
    , LogicGraph
    , setCurLogic )
import Logic.Logic (AnyLogic)
import Syntax.AS_Structured

{-! for Syntax.AS_Structured.SPEC derive : Typeable !-}
{-! for Syntax.AS_Structured.RENAMING derive : Typeable !-}
{-! for Syntax.AS_Structured.RESTRICTION derive : Typeable !-}
{-! for Syntax.AS_Structured.G_mapping derive : Typeable !-}
{-! for Syntax.AS_Structured.G_hiding derive : Typeable !-}
{-! for Syntax.AS_Structured.FIT_ARG derive : Typeable !-}
{-! for Syntax.AS_Structured.Logic_code derive : Typeable !-}
{-! for Syntax.AS_Structured.Logic_name derive : Typeable !-}
{-! for Syntax.AS_Structured.CORRESPONDENCE derive : Typeable !-}
{-! for Syntax.AS_Structured.TERM_OR_ENTITY_REF derive : Typeable !-}
{-! for Syntax.AS_Structured.RELATION_REF derive : Typeable !-}

{-! for Syntax.AS_Structured.SPEC derive : ShATermLG !-}
{-! for Syntax.AS_Structured.RENAMING derive : ShATermLG !-}
{-! for Syntax.AS_Structured.RESTRICTION derive : ShATermLG !-}
{-! for Syntax.AS_Structured.G_mapping derive : ShATermLG !-}
{-! for Syntax.AS_Structured.G_hiding derive : ShATermLG !-}
{-! for Syntax.AS_Structured.FIT_ARG derive : ShATermLG !-}
{-! for Syntax.AS_Structured.Logic_code derive : ShATermLG !-}
{-! for Syntax.AS_Structured.Logic_name derive : ShATermLG !-}
{-! for Syntax.AS_Structured.CORRESPONDENCE derive : ShATermLG !-}
{-! for Syntax.AS_Structured.TERM_OR_ENTITY_REF derive : ShATermLG !-}
{-! for Syntax.AS_Structured.RELATION_REF derive : ShATermLG !-}

-- Generated by DrIFT, look but don't touch!

_tcSPECTc :: TyCon
_tcSPECTc = mkTyCon "Syntax.AS_Structured.SPEC"
instance Typeable SPEC where
    typeOf _ = mkTyConApp _tcSPECTc []

_tcRENAMINGTc :: TyCon
_tcRENAMINGTc = mkTyCon "Syntax.AS_Structured.RENAMING"
instance Typeable RENAMING where
    typeOf _ = mkTyConApp _tcRENAMINGTc []

_tcRESTRICTIONTc :: TyCon
_tcRESTRICTIONTc = mkTyCon "Syntax.AS_Structured.RESTRICTION"
instance Typeable RESTRICTION where
    typeOf _ = mkTyConApp _tcRESTRICTIONTc []

_tcG_mappingTc :: TyCon
_tcG_mappingTc = mkTyCon "Syntax.AS_Structured.G_mapping"
instance Typeable G_mapping where
    typeOf _ = mkTyConApp _tcG_mappingTc []

_tcG_hidingTc :: TyCon
_tcG_hidingTc = mkTyCon "Syntax.AS_Structured.G_hiding"
instance Typeable G_hiding where
    typeOf _ = mkTyConApp _tcG_hidingTc []

_tcFIT_ARGTc :: TyCon
_tcFIT_ARGTc = mkTyCon "Syntax.AS_Structured.FIT_ARG"
instance Typeable FIT_ARG where
    typeOf _ = mkTyConApp _tcFIT_ARGTc []

_tcLogic_codeTc :: TyCon
_tcLogic_codeTc = mkTyCon "Syntax.AS_Structured.Logic_code"
instance Typeable Logic_code where
    typeOf _ = mkTyConApp _tcLogic_codeTc []

_tcLogic_nameTc :: TyCon
_tcLogic_nameTc = mkTyCon "Syntax.AS_Structured.Logic_name"
instance Typeable Logic_name where
    typeOf _ = mkTyConApp _tcLogic_nameTc []

_tcCORRESPONDENCETc :: TyCon
_tcCORRESPONDENCETc = mkTyCon "Syntax.AS_Structured.CORRESPONDENCE"
instance Typeable CORRESPONDENCE where
    typeOf _ = mkTyConApp _tcCORRESPONDENCETc []

_tcTERM_OR_ENTITY_REFTc :: TyCon
_tcTERM_OR_ENTITY_REFTc = mkTyCon "Syntax.AS_Structured.TERM_OR_ENTITY_REF"
instance Typeable TERM_OR_ENTITY_REF where
    typeOf _ = mkTyConApp _tcTERM_OR_ENTITY_REFTc []

_tcRELATION_REFTc :: TyCon
_tcRELATION_REFTc = mkTyCon "Syntax.AS_Structured.RELATION_REF"
instance Typeable RELATION_REF where
    typeOf _ = mkTyConApp _tcRELATION_REFTc []

instance ShATermLG SPEC where
  toShATermLG att0 xv = case xv of
    Basic_spec a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Basic_spec" [a', b'] []) att2
    EmptySpec a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "EmptySpec" [a'] []) att1
    Translation a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Translation" [a', b'] []) att2
    Reduction a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Reduction" [a', b'] []) att2
    Union a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Union" [a', b'] []) att2
    Extension a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Extension" [a', b'] []) att2
    Free_spec a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Free_spec" [a', b'] []) att2
    Cofree_spec a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Cofree_spec" [a', b'] []) att2
    Local_spec a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Local_spec" [a', b', c'] []) att3
    Closed_spec a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Closed_spec" [a', b'] []) att2
    Group a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Group" [a', b'] []) att2
    Spec_inst a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Spec_inst" [a', b', c'] []) att3
    Qualified_spec a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Qualified_spec" [a', b', c'] []) att3
    Data a b c d e -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      (att5, e') <- toShATermLG' att4 e
      return $ addATerm (ShAAppl "Data" [a', b', c', d', e'] []) att5
    Combination a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Combination" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Basic_spec" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Basic_spec a' b') }}
    ShAAppl "EmptySpec" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, EmptySpec a') }
    ShAAppl "Translation" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Translation a' b') }}
    ShAAppl "Reduction" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Reduction a' b') }}
    ShAAppl "Union" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Union a' b') }}
    ShAAppl "Extension" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Extension a' b') }}
    ShAAppl "Free_spec" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Free_spec a' b') }}
    ShAAppl "Cofree_spec" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Cofree_spec a' b') }}
    ShAAppl "Local_spec" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Local_spec a' b' c') }}}
    ShAAppl "Closed_spec" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Closed_spec a' b') }}
    ShAAppl "Group" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Group a' b') }}
    ShAAppl "Spec_inst" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Spec_inst a' b' c') }}}
    ShAAppl "Qualified_spec" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Qualified_spec a' b' c') }}}
    ShAAppl "Data" [a, b, c, d, e] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      case fromShATermLG' lg e att4 of
      { (att5, e') ->
      (att5, Data a' b' c' d' e') }}}}}
    ShAAppl "Combination" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Combination a' b' c') }}}
    u -> fromShATermError "SPEC" u

instance ShATermLG RENAMING where
  toShATermLG att0 xv = case xv of
    Renaming a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Renaming" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Renaming" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Renaming a' b') }}
    u -> fromShATermError "RENAMING" u

instance ShATermLG RESTRICTION where
  toShATermLG att0 xv = case xv of
    Hidden a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Hidden" [a', b'] []) att2
    Revealed a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Revealed" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Hidden" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Hidden a' b') }}
    ShAAppl "Revealed" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Revealed a' b') }}
    u -> fromShATermError "RESTRICTION" u

instance ShATermLG G_mapping where
  toShATermLG att0 xv = case xv of
    G_symb_map a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "G_symb_map" [a'] []) att1
    G_logic_translation a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "G_logic_translation" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "G_symb_map" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, G_symb_map a') }
    ShAAppl "G_logic_translation" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, G_logic_translation a') }
    u -> fromShATermError "G_mapping" u

instance ShATermLG G_hiding where
  toShATermLG att0 xv = case xv of
    G_symb_list a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "G_symb_list" [a'] []) att1
    G_logic_projection a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "G_logic_projection" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "G_symb_list" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, G_symb_list a') }
    ShAAppl "G_logic_projection" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, G_logic_projection a') }
    u -> fromShATermError "G_hiding" u

instance ShATermLG FIT_ARG where
  toShATermLG att0 xv = case xv of
    Fit_spec a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Fit_spec" [a', b', c'] []) att3
    Fit_view a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Fit_view" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Fit_spec" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Fit_spec a' b' c') }}}
    ShAAppl "Fit_view" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Fit_view a' b' c') }}}
    u -> fromShATermError "FIT_ARG" u

instance ShATermLG Logic_code where
  toShATermLG att0 xv = case xv of
    Logic_code a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "Logic_code" [a', b', c', d'] []) att4
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Logic_code" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, Logic_code a' b' c' d') }}}}
    u -> fromShATermError "Logic_code" u

instance ShATermLG Logic_name where
  toShATermLG att0 xv = case xv of
    Logic_name a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Logic_name" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Logic_name" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Logic_name a' b' c') }}}
    u -> fromShATermError "Logic_name" u

instance ShATermLG CORRESPONDENCE where
  toShATermLG att0 xv = case xv of
    Correspondence_block a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Correspondence_block" [a', b',
                                                         c'] []) att3
    Single_correspondence a b c d e -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      (att5, e') <- toShATermLG' att4 e
      return $ addATerm (ShAAppl "Single_correspondence" [a', b', c', d',
                                                          e'] []) att5
    Default_correspondence ->
      return $ addATerm (ShAAppl "Default_correspondence" [] []) att0
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Correspondence_block" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Correspondence_block a' b' c') }}}
    ShAAppl "Single_correspondence" [a, b, c, d, e] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      case fromShATermLG' lg e att4 of
      { (att5, e') ->
      (att5, Single_correspondence a' b' c' d' e') }}}}}
    ShAAppl "Default_correspondence" [] _ -> (att0, Default_correspondence)
    u -> fromShATermError "CORRESPONDENCE" u

instance ShATermLG TERM_OR_ENTITY_REF where
  toShATermLG att0 xv = case xv of
    Term a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Term" [a', b'] []) att2
    Entity_ref a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "Entity_ref" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Term" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Term a' b') }}
    ShAAppl "Entity_ref" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, Entity_ref a') }
    u -> fromShATermError "TERM_OR_ENTITY_REF" u

instance ShATermLG RELATION_REF where
  toShATermLG att0 xv = case xv of
    Subsumes -> return $ addATerm (ShAAppl "Subsumes" [] []) att0
    IsSubsumed -> return $ addATerm (ShAAppl "IsSubsumed" [] []) att0
    Equivalent -> return $ addATerm (ShAAppl "Equivalent" [] []) att0
    Incompatible -> return $ addATerm (ShAAppl "Incompatible" [] []) att0
    HasInstance -> return $ addATerm (ShAAppl "HasInstance" [] []) att0
    InstanceOf -> return $ addATerm (ShAAppl "InstanceOf" [] []) att0
    DefaultRelation -> return $ addATerm (ShAAppl "DefaultRelation" [] []) att0
    Iri a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "Iri" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Subsumes" [] _ -> (att0, Subsumes)
    ShAAppl "IsSubsumed" [] _ -> (att0, IsSubsumed)
    ShAAppl "Equivalent" [] _ -> (att0, Equivalent)
    ShAAppl "Incompatible" [] _ -> (att0, Incompatible)
    ShAAppl "HasInstance" [] _ -> (att0, HasInstance)
    ShAAppl "InstanceOf" [] _ -> (att0, InstanceOf)
    ShAAppl "DefaultRelation" [] _ -> (att0, DefaultRelation)
    ShAAppl "Iri" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, Iri a') }
    u -> fromShATermError "RELATION_REF" u
