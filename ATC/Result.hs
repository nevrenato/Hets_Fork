{-# OPTIONS -w -O0 #-}
{- |
Module      :  ATC/Result.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Common.Result.DiagKind'
'Common.Result.Diagnosis'
'Common.Result.Result'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Common/Result.hs
-}

module ATC.Result () where

import ATC.Id
import ATerm.Lib
import Common.Doc
import Common.DocUtils
import Common.GlobalAnnotations
import Common.Id
import Common.Lexer
import Common.Result
import Control.Monad
import Control.Monad.Identity
import Data.List
import Data.Typeable
import Text.ParserCombinators.Parsec (parse)
import Text.ParserCombinators.Parsec.Char (char)
import Text.ParserCombinators.Parsec.Error

{-! for Common.Result.DiagKind derive : Typeable !-}
{-! for Common.Result.Diagnosis derive : Typeable !-}
{-! for Common.Result.Result derive : Typeable !-}

{-! for Common.Result.DiagKind derive : ShATermConvertible !-}
{-! for Common.Result.Diagnosis derive : ShATermConvertible !-}
{-! for Common.Result.Result derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcDiagKindTc :: TyCon
_tcDiagKindTc = mkTyCon "Common.Result.DiagKind"
instance Typeable DiagKind where
    typeOf _ = mkTyConApp _tcDiagKindTc []

_tcDiagnosisTc :: TyCon
_tcDiagnosisTc = mkTyCon "Common.Result.Diagnosis"
instance Typeable Diagnosis where
    typeOf _ = mkTyConApp _tcDiagnosisTc []

_tcResultTc :: TyCon
_tcResultTc = mkTyCon "Common.Result.Result"
instance Typeable1 Result where
    typeOf1 _ = mkTyConApp _tcResultTc []

instance ShATermConvertible DiagKind where
  toShATermAux att0 xv = case xv of
    Error -> return $ addATerm (ShAAppl "Error" [] []) att0
    Warning -> return $ addATerm (ShAAppl "Warning" [] []) att0
    Hint -> return $ addATerm (ShAAppl "Hint" [] []) att0
    Debug -> return $ addATerm (ShAAppl "Debug" [] []) att0
    MessageW -> return $ addATerm (ShAAppl "MessageW" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Error" [] _ -> (att0, Error)
    ShAAppl "Warning" [] _ -> (att0, Warning)
    ShAAppl "Hint" [] _ -> (att0, Hint)
    ShAAppl "Debug" [] _ -> (att0, Debug)
    ShAAppl "MessageW" [] _ -> (att0, MessageW)
    u -> fromShATermError "DiagKind" u

instance ShATermConvertible Diagnosis where
  toShATermAux att0 xv = case xv of
    Diag a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Diag" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Diag" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Diag a' b' c') }}}
    u -> fromShATermError "Diagnosis" u

instance ShATermConvertible a => ShATermConvertible (Result a) where
  toShATermAux att0 xv = case xv of
    Result a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Result" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Result" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Result a' b') }}
    u -> fromShATermError "Result" u
