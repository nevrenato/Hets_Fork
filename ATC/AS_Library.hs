{-# OPTIONS -w -O0 #-}
{- |
Module      :  ATC/AS_Library.der.hs
Description :  generated Typeable, ShATermLG instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermLG
  for the type(s):
'Syntax.AS_Library.LIB_DEFN'
'Syntax.AS_Library.LIB_ITEM'
'Syntax.AS_Library.DownloadItems'
'Syntax.AS_Library.GENERICITY'
'Syntax.AS_Library.PARAMS'
'Syntax.AS_Library.IMPORTED'
'Syntax.AS_Library.VIEW_TYPE'
'Syntax.AS_Library.ALIGN_TYPE'
'Syntax.AS_Library.MODULE_TYPE'
'Syntax.AS_Library.ALIGN_ARITIES'
'Syntax.AS_Library.ALIGN_ARITY'
'Syntax.AS_Library.ItemNameMap'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Syntax/AS_Library.der.hs
-}

module ATC.AS_Library () where

import ATC.AS_Architecture
import ATC.Grothendieck
import ATC.LibName
import ATerm.Lib
import Common.AS_Annotation
import Common.IRI
import Common.Id
import Common.LibName
import Data.Typeable
import Framework.AS
import Framework.ATC_Framework ()
import Logic.Grothendieck (G_basic_spec)
import Syntax.AS_Architecture
import Syntax.AS_Library
import Syntax.AS_Structured

{-! for Syntax.AS_Library.LIB_DEFN derive : Typeable !-}
{-! for Syntax.AS_Library.LIB_ITEM derive : Typeable !-}
{-! for Syntax.AS_Library.DownloadItems derive : Typeable !-}
{-! for Syntax.AS_Library.GENERICITY derive : Typeable !-}
{-! for Syntax.AS_Library.PARAMS derive : Typeable !-}
{-! for Syntax.AS_Library.IMPORTED derive : Typeable !-}
{-! for Syntax.AS_Library.VIEW_TYPE derive : Typeable !-}
{-! for Syntax.AS_Library.ALIGN_TYPE derive : Typeable !-}
{-! for Syntax.AS_Library.MODULE_TYPE derive : Typeable !-}
{-! for Syntax.AS_Library.ALIGN_ARITIES derive : Typeable !-}
{-! for Syntax.AS_Library.ALIGN_ARITY derive : Typeable !-}
{-! for Syntax.AS_Library.ItemNameMap derive : Typeable !-}

{-! for Syntax.AS_Library.LIB_DEFN derive : ShATermLG !-}
{-! for Syntax.AS_Library.LIB_ITEM derive : ShATermLG !-}
{-! for Syntax.AS_Library.DownloadItems derive : ShATermLG !-}
{-! for Syntax.AS_Library.GENERICITY derive : ShATermLG !-}
{-! for Syntax.AS_Library.PARAMS derive : ShATermLG !-}
{-! for Syntax.AS_Library.IMPORTED derive : ShATermLG !-}
{-! for Syntax.AS_Library.VIEW_TYPE derive : ShATermLG !-}
{-! for Syntax.AS_Library.ALIGN_TYPE derive : ShATermLG !-}
{-! for Syntax.AS_Library.MODULE_TYPE derive : ShATermLG !-}
{-! for Syntax.AS_Library.ALIGN_ARITIES derive : ShATermLG !-}
{-! for Syntax.AS_Library.ALIGN_ARITY derive : ShATermLG !-}
{-! for Syntax.AS_Library.ItemNameMap derive : ShATermLG !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermLG ItemNameMap where
  toShATermLG att0 xv = case xv of
    ItemNameMap a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "ItemNameMap" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "ItemNameMap" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, ItemNameMap a' b') }}
    u -> fromShATermError "ItemNameMap" u

instance ShATermLG ALIGN_ARITY where
  toShATermLG att0 xv = case xv of
    AA_InjectiveAndTotal ->
      return $ addATerm (ShAAppl "AA_InjectiveAndTotal" [] []) att0
    AA_Injective -> return $ addATerm (ShAAppl "AA_Injective" [] []) att0
    AA_Total -> return $ addATerm (ShAAppl "AA_Total" [] []) att0
    AA_NeitherInjectiveNorTotal ->
      return $ addATerm (ShAAppl "AA_NeitherInjectiveNorTotal" [] []) att0
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "AA_InjectiveAndTotal" [] _ -> (att0, AA_InjectiveAndTotal)
    ShAAppl "AA_Injective" [] _ -> (att0, AA_Injective)
    ShAAppl "AA_Total" [] _ -> (att0, AA_Total)
    ShAAppl "AA_NeitherInjectiveNorTotal" [] _ -> (att0, AA_NeitherInjectiveNorTotal)
    u -> fromShATermError "ALIGN_ARITY" u

instance ShATermLG ALIGN_ARITIES where
  toShATermLG att0 xv = case xv of
    Align_arities a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Align_arities" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Align_arities" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Align_arities a' b') }}
    u -> fromShATermError "ALIGN_ARITIES" u

instance ShATermLG MODULE_TYPE where
  toShATermLG att0 xv = case xv of
    Module_type a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Module_type" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Module_type" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Module_type a' b' c') }}}
    u -> fromShATermError "MODULE_TYPE" u

instance ShATermLG ALIGN_TYPE where
  toShATermLG att0 xv = case xv of
    Align_type a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Align_type" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Align_type" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Align_type a' b' c') }}}
    u -> fromShATermError "ALIGN_TYPE" u

instance ShATermLG VIEW_TYPE where
  toShATermLG att0 xv = case xv of
    View_type a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "View_type" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "View_type" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, View_type a' b' c') }}}
    u -> fromShATermError "VIEW_TYPE" u

instance ShATermLG IMPORTED where
  toShATermLG att0 xv = case xv of
    Imported a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "Imported" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Imported" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, Imported a') }
    u -> fromShATermError "IMPORTED" u

instance ShATermLG PARAMS where
  toShATermLG att0 xv = case xv of
    Params a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "Params" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Params" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, Params a') }
    u -> fromShATermError "PARAMS" u

instance ShATermLG GENERICITY where
  toShATermLG att0 xv = case xv of
    Genericity a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Genericity" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Genericity" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Genericity a' b' c') }}}
    u -> fromShATermError "GENERICITY" u

instance ShATermLG DownloadItems where
  toShATermLG att0 xv = case xv of
    ItemMaps a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "ItemMaps" [a'] []) att1
    UniqueItem a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "UniqueItem" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "ItemMaps" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, ItemMaps a') }
    ShAAppl "UniqueItem" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, UniqueItem a') }
    u -> fromShATermError "DownloadItems" u

instance ShATermLG LIB_ITEM where
  toShATermLG att0 xv = case xv of
    Spec_defn a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "Spec_defn" [a', b', c', d'] []) att4
    View_defn a b c d e -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      (att5, e') <- toShATermLG' att4 e
      return $ addATerm (ShAAppl "View_defn" [a', b', c', d',
                                              e'] []) att5
    Align_defn a b c d e -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      (att5, e') <- toShATermLG' att4 e
      return $ addATerm (ShAAppl "Align_defn" [a', b', c', d',
                                               e'] []) att5
    Module_defn a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "Module_defn" [a', b', c', d'] []) att4
    Arch_spec_defn a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Arch_spec_defn" [a', b', c'] []) att3
    Unit_spec_defn a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Unit_spec_defn" [a', b', c'] []) att3
    Ref_spec_defn a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Ref_spec_defn" [a', b', c'] []) att3
    Download_items a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Download_items" [a', b', c'] []) att3
    Logic_decl a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "Logic_decl" [a', b', c'] []) att3
    Newlogic_defn a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Newlogic_defn" [a', b'] []) att2
    Newcomorphism_defn a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Newcomorphism_defn" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Spec_defn" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, Spec_defn a' b' c' d') }}}}
    ShAAppl "View_defn" [a, b, c, d, e] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      case fromShATermLG' lg e att4 of
      { (att5, e') ->
      (att5, View_defn a' b' c' d' e') }}}}}
    ShAAppl "Align_defn" [a, b, c, d, e] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      case fromShATermLG' lg e att4 of
      { (att5, e') ->
      (att5, Align_defn a' b' c' d' e') }}}}}
    ShAAppl "Module_defn" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, Module_defn a' b' c' d') }}}}
    ShAAppl "Arch_spec_defn" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Arch_spec_defn a' b' c') }}}
    ShAAppl "Unit_spec_defn" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Unit_spec_defn a' b' c') }}}
    ShAAppl "Ref_spec_defn" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Ref_spec_defn a' b' c') }}}
    ShAAppl "Download_items" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Download_items a' b' c') }}}
    ShAAppl "Logic_decl" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, Logic_decl a' b' c') }}}
    ShAAppl "Newlogic_defn" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Newlogic_defn a' b') }}
    ShAAppl "Newcomorphism_defn" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Newcomorphism_defn a' b') }}
    u -> fromShATermError "LIB_ITEM" u

instance ShATermLG LIB_DEFN where
  toShATermLG att0 xv = case xv of
    Lib_defn a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "Lib_defn" [a', b', c', d'] []) att4
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Lib_defn" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, Lib_defn a' b' c' d') }}}}
    u -> fromShATermError "LIB_DEFN" u

_tcItemNameMapTc :: TyCon
_tcItemNameMapTc = mkTyCon "Syntax.AS_Library.ItemNameMap"
instance Typeable ItemNameMap where
    typeOf _ = mkTyConApp _tcItemNameMapTc []

_tcALIGN_ARITYTc :: TyCon
_tcALIGN_ARITYTc = mkTyCon "Syntax.AS_Library.ALIGN_ARITY"
instance Typeable ALIGN_ARITY where
    typeOf _ = mkTyConApp _tcALIGN_ARITYTc []

_tcALIGN_ARITIESTc :: TyCon
_tcALIGN_ARITIESTc = mkTyCon "Syntax.AS_Library.ALIGN_ARITIES"
instance Typeable ALIGN_ARITIES where
    typeOf _ = mkTyConApp _tcALIGN_ARITIESTc []

_tcMODULE_TYPETc :: TyCon
_tcMODULE_TYPETc = mkTyCon "Syntax.AS_Library.MODULE_TYPE"
instance Typeable MODULE_TYPE where
    typeOf _ = mkTyConApp _tcMODULE_TYPETc []

_tcALIGN_TYPETc :: TyCon
_tcALIGN_TYPETc = mkTyCon "Syntax.AS_Library.ALIGN_TYPE"
instance Typeable ALIGN_TYPE where
    typeOf _ = mkTyConApp _tcALIGN_TYPETc []

_tcVIEW_TYPETc :: TyCon
_tcVIEW_TYPETc = mkTyCon "Syntax.AS_Library.VIEW_TYPE"
instance Typeable VIEW_TYPE where
    typeOf _ = mkTyConApp _tcVIEW_TYPETc []

_tcIMPORTEDTc :: TyCon
_tcIMPORTEDTc = mkTyCon "Syntax.AS_Library.IMPORTED"
instance Typeable IMPORTED where
    typeOf _ = mkTyConApp _tcIMPORTEDTc []

_tcPARAMSTc :: TyCon
_tcPARAMSTc = mkTyCon "Syntax.AS_Library.PARAMS"
instance Typeable PARAMS where
    typeOf _ = mkTyConApp _tcPARAMSTc []

_tcGENERICITYTc :: TyCon
_tcGENERICITYTc = mkTyCon "Syntax.AS_Library.GENERICITY"
instance Typeable GENERICITY where
    typeOf _ = mkTyConApp _tcGENERICITYTc []

_tcDownloadItemsTc :: TyCon
_tcDownloadItemsTc = mkTyCon "Syntax.AS_Library.DownloadItems"
instance Typeable DownloadItems where
    typeOf _ = mkTyConApp _tcDownloadItemsTc []

_tcLIB_ITEMTc :: TyCon
_tcLIB_ITEMTc = mkTyCon "Syntax.AS_Library.LIB_ITEM"
instance Typeable LIB_ITEM where
    typeOf _ = mkTyConApp _tcLIB_ITEMTc []

_tcLIB_DEFNTc :: TyCon
_tcLIB_DEFNTc = mkTyCon "Syntax.AS_Library.LIB_DEFN"
instance Typeable LIB_DEFN where
    typeOf _ = mkTyConApp _tcLIB_DEFNTc []
