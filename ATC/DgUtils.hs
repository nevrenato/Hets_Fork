{-# OPTIONS -w -O0 #-}
{- |
Module      :  ATC/DgUtils.der.hs
Description :  generated Typeable, ShATermLG instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermLG
  for the type(s):
'Static.DgUtils.XPathPart'
'Static.DgUtils.NodeName'
'Static.DgUtils.DGNodeType'
'Static.DgUtils.NodeMod'
'Static.DgUtils.EdgeId'
'Static.DgUtils.ProofBasis'
'Static.DgUtils.DGRule'
'Static.DgUtils.ThmLinkStatus'
'Static.DgUtils.Scope'
'Static.DgUtils.LinkKind'
'Static.DgUtils.FreeOrCofree'
'Static.DgUtils.ConsStatus'
'Static.DgUtils.DGEdgeType'
'Static.DgUtils.DGEdgeTypeModInc'
'Static.DgUtils.ThmTypes'
'Static.DgUtils.RTPointer'
'Static.DgUtils.RTLeaves'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Static/DgUtils.hs
-}

module ATC.DgUtils () where

import ATC.Consistency
import ATC.Grothendieck
import ATC.LibName
import ATerm.Lib
import Common.Consistency
import Common.IRI (IRI, nullIRI, iriToStringShortUnsecure, parseCurie)
import Common.LibName
import Common.Utils (numberSuffix, splitByList, splitOn, readMaybe)
import Data.Graph.Inductive.Graph (Node)
import Data.List
import Data.Maybe
import Data.Typeable
import Static.DgUtils
import qualified Common.Lib.Rel as Rel
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for Static.DgUtils.XPathPart derive : Typeable !-}
{-! for Static.DgUtils.NodeName derive : Typeable !-}
{-! for Static.DgUtils.DGNodeType derive : Typeable !-}
{-! for Static.DgUtils.NodeMod derive : Typeable !-}
{-! for Static.DgUtils.EdgeId derive : Typeable !-}
{-! for Static.DgUtils.ProofBasis derive : Typeable !-}
{-! for Static.DgUtils.DGRule derive : Typeable !-}
{-! for Static.DgUtils.ThmLinkStatus derive : Typeable !-}
{-! for Static.DgUtils.Scope derive : Typeable !-}
{-! for Static.DgUtils.LinkKind derive : Typeable !-}
{-! for Static.DgUtils.FreeOrCofree derive : Typeable !-}
{-! for Static.DgUtils.ConsStatus derive : Typeable !-}
{-! for Static.DgUtils.DGEdgeType derive : Typeable !-}
{-! for Static.DgUtils.DGEdgeTypeModInc derive : Typeable !-}
{-! for Static.DgUtils.ThmTypes derive : Typeable !-}
{-! for Static.DgUtils.RTPointer derive : Typeable !-}
{-! for Static.DgUtils.RTLeaves derive : Typeable !-}

{-! for Static.DgUtils.XPathPart derive : ShATermLG !-}
{-! for Static.DgUtils.NodeName derive : ShATermLG !-}
{-! for Static.DgUtils.DGNodeType derive : ShATermLG !-}
{-! for Static.DgUtils.NodeMod derive : ShATermLG !-}
{-! for Static.DgUtils.EdgeId derive : ShATermLG !-}
{-! for Static.DgUtils.ProofBasis derive : ShATermLG !-}
{-! for Static.DgUtils.DGRule derive : ShATermLG !-}
{-! for Static.DgUtils.ThmLinkStatus derive : ShATermLG !-}
{-! for Static.DgUtils.Scope derive : ShATermLG !-}
{-! for Static.DgUtils.LinkKind derive : ShATermLG !-}
{-! for Static.DgUtils.FreeOrCofree derive : ShATermLG !-}
{-! for Static.DgUtils.ConsStatus derive : ShATermLG !-}
{-! for Static.DgUtils.DGEdgeType derive : ShATermLG !-}
{-! for Static.DgUtils.DGEdgeTypeModInc derive : ShATermLG !-}
{-! for Static.DgUtils.ThmTypes derive : ShATermLG !-}
{-! for Static.DgUtils.RTPointer derive : ShATermLG !-}
{-! for Static.DgUtils.RTLeaves derive : ShATermLG !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermLG RTLeaves where
  toShATermLG att0 xv = case xv of
    RTLeaf a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "RTLeaf" [a'] []) att1
    RTLeaves a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "RTLeaves" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "RTLeaf" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, RTLeaf a') }
    ShAAppl "RTLeaves" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, RTLeaves a') }
    u -> fromShATermError "RTLeaves" u

instance ShATermLG RTPointer where
  toShATermLG att0 xv = case xv of
    RTNone -> return $ addATerm (ShAAppl "RTNone" [] []) att0
    NPUnit a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "NPUnit" [a'] []) att1
    NPBranch a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "NPBranch" [a', b'] []) att2
    NPRef a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "NPRef" [a', b'] []) att2
    NPComp a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "NPComp" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "RTNone" [] _ -> (att0, RTNone)
    ShAAppl "NPUnit" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, NPUnit a') }
    ShAAppl "NPBranch" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, NPBranch a' b') }}
    ShAAppl "NPRef" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, NPRef a' b') }}
    ShAAppl "NPComp" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, NPComp a') }
    u -> fromShATermError "RTPointer" u

instance ShATermLG ThmTypes where
  toShATermLG att0 xv = case xv of
    HidingThm -> return $ addATerm (ShAAppl "HidingThm" [] []) att0
    FreeOrCofreeThm a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "FreeOrCofreeThm" [a'] []) att1
    GlobalOrLocalThm a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "GlobalOrLocalThm" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "HidingThm" [] _ -> (att0, HidingThm)
    ShAAppl "FreeOrCofreeThm" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, FreeOrCofreeThm a') }
    ShAAppl "GlobalOrLocalThm" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, GlobalOrLocalThm a' b') }}
    u -> fromShATermError "ThmTypes" u

instance ShATermLG DGEdgeTypeModInc where
  toShATermLG att0 xv = case xv of
    GlobalDef -> return $ addATerm (ShAAppl "GlobalDef" [] []) att0
    HetDef -> return $ addATerm (ShAAppl "HetDef" [] []) att0
    HidingDef -> return $ addATerm (ShAAppl "HidingDef" [] []) att0
    LocalDef -> return $ addATerm (ShAAppl "LocalDef" [] []) att0
    FreeOrCofreeDef a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "FreeOrCofreeDef" [a'] []) att1
    ThmType a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "ThmType" [a', b', c', d'] []) att4
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "GlobalDef" [] _ -> (att0, GlobalDef)
    ShAAppl "HetDef" [] _ -> (att0, HetDef)
    ShAAppl "HidingDef" [] _ -> (att0, HidingDef)
    ShAAppl "LocalDef" [] _ -> (att0, LocalDef)
    ShAAppl "FreeOrCofreeDef" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, FreeOrCofreeDef a') }
    ShAAppl "ThmType" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, ThmType a' b' c' d') }}}}
    u -> fromShATermError "DGEdgeTypeModInc" u

instance ShATermLG DGEdgeType where
  toShATermLG att0 xv = case xv of
    DGEdgeType a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "DGEdgeType" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "DGEdgeType" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, DGEdgeType a' b') }}
    u -> fromShATermError "DGEdgeType" u

instance ShATermLG ConsStatus where
  toShATermLG att0 xv = case xv of
    ConsStatus a b c -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      return $ addATerm (ShAAppl "ConsStatus" [a', b', c'] []) att3
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "ConsStatus" [a, b, c] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      (att3, ConsStatus a' b' c') }}}
    u -> fromShATermError "ConsStatus" u

instance ShATermLG FreeOrCofree where
  toShATermLG att0 xv = case xv of
    Free -> return $ addATerm (ShAAppl "Free" [] []) att0
    Cofree -> return $ addATerm (ShAAppl "Cofree" [] []) att0
    NPFree -> return $ addATerm (ShAAppl "NPFree" [] []) att0
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Free" [] _ -> (att0, Free)
    ShAAppl "Cofree" [] _ -> (att0, Cofree)
    ShAAppl "NPFree" [] _ -> (att0, NPFree)
    u -> fromShATermError "FreeOrCofree" u

instance ShATermLG LinkKind where
  toShATermLG att0 xv = case xv of
    DefLink -> return $ addATerm (ShAAppl "DefLink" [] []) att0
    ThmLink a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "ThmLink" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "DefLink" [] _ -> (att0, DefLink)
    ShAAppl "ThmLink" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, ThmLink a') }
    u -> fromShATermError "LinkKind" u

instance ShATermLG Scope where
  toShATermLG att0 xv = case xv of
    Local -> return $ addATerm (ShAAppl "Local" [] []) att0
    Global -> return $ addATerm (ShAAppl "Global" [] []) att0
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "Local" [] _ -> (att0, Local)
    ShAAppl "Global" [] _ -> (att0, Global)
    u -> fromShATermError "Scope" u

instance ShATermLG ThmLinkStatus where
  toShATermLG att0 xv = case xv of
    LeftOpen -> return $ addATerm (ShAAppl "LeftOpen" [] []) att0
    Proven a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "Proven" [a', b'] []) att2
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "LeftOpen" [] _ -> (att0, LeftOpen)
    ShAAppl "Proven" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, Proven a' b') }}
    u -> fromShATermError "ThmLinkStatus" u

instance ShATermLG DGRule where
  toShATermLG att0 xv = case xv of
    DGRule a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "DGRule" [a'] []) att1
    DGRuleWithEdge a b -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      return $ addATerm (ShAAppl "DGRuleWithEdge" [a', b'] []) att2
    DGRuleLocalInference a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "DGRuleLocalInference" [a'] []) att1
    Composition a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "Composition" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "DGRule" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, DGRule a') }
    ShAAppl "DGRuleWithEdge" [a, b] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      (att2, DGRuleWithEdge a' b') }}
    ShAAppl "DGRuleLocalInference" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, DGRuleLocalInference a') }
    ShAAppl "Composition" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, Composition a') }
    u -> fromShATermError "DGRule" u

instance ShATermLG ProofBasis where
  toShATermLG att0 xv = case xv of
    ProofBasis a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "ProofBasis" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "ProofBasis" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, ProofBasis a') }
    u -> fromShATermError "ProofBasis" u

instance ShATermLG EdgeId where
  toShATermLG att0 xv = case xv of
    EdgeId a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "EdgeId" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "EdgeId" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, EdgeId a') }
    u -> fromShATermError "EdgeId" u

instance ShATermLG NodeMod where
  toShATermLG att0 xv = case xv of
    NodeMod a b c d e -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      (att5, e') <- toShATermLG' att4 e
      return $ addATerm (ShAAppl "NodeMod" [a', b', c', d', e'] []) att5
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "NodeMod" [a, b, c, d, e] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      case fromShATermLG' lg e att4 of
      { (att5, e') ->
      (att5, NodeMod a' b' c' d' e') }}}}}
    u -> fromShATermError "NodeMod" u

instance ShATermLG DGNodeType where
  toShATermLG att0 xv = case xv of
    DGNodeType a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "DGNodeType" [a', b', c', d'] []) att4
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "DGNodeType" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, DGNodeType a' b' c' d') }}}}
    u -> fromShATermError "DGNodeType" u

instance ShATermLG NodeName where
  toShATermLG att0 xv = case xv of
    NodeName a b c d -> do
      (att1, a') <- toShATermLG' att0 a
      (att2, b') <- toShATermLG' att1 b
      (att3, c') <- toShATermLG' att2 c
      (att4, d') <- toShATermLG' att3 d
      return $ addATerm (ShAAppl "NodeName" [a', b', c', d'] []) att4
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "NodeName" [a, b, c, d] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      case fromShATermLG' lg b att1 of
      { (att2, b') ->
      case fromShATermLG' lg c att2 of
      { (att3, c') ->
      case fromShATermLG' lg d att3 of
      { (att4, d') ->
      (att4, NodeName a' b' c' d') }}}}
    u -> fromShATermError "NodeName" u

instance ShATermLG XPathPart where
  toShATermLG att0 xv = case xv of
    ElemName a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "ElemName" [a'] []) att1
    ChildIndex a -> do
      (att1, a') <- toShATermLG' att0 a
      return $ addATerm (ShAAppl "ChildIndex" [a'] []) att1
  fromShATermLG lg ix att0 = case getShATerm ix att0 of
    ShAAppl "ElemName" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, ElemName a') }
    ShAAppl "ChildIndex" [a] _ ->
      case fromShATermLG' lg a att0 of
      { (att1, a') ->
      (att1, ChildIndex a') }
    u -> fromShATermError "XPathPart" u

_tcRTLeavesTc :: TyCon
_tcRTLeavesTc = mkTyCon "Static.DgUtils.RTLeaves"
instance Typeable RTLeaves where
    typeOf _ = mkTyConApp _tcRTLeavesTc []

_tcRTPointerTc :: TyCon
_tcRTPointerTc = mkTyCon "Static.DgUtils.RTPointer"
instance Typeable RTPointer where
    typeOf _ = mkTyConApp _tcRTPointerTc []

_tcThmTypesTc :: TyCon
_tcThmTypesTc = mkTyCon "Static.DgUtils.ThmTypes"
instance Typeable ThmTypes where
    typeOf _ = mkTyConApp _tcThmTypesTc []

_tcDGEdgeTypeModIncTc :: TyCon
_tcDGEdgeTypeModIncTc = mkTyCon "Static.DgUtils.DGEdgeTypeModInc"
instance Typeable DGEdgeTypeModInc where
    typeOf _ = mkTyConApp _tcDGEdgeTypeModIncTc []

_tcDGEdgeTypeTc :: TyCon
_tcDGEdgeTypeTc = mkTyCon "Static.DgUtils.DGEdgeType"
instance Typeable DGEdgeType where
    typeOf _ = mkTyConApp _tcDGEdgeTypeTc []

_tcConsStatusTc :: TyCon
_tcConsStatusTc = mkTyCon "Static.DgUtils.ConsStatus"
instance Typeable ConsStatus where
    typeOf _ = mkTyConApp _tcConsStatusTc []

_tcFreeOrCofreeTc :: TyCon
_tcFreeOrCofreeTc = mkTyCon "Static.DgUtils.FreeOrCofree"
instance Typeable FreeOrCofree where
    typeOf _ = mkTyConApp _tcFreeOrCofreeTc []

_tcLinkKindTc :: TyCon
_tcLinkKindTc = mkTyCon "Static.DgUtils.LinkKind"
instance Typeable LinkKind where
    typeOf _ = mkTyConApp _tcLinkKindTc []

_tcScopeTc :: TyCon
_tcScopeTc = mkTyCon "Static.DgUtils.Scope"
instance Typeable Scope where
    typeOf _ = mkTyConApp _tcScopeTc []

_tcThmLinkStatusTc :: TyCon
_tcThmLinkStatusTc = mkTyCon "Static.DgUtils.ThmLinkStatus"
instance Typeable ThmLinkStatus where
    typeOf _ = mkTyConApp _tcThmLinkStatusTc []

_tcDGRuleTc :: TyCon
_tcDGRuleTc = mkTyCon "Static.DgUtils.DGRule"
instance Typeable DGRule where
    typeOf _ = mkTyConApp _tcDGRuleTc []

_tcProofBasisTc :: TyCon
_tcProofBasisTc = mkTyCon "Static.DgUtils.ProofBasis"
instance Typeable ProofBasis where
    typeOf _ = mkTyConApp _tcProofBasisTc []

_tcEdgeIdTc :: TyCon
_tcEdgeIdTc = mkTyCon "Static.DgUtils.EdgeId"
instance Typeable EdgeId where
    typeOf _ = mkTyConApp _tcEdgeIdTc []

_tcNodeModTc :: TyCon
_tcNodeModTc = mkTyCon "Static.DgUtils.NodeMod"
instance Typeable NodeMod where
    typeOf _ = mkTyConApp _tcNodeModTc []

_tcDGNodeTypeTc :: TyCon
_tcDGNodeTypeTc = mkTyCon "Static.DgUtils.DGNodeType"
instance Typeable DGNodeType where
    typeOf _ = mkTyConApp _tcDGNodeTypeTc []

_tcNodeNameTc :: TyCon
_tcNodeNameTc = mkTyCon "Static.DgUtils.NodeName"
instance Typeable NodeName where
    typeOf _ = mkTyConApp _tcNodeNameTc []

_tcXPathPartTc :: TyCon
_tcXPathPartTc = mkTyCon "Static.DgUtils.XPathPart"
instance Typeable XPathPart where
    typeOf _ = mkTyConApp _tcXPathPartTc []
