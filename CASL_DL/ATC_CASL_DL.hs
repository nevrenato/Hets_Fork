{-# OPTIONS -w -O0 #-}
{- |
Module      :  CASL_DL/ATC_CASL_DL.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'CASL_DL.AS_CASL_DL.CardType'
'CASL_DL.AS_CASL_DL.DL_FORMULA'
'CASL_DL.Sign.CASL_DLSign'
'CASL_DL.Sign.PropertyType'
'CASL_DL.Sign.AnnoAppl'
'CASL_DL.Sign.AnnoLiteral'
'CASL_DL.Sublogics.CASL_DL_SL'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
CASL_DL/AS_CASL_DL.hs
CASL_DL/Sign.hs
CASL_DL/Sublogics.hs
-}

module CASL_DL.ATC_CASL_DL () where

import ATerm.Lib
import CASL.AS_Basic_CASL
import CASL.ATC_CASL
import CASL_DL.AS_CASL_DL
import CASL_DL.Print_AS ()
import CASL_DL.Sign
import CASL_DL.Sublogics
import Common.AS_Annotation
import Common.Doc
import Common.DocUtils
import Common.Id
import Control.Exception
import Data.List (union, (\\), isPrefixOf)
import Data.Typeable
import qualified Data.Map as Map

{-! for CASL_DL.AS_CASL_DL.CardType derive : Typeable !-}
{-! for CASL_DL.AS_CASL_DL.DL_FORMULA derive : Typeable !-}
{-! for CASL_DL.Sign.CASL_DLSign derive : Typeable !-}
{-! for CASL_DL.Sign.PropertyType derive : Typeable !-}
{-! for CASL_DL.Sign.AnnoAppl derive : Typeable !-}
{-! for CASL_DL.Sign.AnnoLiteral derive : Typeable !-}
{-! for CASL_DL.Sublogics.CASL_DL_SL derive : Typeable !-}

{-! for CASL_DL.AS_CASL_DL.CardType derive : ShATermConvertible !-}
{-! for CASL_DL.AS_CASL_DL.DL_FORMULA derive : ShATermConvertible !-}
{-! for CASL_DL.Sign.CASL_DLSign derive : ShATermConvertible !-}
{-! for CASL_DL.Sign.PropertyType derive : ShATermConvertible !-}
{-! for CASL_DL.Sign.AnnoAppl derive : ShATermConvertible !-}
{-! for CASL_DL.Sign.AnnoLiteral derive : ShATermConvertible !-}
{-! for CASL_DL.Sublogics.CASL_DL_SL derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcCardTypeTc :: TyCon
_tcCardTypeTc = mkTyCon "CASL_DL.AS_CASL_DL.CardType"
instance Typeable CardType where
    typeOf _ = mkTyConApp _tcCardTypeTc []

_tcDL_FORMULATc :: TyCon
_tcDL_FORMULATc = mkTyCon "CASL_DL.AS_CASL_DL.DL_FORMULA"
instance Typeable DL_FORMULA where
    typeOf _ = mkTyConApp _tcDL_FORMULATc []

instance ShATermConvertible CardType where
  toShATermAux att0 xv = case xv of
    CMin -> return $ addATerm (ShAAppl "CMin" [] []) att0
    CMax -> return $ addATerm (ShAAppl "CMax" [] []) att0
    CExact -> return $ addATerm (ShAAppl "CExact" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CMin" [] _ -> (att0, CMin)
    ShAAppl "CMax" [] _ -> (att0, CMax)
    ShAAppl "CExact" [] _ -> (att0, CExact)
    u -> fromShATermError "CardType" u

instance ShATermConvertible DL_FORMULA where
  toShATermAux att0 xv = case xv of
    Cardinality a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "Cardinality" [a', b', c', d', e',
                                                f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Cardinality" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, Cardinality a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "DL_FORMULA" u

_tcCASL_DLSignTc :: TyCon
_tcCASL_DLSignTc = mkTyCon "CASL_DL.Sign.CASL_DLSign"
instance Typeable CASL_DLSign where
    typeOf _ = mkTyConApp _tcCASL_DLSignTc []

_tcPropertyTypeTc :: TyCon
_tcPropertyTypeTc = mkTyCon "CASL_DL.Sign.PropertyType"
instance Typeable PropertyType where
    typeOf _ = mkTyConApp _tcPropertyTypeTc []

_tcAnnoApplTc :: TyCon
_tcAnnoApplTc = mkTyCon "CASL_DL.Sign.AnnoAppl"
instance Typeable AnnoAppl where
    typeOf _ = mkTyConApp _tcAnnoApplTc []

_tcAnnoLiteralTc :: TyCon
_tcAnnoLiteralTc = mkTyCon "CASL_DL.Sign.AnnoLiteral"
instance Typeable AnnoLiteral where
    typeOf _ = mkTyConApp _tcAnnoLiteralTc []

instance ShATermConvertible CASL_DLSign where
  toShATermAux att0 xv = case xv of
    CASL_DLSign a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "CASL_DLSign" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CASL_DLSign" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, CASL_DLSign a' b') }}
    u -> fromShATermError "CASL_DLSign" u

instance ShATermConvertible PropertyType where
  toShATermAux att0 xv = case xv of
    AnnoProperty -> return $ addATerm (ShAAppl "AnnoProperty" [] []) att0
    OntoProperty -> return $ addATerm (ShAAppl "OntoProperty" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnnoProperty" [] _ -> (att0, AnnoProperty)
    ShAAppl "OntoProperty" [] _ -> (att0, OntoProperty)
    u -> fromShATermError "PropertyType" u

instance ShATermConvertible AnnoAppl where
  toShATermAux att0 xv = case xv of
    AnnoAppl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "AnnoAppl" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnnoAppl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, AnnoAppl a' b' c') }}}
    u -> fromShATermError "AnnoAppl" u

instance ShATermConvertible AnnoLiteral where
  toShATermAux att0 xv = case xv of
    AL_Term a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AL_Term" [a'] []) att1
    AL_Id a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AL_Id" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AL_Term" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AL_Term a') }
    ShAAppl "AL_Id" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AL_Id a') }
    u -> fromShATermError "AnnoLiteral" u

instance ShATermConvertible CASL_DL_SL where
  toShATermAux att0 xv = case xv of
    SROIQ -> return $ addATerm (ShAAppl "SROIQ" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SROIQ" [] _ -> (att0, SROIQ)
    u -> fromShATermError "CASL_DL_SL" u

_tcCASL_DL_SLTc :: TyCon
_tcCASL_DL_SLTc = mkTyCon "CASL_DL.Sublogics.CASL_DL_SL"
instance Typeable CASL_DL_SL where
    typeOf _ = mkTyConApp _tcCASL_DL_SLTc []
