{-# OPTIONS -w -O0 #-}
{- |
Module      :  OWL2/ATC_OWL2.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'OWL2.AS.IRIType'
'OWL2.AS.QName'
'OWL2.AS.EquivOrDisjoint'
'OWL2.AS.DomainOrRange'
'OWL2.AS.SameOrDifferent'
'OWL2.AS.Relation'
'OWL2.AS.Character'
'OWL2.AS.PositiveOrNegative'
'OWL2.AS.QuantifierType'
'OWL2.AS.DatatypeCat'
'OWL2.AS.CardinalityType'
'OWL2.AS.Cardinality'
'OWL2.AS.JunctionType'
'OWL2.AS.Entity'
'OWL2.AS.EntityType'
'OWL2.AS.TypedOrUntyped'
'OWL2.AS.Literal'
'OWL2.AS.NNInt'
'OWL2.AS.IntLit'
'OWL2.AS.DecLit'
'OWL2.AS.FloatLit'
'OWL2.AS.ObjectPropertyExpression'
'OWL2.AS.DataRange'
'OWL2.AS.ClassExpression'
'OWL2.AS.Annotation'
'OWL2.AS.AnnotationValue'
'OWL2.Symbols.ExtEntityType'
'OWL2.Symbols.SymbItems'
'OWL2.Symbols.SymbMapItems'
'OWL2.Symbols.RawSymb'
'OWL2.Sign.Sign'
'OWL2.Sign.SignAxiom'
'OWL2.Sign.RoleKind'
'OWL2.Sign.RoleType'
'OWL2.Sign.DesKind'
'OWL2.Sign.DomainOrRangeOrFunc'
'OWL2.MS.Extended'
'OWL2.MS.ListFrameBit'
'OWL2.MS.AnnoType'
'OWL2.MS.AnnFrameBit'
'OWL2.MS.Fact'
'OWL2.MS.FrameBit'
'OWL2.MS.Frame'
'OWL2.MS.Axiom'
'OWL2.MS.Ontology'
'OWL2.MS.OntologyDocument'
'OWL2.Morphism.OWLMorphism'
'OWL2.ProfilesAndSublogics.ProfSub'
'OWL2.Sublogic.NumberRestrictions'
'OWL2.Sublogic.OWLSub'
'OWL2.Profiles.Profiles'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
OWL2/AS.hs
OWL2/Symbols.hs
OWL2/Sign.hs
OWL2/MS.hs
OWL2/Morphism.hs
OWL2/ProfilesAndSublogics.hs
OWL2/Sublogic.hs
OWL2/Profiles.hs
-}

module OWL2.ATC_OWL2 () where

import ATC.Result
import ATerm.Lib
import Common.Doc
import Common.DocUtils
import Common.Id
import Common.Lib.MapSet (setToMap)
import Common.Lib.State (execState)
import Common.Result
import Common.Utils (composeMap)
import Control.Monad
import Data.Char (intToDigit)
import Data.List
import Data.Maybe
import Data.Typeable
import OWL2.AS
import OWL2.ColonKeywords
import OWL2.Function
import OWL2.Keywords
import OWL2.MS
import OWL2.ManchesterPrint ()
import OWL2.Morphism
import OWL2.Profiles
import OWL2.ProfilesAndSublogics
import OWL2.Sign
import OWL2.StaticAnalysis
import OWL2.Sublogic
import OWL2.Symbols
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for OWL2.AS.IRIType derive : Typeable !-}
{-! for OWL2.AS.QName derive : Typeable !-}
{-! for OWL2.AS.EquivOrDisjoint derive : Typeable !-}
{-! for OWL2.AS.DomainOrRange derive : Typeable !-}
{-! for OWL2.AS.SameOrDifferent derive : Typeable !-}
{-! for OWL2.AS.Relation derive : Typeable !-}
{-! for OWL2.AS.Character derive : Typeable !-}
{-! for OWL2.AS.PositiveOrNegative derive : Typeable !-}
{-! for OWL2.AS.QuantifierType derive : Typeable !-}
{-! for OWL2.AS.DatatypeCat derive : Typeable !-}
{-! for OWL2.AS.CardinalityType derive : Typeable !-}
{-! for OWL2.AS.Cardinality derive : Typeable !-}
{-! for OWL2.AS.JunctionType derive : Typeable !-}
{-! for OWL2.AS.Entity derive : Typeable !-}
{-! for OWL2.AS.EntityType derive : Typeable !-}
{-! for OWL2.AS.TypedOrUntyped derive : Typeable !-}
{-! for OWL2.AS.Literal derive : Typeable !-}
{-! for OWL2.AS.NNInt derive : Typeable !-}
{-! for OWL2.AS.IntLit derive : Typeable !-}
{-! for OWL2.AS.DecLit derive : Typeable !-}
{-! for OWL2.AS.FloatLit derive : Typeable !-}
{-! for OWL2.AS.ObjectPropertyExpression derive : Typeable !-}
{-! for OWL2.AS.DataRange derive : Typeable !-}
{-! for OWL2.AS.ClassExpression derive : Typeable !-}
{-! for OWL2.AS.Annotation derive : Typeable !-}
{-! for OWL2.AS.AnnotationValue derive : Typeable !-}
{-! for OWL2.Symbols.ExtEntityType derive : Typeable !-}
{-! for OWL2.Symbols.SymbItems derive : Typeable !-}
{-! for OWL2.Symbols.SymbMapItems derive : Typeable !-}
{-! for OWL2.Symbols.RawSymb derive : Typeable !-}
{-! for OWL2.Sign.Sign derive : Typeable !-}
{-! for OWL2.Sign.SignAxiom derive : Typeable !-}
{-! for OWL2.Sign.RoleKind derive : Typeable !-}
{-! for OWL2.Sign.RoleType derive : Typeable !-}
{-! for OWL2.Sign.DesKind derive : Typeable !-}
{-! for OWL2.Sign.DomainOrRangeOrFunc derive : Typeable !-}
{-! for OWL2.MS.Extended derive : Typeable !-}
{-! for OWL2.MS.ListFrameBit derive : Typeable !-}
{-! for OWL2.MS.AnnoType derive : Typeable !-}
{-! for OWL2.MS.AnnFrameBit derive : Typeable !-}
{-! for OWL2.MS.Fact derive : Typeable !-}
{-! for OWL2.MS.FrameBit derive : Typeable !-}
{-! for OWL2.MS.Frame derive : Typeable !-}
{-! for OWL2.MS.Axiom derive : Typeable !-}
{-! for OWL2.MS.Ontology derive : Typeable !-}
{-! for OWL2.MS.OntologyDocument derive : Typeable !-}
{-! for OWL2.Morphism.OWLMorphism derive : Typeable !-}
{-! for OWL2.ProfilesAndSublogics.ProfSub derive : Typeable !-}
{-! for OWL2.Sublogic.NumberRestrictions derive : Typeable !-}
{-! for OWL2.Sublogic.OWLSub derive : Typeable !-}
{-! for OWL2.Profiles.Profiles derive : Typeable !-}

{-! for OWL2.AS.IRIType derive : ShATermConvertible !-}
{-! for OWL2.AS.QName derive : ShATermConvertible !-}
{-! for OWL2.AS.EquivOrDisjoint derive : ShATermConvertible !-}
{-! for OWL2.AS.DomainOrRange derive : ShATermConvertible !-}
{-! for OWL2.AS.SameOrDifferent derive : ShATermConvertible !-}
{-! for OWL2.AS.Relation derive : ShATermConvertible !-}
{-! for OWL2.AS.Character derive : ShATermConvertible !-}
{-! for OWL2.AS.PositiveOrNegative derive : ShATermConvertible !-}
{-! for OWL2.AS.QuantifierType derive : ShATermConvertible !-}
{-! for OWL2.AS.DatatypeCat derive : ShATermConvertible !-}
{-! for OWL2.AS.CardinalityType derive : ShATermConvertible !-}
{-! for OWL2.AS.Cardinality derive : ShATermConvertible !-}
{-! for OWL2.AS.JunctionType derive : ShATermConvertible !-}
{-! for OWL2.AS.Entity derive : ShATermConvertible !-}
{-! for OWL2.AS.EntityType derive : ShATermConvertible !-}
{-! for OWL2.AS.TypedOrUntyped derive : ShATermConvertible !-}
{-! for OWL2.AS.Literal derive : ShATermConvertible !-}
{-! for OWL2.AS.NNInt derive : ShATermConvertible !-}
{-! for OWL2.AS.IntLit derive : ShATermConvertible !-}
{-! for OWL2.AS.DecLit derive : ShATermConvertible !-}
{-! for OWL2.AS.FloatLit derive : ShATermConvertible !-}
{-! for OWL2.AS.ObjectPropertyExpression derive : ShATermConvertible !-}
{-! for OWL2.AS.DataRange derive : ShATermConvertible !-}
{-! for OWL2.AS.ClassExpression derive : ShATermConvertible !-}
{-! for OWL2.AS.Annotation derive : ShATermConvertible !-}
{-! for OWL2.AS.AnnotationValue derive : ShATermConvertible !-}
{-! for OWL2.Symbols.ExtEntityType derive : ShATermConvertible !-}
{-! for OWL2.Symbols.SymbItems derive : ShATermConvertible !-}
{-! for OWL2.Symbols.SymbMapItems derive : ShATermConvertible !-}
{-! for OWL2.Symbols.RawSymb derive : ShATermConvertible !-}
{-! for OWL2.Sign.Sign derive : ShATermConvertible !-}
{-! for OWL2.Sign.SignAxiom derive : ShATermConvertible !-}
{-! for OWL2.Sign.RoleKind derive : ShATermConvertible !-}
{-! for OWL2.Sign.RoleType derive : ShATermConvertible !-}
{-! for OWL2.Sign.DesKind derive : ShATermConvertible !-}
{-! for OWL2.Sign.DomainOrRangeOrFunc derive : ShATermConvertible !-}
{-! for OWL2.MS.Extended derive : ShATermConvertible !-}
{-! for OWL2.MS.ListFrameBit derive : ShATermConvertible !-}
{-! for OWL2.MS.AnnoType derive : ShATermConvertible !-}
{-! for OWL2.MS.AnnFrameBit derive : ShATermConvertible !-}
{-! for OWL2.MS.Fact derive : ShATermConvertible !-}
{-! for OWL2.MS.FrameBit derive : ShATermConvertible !-}
{-! for OWL2.MS.Frame derive : ShATermConvertible !-}
{-! for OWL2.MS.Axiom derive : ShATermConvertible !-}
{-! for OWL2.MS.Ontology derive : ShATermConvertible !-}
{-! for OWL2.MS.OntologyDocument derive : ShATermConvertible !-}
{-! for OWL2.Morphism.OWLMorphism derive : ShATermConvertible !-}
{-! for OWL2.ProfilesAndSublogics.ProfSub derive : ShATermConvertible !-}
{-! for OWL2.Sublogic.NumberRestrictions derive : ShATermConvertible !-}
{-! for OWL2.Sublogic.OWLSub derive : ShATermConvertible !-}
{-! for OWL2.Profiles.Profiles derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcIRITypeTc :: TyCon
_tcIRITypeTc = mkTyCon "OWL2.AS.IRIType"
instance Typeable IRIType where
    typeOf _ = mkTyConApp _tcIRITypeTc []

_tcQNameTc :: TyCon
_tcQNameTc = mkTyCon "OWL2.AS.QName"
instance Typeable QName where
    typeOf _ = mkTyConApp _tcQNameTc []

_tcEquivOrDisjointTc :: TyCon
_tcEquivOrDisjointTc = mkTyCon "OWL2.AS.EquivOrDisjoint"
instance Typeable EquivOrDisjoint where
    typeOf _ = mkTyConApp _tcEquivOrDisjointTc []

_tcDomainOrRangeTc :: TyCon
_tcDomainOrRangeTc = mkTyCon "OWL2.AS.DomainOrRange"
instance Typeable DomainOrRange where
    typeOf _ = mkTyConApp _tcDomainOrRangeTc []

_tcSameOrDifferentTc :: TyCon
_tcSameOrDifferentTc = mkTyCon "OWL2.AS.SameOrDifferent"
instance Typeable SameOrDifferent where
    typeOf _ = mkTyConApp _tcSameOrDifferentTc []

_tcRelationTc :: TyCon
_tcRelationTc = mkTyCon "OWL2.AS.Relation"
instance Typeable Relation where
    typeOf _ = mkTyConApp _tcRelationTc []

_tcCharacterTc :: TyCon
_tcCharacterTc = mkTyCon "OWL2.AS.Character"
instance Typeable Character where
    typeOf _ = mkTyConApp _tcCharacterTc []

_tcPositiveOrNegativeTc :: TyCon
_tcPositiveOrNegativeTc = mkTyCon "OWL2.AS.PositiveOrNegative"
instance Typeable PositiveOrNegative where
    typeOf _ = mkTyConApp _tcPositiveOrNegativeTc []

_tcQuantifierTypeTc :: TyCon
_tcQuantifierTypeTc = mkTyCon "OWL2.AS.QuantifierType"
instance Typeable QuantifierType where
    typeOf _ = mkTyConApp _tcQuantifierTypeTc []

_tcDatatypeCatTc :: TyCon
_tcDatatypeCatTc = mkTyCon "OWL2.AS.DatatypeCat"
instance Typeable DatatypeCat where
    typeOf _ = mkTyConApp _tcDatatypeCatTc []

_tcCardinalityTypeTc :: TyCon
_tcCardinalityTypeTc = mkTyCon "OWL2.AS.CardinalityType"
instance Typeable CardinalityType where
    typeOf _ = mkTyConApp _tcCardinalityTypeTc []

_tcCardinalityTc :: TyCon
_tcCardinalityTc = mkTyCon "OWL2.AS.Cardinality"
instance Typeable2 Cardinality where
    typeOf2 _ = mkTyConApp _tcCardinalityTc []

_tcJunctionTypeTc :: TyCon
_tcJunctionTypeTc = mkTyCon "OWL2.AS.JunctionType"
instance Typeable JunctionType where
    typeOf _ = mkTyConApp _tcJunctionTypeTc []

_tcEntityTc :: TyCon
_tcEntityTc = mkTyCon "OWL2.AS.Entity"
instance Typeable Entity where
    typeOf _ = mkTyConApp _tcEntityTc []

_tcEntityTypeTc :: TyCon
_tcEntityTypeTc = mkTyCon "OWL2.AS.EntityType"
instance Typeable EntityType where
    typeOf _ = mkTyConApp _tcEntityTypeTc []

_tcTypedOrUntypedTc :: TyCon
_tcTypedOrUntypedTc = mkTyCon "OWL2.AS.TypedOrUntyped"
instance Typeable TypedOrUntyped where
    typeOf _ = mkTyConApp _tcTypedOrUntypedTc []

_tcLiteralTc :: TyCon
_tcLiteralTc = mkTyCon "OWL2.AS.Literal"
instance Typeable Literal where
    typeOf _ = mkTyConApp _tcLiteralTc []

_tcNNIntTc :: TyCon
_tcNNIntTc = mkTyCon "OWL2.AS.NNInt"
instance Typeable NNInt where
    typeOf _ = mkTyConApp _tcNNIntTc []

_tcIntLitTc :: TyCon
_tcIntLitTc = mkTyCon "OWL2.AS.IntLit"
instance Typeable IntLit where
    typeOf _ = mkTyConApp _tcIntLitTc []

_tcDecLitTc :: TyCon
_tcDecLitTc = mkTyCon "OWL2.AS.DecLit"
instance Typeable DecLit where
    typeOf _ = mkTyConApp _tcDecLitTc []

_tcFloatLitTc :: TyCon
_tcFloatLitTc = mkTyCon "OWL2.AS.FloatLit"
instance Typeable FloatLit where
    typeOf _ = mkTyConApp _tcFloatLitTc []

_tcObjectPropertyExpressionTc :: TyCon
_tcObjectPropertyExpressionTc = mkTyCon "OWL2.AS.ObjectPropertyExpression"
instance Typeable ObjectPropertyExpression where
    typeOf _ = mkTyConApp _tcObjectPropertyExpressionTc []

_tcDataRangeTc :: TyCon
_tcDataRangeTc = mkTyCon "OWL2.AS.DataRange"
instance Typeable DataRange where
    typeOf _ = mkTyConApp _tcDataRangeTc []

_tcClassExpressionTc :: TyCon
_tcClassExpressionTc = mkTyCon "OWL2.AS.ClassExpression"
instance Typeable ClassExpression where
    typeOf _ = mkTyConApp _tcClassExpressionTc []

_tcAnnotationTc :: TyCon
_tcAnnotationTc = mkTyCon "OWL2.AS.Annotation"
instance Typeable Annotation where
    typeOf _ = mkTyConApp _tcAnnotationTc []

_tcAnnotationValueTc :: TyCon
_tcAnnotationValueTc = mkTyCon "OWL2.AS.AnnotationValue"
instance Typeable AnnotationValue where
    typeOf _ = mkTyConApp _tcAnnotationValueTc []

instance ShATermConvertible IRIType where
  toShATermAux att0 xv = case xv of
    Full -> return $ addATerm (ShAAppl "Full" [] []) att0
    Abbreviated -> return $ addATerm (ShAAppl "Abbreviated" [] []) att0
    NodeID -> return $ addATerm (ShAAppl "NodeID" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Full" [] _ -> (att0, Full)
    ShAAppl "Abbreviated" [] _ -> (att0, Abbreviated)
    ShAAppl "NodeID" [] _ -> (att0, NodeID)
    u -> fromShATermError "IRIType" u

instance ShATermConvertible QName where
  toShATermAux att0 xv = case xv of
    QN a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "QN" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "QN" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, QN a' b' c' d' e') }}}}}
    u -> fromShATermError "QName" u

instance ShATermConvertible EquivOrDisjoint where
  toShATermAux att0 xv = case xv of
    Equivalent -> return $ addATerm (ShAAppl "Equivalent" [] []) att0
    Disjoint -> return $ addATerm (ShAAppl "Disjoint" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Equivalent" [] _ -> (att0, Equivalent)
    ShAAppl "Disjoint" [] _ -> (att0, Disjoint)
    u -> fromShATermError "EquivOrDisjoint" u

instance ShATermConvertible DomainOrRange where
  toShATermAux att0 xv = case xv of
    ADomain -> return $ addATerm (ShAAppl "ADomain" [] []) att0
    ARange -> return $ addATerm (ShAAppl "ARange" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ADomain" [] _ -> (att0, ADomain)
    ShAAppl "ARange" [] _ -> (att0, ARange)
    u -> fromShATermError "DomainOrRange" u

instance ShATermConvertible SameOrDifferent where
  toShATermAux att0 xv = case xv of
    Same -> return $ addATerm (ShAAppl "Same" [] []) att0
    Different -> return $ addATerm (ShAAppl "Different" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Same" [] _ -> (att0, Same)
    ShAAppl "Different" [] _ -> (att0, Different)
    u -> fromShATermError "SameOrDifferent" u

instance ShATermConvertible Relation where
  toShATermAux att0 xv = case xv of
    EDRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EDRelation" [a'] []) att1
    SubPropertyOf -> return $ addATerm (ShAAppl "SubPropertyOf" [] []) att0
    InverseOf -> return $ addATerm (ShAAppl "InverseOf" [] []) att0
    SubClass -> return $ addATerm (ShAAppl "SubClass" [] []) att0
    Types -> return $ addATerm (ShAAppl "Types" [] []) att0
    DRRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DRRelation" [a'] []) att1
    SDRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SDRelation" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EDRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EDRelation a') }
    ShAAppl "SubPropertyOf" [] _ -> (att0, SubPropertyOf)
    ShAAppl "InverseOf" [] _ -> (att0, InverseOf)
    ShAAppl "SubClass" [] _ -> (att0, SubClass)
    ShAAppl "Types" [] _ -> (att0, Types)
    ShAAppl "DRRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DRRelation a') }
    ShAAppl "SDRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SDRelation a') }
    u -> fromShATermError "Relation" u

instance ShATermConvertible Character where
  toShATermAux att0 xv = case xv of
    Functional -> return $ addATerm (ShAAppl "Functional" [] []) att0
    InverseFunctional ->
      return $ addATerm (ShAAppl "InverseFunctional" [] []) att0
    Reflexive -> return $ addATerm (ShAAppl "Reflexive" [] []) att0
    Irreflexive -> return $ addATerm (ShAAppl "Irreflexive" [] []) att0
    Symmetric -> return $ addATerm (ShAAppl "Symmetric" [] []) att0
    Asymmetric -> return $ addATerm (ShAAppl "Asymmetric" [] []) att0
    Antisymmetric -> return $ addATerm (ShAAppl "Antisymmetric" [] []) att0
    Transitive -> return $ addATerm (ShAAppl "Transitive" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Functional" [] _ -> (att0, Functional)
    ShAAppl "InverseFunctional" [] _ -> (att0, InverseFunctional)
    ShAAppl "Reflexive" [] _ -> (att0, Reflexive)
    ShAAppl "Irreflexive" [] _ -> (att0, Irreflexive)
    ShAAppl "Symmetric" [] _ -> (att0, Symmetric)
    ShAAppl "Asymmetric" [] _ -> (att0, Asymmetric)
    ShAAppl "Antisymmetric" [] _ -> (att0, Antisymmetric)
    ShAAppl "Transitive" [] _ -> (att0, Transitive)
    u -> fromShATermError "Character" u

instance ShATermConvertible PositiveOrNegative where
  toShATermAux att0 xv = case xv of
    Positive -> return $ addATerm (ShAAppl "Positive" [] []) att0
    Negative -> return $ addATerm (ShAAppl "Negative" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Positive" [] _ -> (att0, Positive)
    ShAAppl "Negative" [] _ -> (att0, Negative)
    u -> fromShATermError "PositiveOrNegative" u

instance ShATermConvertible QuantifierType where
  toShATermAux att0 xv = case xv of
    AllValuesFrom -> return $ addATerm (ShAAppl "AllValuesFrom" [] []) att0
    SomeValuesFrom -> return $ addATerm (ShAAppl "SomeValuesFrom" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AllValuesFrom" [] _ -> (att0, AllValuesFrom)
    ShAAppl "SomeValuesFrom" [] _ -> (att0, SomeValuesFrom)
    u -> fromShATermError "QuantifierType" u

instance ShATermConvertible DatatypeCat where
  toShATermAux att0 xv = case xv of
    OWL2Number -> return $ addATerm (ShAAppl "OWL2Number" [] []) att0
    OWL2String -> return $ addATerm (ShAAppl "OWL2String" [] []) att0
    OWL2Bool -> return $ addATerm (ShAAppl "OWL2Bool" [] []) att0
    Other -> return $ addATerm (ShAAppl "Other" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OWL2Number" [] _ -> (att0, OWL2Number)
    ShAAppl "OWL2String" [] _ -> (att0, OWL2String)
    ShAAppl "OWL2Bool" [] _ -> (att0, OWL2Bool)
    ShAAppl "Other" [] _ -> (att0, Other)
    u -> fromShATermError "DatatypeCat" u

instance ShATermConvertible CardinalityType where
  toShATermAux att0 xv = case xv of
    MinCardinality -> return $ addATerm (ShAAppl "MinCardinality" [] []) att0
    MaxCardinality -> return $ addATerm (ShAAppl "MaxCardinality" [] []) att0
    ExactCardinality ->
      return $ addATerm (ShAAppl "ExactCardinality" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MinCardinality" [] _ -> (att0, MinCardinality)
    ShAAppl "MaxCardinality" [] _ -> (att0, MaxCardinality)
    ShAAppl "ExactCardinality" [] _ -> (att0, ExactCardinality)
    u -> fromShATermError "CardinalityType" u

instance (ShATermConvertible a,
          ShATermConvertible b) => ShATermConvertible (Cardinality a b) where
  toShATermAux att0 xv = case xv of
    Cardinality a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Cardinality" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Cardinality" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Cardinality a' b' c' d') }}}}
    u -> fromShATermError "Cardinality" u

instance ShATermConvertible JunctionType where
  toShATermAux att0 xv = case xv of
    UnionOf -> return $ addATerm (ShAAppl "UnionOf" [] []) att0
    IntersectionOf -> return $ addATerm (ShAAppl "IntersectionOf" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "UnionOf" [] _ -> (att0, UnionOf)
    ShAAppl "IntersectionOf" [] _ -> (att0, IntersectionOf)
    u -> fromShATermError "JunctionType" u

instance ShATermConvertible Entity where
  toShATermAux att0 xv = case xv of
    Entity a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Entity" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Entity" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Entity a' b') }}
    u -> fromShATermError "Entity" u

instance ShATermConvertible EntityType where
  toShATermAux att0 xv = case xv of
    Datatype -> return $ addATerm (ShAAppl "Datatype" [] []) att0
    Class -> return $ addATerm (ShAAppl "Class" [] []) att0
    ObjectProperty -> return $ addATerm (ShAAppl "ObjectProperty" [] []) att0
    DataProperty -> return $ addATerm (ShAAppl "DataProperty" [] []) att0
    AnnotationProperty ->
      return $ addATerm (ShAAppl "AnnotationProperty" [] []) att0
    NamedIndividual -> return $ addATerm (ShAAppl "NamedIndividual" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Datatype" [] _ -> (att0, Datatype)
    ShAAppl "Class" [] _ -> (att0, Class)
    ShAAppl "ObjectProperty" [] _ -> (att0, ObjectProperty)
    ShAAppl "DataProperty" [] _ -> (att0, DataProperty)
    ShAAppl "AnnotationProperty" [] _ -> (att0, AnnotationProperty)
    ShAAppl "NamedIndividual" [] _ -> (att0, NamedIndividual)
    u -> fromShATermError "EntityType" u

instance ShATermConvertible TypedOrUntyped where
  toShATermAux att0 xv = case xv of
    Typed a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Typed" [a'] []) att1
    Untyped a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Untyped" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Typed" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Typed a') }
    ShAAppl "Untyped" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Untyped a') }
    u -> fromShATermError "TypedOrUntyped" u

instance ShATermConvertible Literal where
  toShATermAux att0 xv = case xv of
    Literal a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Literal" [a', b'] []) att2
    NumberLit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NumberLit" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Literal" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Literal a' b') }}
    ShAAppl "NumberLit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NumberLit a') }
    u -> fromShATermError "Literal" u

instance ShATermConvertible NNInt where
  toShATermAux att0 xv = case xv of
    NNInt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NNInt" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NNInt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NNInt a') }
    u -> fromShATermError "NNInt" u

instance ShATermConvertible IntLit where
  toShATermAux att0 xv = case xv of
    IntLit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "IntLit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "IntLit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, IntLit a' b') }}
    u -> fromShATermError "IntLit" u

instance ShATermConvertible DecLit where
  toShATermAux att0 xv = case xv of
    DecLit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DecLit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DecLit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DecLit a' b') }}
    u -> fromShATermError "DecLit" u

instance ShATermConvertible FloatLit where
  toShATermAux att0 xv = case xv of
    FloatLit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FloatLit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FloatLit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FloatLit a' b') }}
    u -> fromShATermError "FloatLit" u

instance ShATermConvertible ObjectPropertyExpression where
  toShATermAux att0 xv = case xv of
    ObjectProp a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectProp" [a'] []) att1
    ObjectInverseOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectInverseOf" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ObjectProp" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectProp a') }
    ShAAppl "ObjectInverseOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectInverseOf a') }
    u -> fromShATermError "ObjectPropertyExpression" u

instance ShATermConvertible DataRange where
  toShATermAux att0 xv = case xv of
    DataType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DataType" [a', b'] []) att2
    DataJunction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DataJunction" [a', b'] []) att2
    DataComplementOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataComplementOf" [a'] []) att1
    DataOneOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataOneOf" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DataType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DataType a' b') }}
    ShAAppl "DataJunction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DataJunction a' b') }}
    ShAAppl "DataComplementOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataComplementOf a') }
    ShAAppl "DataOneOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataOneOf a') }
    u -> fromShATermError "DataRange" u

instance ShATermConvertible ClassExpression where
  toShATermAux att0 xv = case xv of
    Expression a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Expression" [a'] []) att1
    ObjectJunction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ObjectJunction" [a', b'] []) att2
    ObjectComplementOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectComplementOf" [a'] []) att1
    ObjectOneOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectOneOf" [a'] []) att1
    ObjectValuesFrom a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ObjectValuesFrom" [a', b', c'] []) att3
    ObjectHasValue a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ObjectHasValue" [a', b'] []) att2
    ObjectHasSelf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectHasSelf" [a'] []) att1
    ObjectCardinality a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectCardinality" [a'] []) att1
    DataValuesFrom a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "DataValuesFrom" [a', b', c'] []) att3
    DataHasValue a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DataHasValue" [a', b'] []) att2
    DataCardinality a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataCardinality" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Expression" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Expression a') }
    ShAAppl "ObjectJunction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ObjectJunction a' b') }}
    ShAAppl "ObjectComplementOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectComplementOf a') }
    ShAAppl "ObjectOneOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectOneOf a') }
    ShAAppl "ObjectValuesFrom" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ObjectValuesFrom a' b' c') }}}
    ShAAppl "ObjectHasValue" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ObjectHasValue a' b') }}
    ShAAppl "ObjectHasSelf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectHasSelf a') }
    ShAAppl "ObjectCardinality" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectCardinality a') }
    ShAAppl "DataValuesFrom" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, DataValuesFrom a' b' c') }}}
    ShAAppl "DataHasValue" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DataHasValue a' b') }}
    ShAAppl "DataCardinality" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataCardinality a') }
    u -> fromShATermError "ClassExpression" u

instance ShATermConvertible Annotation where
  toShATermAux att0 xv = case xv of
    Annotation a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Annotation" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Annotation" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Annotation a' b' c') }}}
    u -> fromShATermError "Annotation" u

instance ShATermConvertible AnnotationValue where
  toShATermAux att0 xv = case xv of
    AnnValue a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnnValue" [a'] []) att1
    AnnValLit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnnValLit" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnnValue" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnnValue a') }
    ShAAppl "AnnValLit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnnValLit a') }
    u -> fromShATermError "AnnotationValue" u

_tcExtendedTc :: TyCon
_tcExtendedTc = mkTyCon "OWL2.MS.Extended"
instance Typeable Extended where
    typeOf _ = mkTyConApp _tcExtendedTc []

_tcListFrameBitTc :: TyCon
_tcListFrameBitTc = mkTyCon "OWL2.MS.ListFrameBit"
instance Typeable ListFrameBit where
    typeOf _ = mkTyConApp _tcListFrameBitTc []

_tcAnnoTypeTc :: TyCon
_tcAnnoTypeTc = mkTyCon "OWL2.MS.AnnoType"
instance Typeable AnnoType where
    typeOf _ = mkTyConApp _tcAnnoTypeTc []

_tcAnnFrameBitTc :: TyCon
_tcAnnFrameBitTc = mkTyCon "OWL2.MS.AnnFrameBit"
instance Typeable AnnFrameBit where
    typeOf _ = mkTyConApp _tcAnnFrameBitTc []

_tcFactTc :: TyCon
_tcFactTc = mkTyCon "OWL2.MS.Fact"
instance Typeable Fact where
    typeOf _ = mkTyConApp _tcFactTc []

_tcFrameBitTc :: TyCon
_tcFrameBitTc = mkTyCon "OWL2.MS.FrameBit"
instance Typeable FrameBit where
    typeOf _ = mkTyConApp _tcFrameBitTc []

_tcFrameTc :: TyCon
_tcFrameTc = mkTyCon "OWL2.MS.Frame"
instance Typeable Frame where
    typeOf _ = mkTyConApp _tcFrameTc []

_tcAxiomTc :: TyCon
_tcAxiomTc = mkTyCon "OWL2.MS.Axiom"
instance Typeable Axiom where
    typeOf _ = mkTyConApp _tcAxiomTc []

_tcOntologyTc :: TyCon
_tcOntologyTc = mkTyCon "OWL2.MS.Ontology"
instance Typeable Ontology where
    typeOf _ = mkTyConApp _tcOntologyTc []

_tcOntologyDocumentTc :: TyCon
_tcOntologyDocumentTc = mkTyCon "OWL2.MS.OntologyDocument"
instance Typeable OntologyDocument where
    typeOf _ = mkTyConApp _tcOntologyDocumentTc []

instance ShATermConvertible Extended where
  toShATermAux att0 xv = case xv of
    Misc a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Misc" [a'] []) att1
    SimpleEntity a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SimpleEntity" [a'] []) att1
    ObjectEntity a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectEntity" [a'] []) att1
    ClassEntity a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ClassEntity" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Misc" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Misc a') }
    ShAAppl "SimpleEntity" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SimpleEntity a') }
    ShAAppl "ObjectEntity" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectEntity a') }
    ShAAppl "ClassEntity" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ClassEntity a') }
    u -> fromShATermError "Extended" u

instance ShATermConvertible ListFrameBit where
  toShATermAux att0 xv = case xv of
    AnnotationBit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnnotationBit" [a'] []) att1
    ExpressionBit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ExpressionBit" [a'] []) att1
    ObjectBit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectBit" [a'] []) att1
    DataBit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataBit" [a'] []) att1
    IndividualSameOrDifferent a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "IndividualSameOrDifferent" [a'] []) att1
    ObjectCharacteristics a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectCharacteristics" [a'] []) att1
    DataPropRange a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataPropRange" [a'] []) att1
    IndividualFacts a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "IndividualFacts" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnnotationBit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnnotationBit a') }
    ShAAppl "ExpressionBit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ExpressionBit a') }
    ShAAppl "ObjectBit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectBit a') }
    ShAAppl "DataBit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataBit a') }
    ShAAppl "IndividualSameOrDifferent" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, IndividualSameOrDifferent a') }
    ShAAppl "ObjectCharacteristics" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectCharacteristics a') }
    ShAAppl "DataPropRange" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataPropRange a') }
    ShAAppl "IndividualFacts" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, IndividualFacts a') }
    u -> fromShATermError "ListFrameBit" u

instance ShATermConvertible AnnoType where
  toShATermAux att0 xv = case xv of
    Declaration -> return $ addATerm (ShAAppl "Declaration" [] []) att0
    Assertion -> return $ addATerm (ShAAppl "Assertion" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Declaration" [] _ -> (att0, Declaration)
    ShAAppl "Assertion" [] _ -> (att0, Assertion)
    u -> fromShATermError "AnnoType" u

instance ShATermConvertible AnnFrameBit where
  toShATermAux att0 xv = case xv of
    AnnotationFrameBit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnnotationFrameBit" [a'] []) att1
    DataFunctional -> return $ addATerm (ShAAppl "DataFunctional" [] []) att0
    DatatypeBit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DatatypeBit" [a'] []) att1
    ClassDisjointUnion a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ClassDisjointUnion" [a'] []) att1
    ClassHasKey a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ClassHasKey" [a', b'] []) att2
    ObjectSubPropertyChain a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectSubPropertyChain" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnnotationFrameBit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnnotationFrameBit a') }
    ShAAppl "DataFunctional" [] _ -> (att0, DataFunctional)
    ShAAppl "DatatypeBit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DatatypeBit a') }
    ShAAppl "ClassDisjointUnion" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ClassDisjointUnion a') }
    ShAAppl "ClassHasKey" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ClassHasKey a' b') }}
    ShAAppl "ObjectSubPropertyChain" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectSubPropertyChain a') }
    u -> fromShATermError "AnnFrameBit" u

instance ShATermConvertible Fact where
  toShATermAux att0 xv = case xv of
    ObjectPropertyFact a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ObjectPropertyFact" [a', b',
                                                       c'] []) att3
    DataPropertyFact a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "DataPropertyFact" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ObjectPropertyFact" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ObjectPropertyFact a' b' c') }}}
    ShAAppl "DataPropertyFact" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, DataPropertyFact a' b' c') }}}
    u -> fromShATermError "Fact" u

instance ShATermConvertible FrameBit where
  toShATermAux att0 xv = case xv of
    ListFrameBit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ListFrameBit" [a', b'] []) att2
    AnnFrameBit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "AnnFrameBit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ListFrameBit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ListFrameBit a' b') }}
    ShAAppl "AnnFrameBit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, AnnFrameBit a' b') }}
    u -> fromShATermError "FrameBit" u

instance ShATermConvertible Frame where
  toShATermAux att0 xv = case xv of
    Frame a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Frame" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Frame" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Frame a' b') }}
    u -> fromShATermError "Frame" u

instance ShATermConvertible Axiom where
  toShATermAux att0 xv = case xv of
    PlainAxiom a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "PlainAxiom" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PlainAxiom" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, PlainAxiom a' b') }}
    u -> fromShATermError "Axiom" u

instance ShATermConvertible Ontology where
  toShATermAux att0 xv = case xv of
    Ontology a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Ontology" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Ontology" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Ontology a' b' c' d') }}}}
    u -> fromShATermError "Ontology" u

instance ShATermConvertible OntologyDocument where
  toShATermAux att0 xv = case xv of
    OntologyDocument a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "OntologyDocument" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OntologyDocument" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, OntologyDocument a' b') }}
    u -> fromShATermError "OntologyDocument" u

_tcOWLMorphismTc :: TyCon
_tcOWLMorphismTc = mkTyCon "OWL2.Morphism.OWLMorphism"
instance Typeable OWLMorphism where
    typeOf _ = mkTyConApp _tcOWLMorphismTc []

instance ShATermConvertible OWLMorphism where
  toShATermAux att0 xv = case xv of
    OWLMorphism a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "OWLMorphism" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OWLMorphism" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, OWLMorphism a' b' c' d') }}}}
    u -> fromShATermError "OWLMorphism" u

instance ShATermConvertible Profiles where
  toShATermAux att0 xv = case xv of
    Profiles a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Profiles" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Profiles" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Profiles a' b' c') }}}
    u -> fromShATermError "Profiles" u

_tcProfilesTc :: TyCon
_tcProfilesTc = mkTyCon "OWL2.Profiles.Profiles"
instance Typeable Profiles where
    typeOf _ = mkTyConApp _tcProfilesTc []

_tcProfSubTc :: TyCon
_tcProfSubTc = mkTyCon "OWL2.ProfilesAndSublogics.ProfSub"
instance Typeable ProfSub where
    typeOf _ = mkTyConApp _tcProfSubTc []

instance ShATermConvertible ProfSub where
  toShATermAux att0 xv = case xv of
    ProfSub a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ProfSub" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ProfSub" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ProfSub a' b') }}
    u -> fromShATermError "ProfSub" u

instance ShATermConvertible a => ShATermConvertible (DomainOrRangeOrFunc a) where
  toShATermAux att0 xv = case xv of
    DomainOrRange a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DomainOrRange" [a', b'] []) att2
    RDRange a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "RDRange" [a'] []) att1
    FuncProp a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FuncProp" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DomainOrRange" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DomainOrRange a' b') }}
    ShAAppl "RDRange" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, RDRange a') }
    ShAAppl "FuncProp" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FuncProp a') }
    u -> fromShATermError "DomainOrRangeOrFunc" u

instance ShATermConvertible DesKind where
  toShATermAux att0 xv = case xv of
    RDomain -> return $ addATerm (ShAAppl "RDomain" [] []) att0
    DDomain -> return $ addATerm (ShAAppl "DDomain" [] []) att0
    RIRange -> return $ addATerm (ShAAppl "RIRange" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "RDomain" [] _ -> (att0, RDomain)
    ShAAppl "DDomain" [] _ -> (att0, DDomain)
    ShAAppl "RIRange" [] _ -> (att0, RIRange)
    u -> fromShATermError "DesKind" u

instance ShATermConvertible RoleType where
  toShATermAux att0 xv = case xv of
    IRole -> return $ addATerm (ShAAppl "IRole" [] []) att0
    DRole -> return $ addATerm (ShAAppl "DRole" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "IRole" [] _ -> (att0, IRole)
    ShAAppl "DRole" [] _ -> (att0, DRole)
    u -> fromShATermError "RoleType" u

instance ShATermConvertible RoleKind where
  toShATermAux att0 xv = case xv of
    FuncRole -> return $ addATerm (ShAAppl "FuncRole" [] []) att0
    RefRole -> return $ addATerm (ShAAppl "RefRole" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FuncRole" [] _ -> (att0, FuncRole)
    ShAAppl "RefRole" [] _ -> (att0, RefRole)
    u -> fromShATermError "RoleKind" u

instance ShATermConvertible SignAxiom where
  toShATermAux att0 xv = case xv of
    Subconcept a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Subconcept" [a', b'] []) att2
    Role a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Role" [a', b'] []) att2
    Data a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Data" [a', b'] []) att2
    Conceptmembership a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Conceptmembership" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Subconcept" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Subconcept a' b') }}
    ShAAppl "Role" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Role a' b') }}
    ShAAppl "Data" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Data a' b') }}
    ShAAppl "Conceptmembership" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Conceptmembership a' b') }}
    u -> fromShATermError "SignAxiom" u

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b c d e f g -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      return $ addATerm (ShAAppl "Sign" [a', b', c', d', e', f',
                                         g'] []) att7
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c, d, e, f, g] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      (att7, Sign a' b' c' d' e' f' g') }}}}}}}
    u -> fromShATermError "Sign" u

_tcDomainOrRangeOrFuncTc :: TyCon
_tcDomainOrRangeOrFuncTc = mkTyCon "OWL2.Sign.DomainOrRangeOrFunc"
instance Typeable1 DomainOrRangeOrFunc where
    typeOf1 _ = mkTyConApp _tcDomainOrRangeOrFuncTc []

_tcDesKindTc :: TyCon
_tcDesKindTc = mkTyCon "OWL2.Sign.DesKind"
instance Typeable DesKind where
    typeOf _ = mkTyConApp _tcDesKindTc []

_tcRoleTypeTc :: TyCon
_tcRoleTypeTc = mkTyCon "OWL2.Sign.RoleType"
instance Typeable RoleType where
    typeOf _ = mkTyConApp _tcRoleTypeTc []

_tcRoleKindTc :: TyCon
_tcRoleKindTc = mkTyCon "OWL2.Sign.RoleKind"
instance Typeable RoleKind where
    typeOf _ = mkTyConApp _tcRoleKindTc []

_tcSignAxiomTc :: TyCon
_tcSignAxiomTc = mkTyCon "OWL2.Sign.SignAxiom"
instance Typeable SignAxiom where
    typeOf _ = mkTyConApp _tcSignAxiomTc []

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "OWL2.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible OWLSub where
  toShATermAux att0 xv = case xv of
    OWLSub a b c d e f g h -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      (att8, h') <- toShATerm' att7 h
      return $ addATerm (ShAAppl "OWLSub" [a', b', c', d', e', f', g',
                                           h'] []) att8
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OWLSub" [a, b, c, d, e, f, g, h] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      case fromShATerm' h att7 of
      { (att8, h') ->
      (att8, OWLSub a' b' c' d' e' f' g' h') }}}}}}}}
    u -> fromShATermError "OWLSub" u

instance ShATermConvertible NumberRestrictions where
  toShATermAux att0 xv = case xv of
    None -> return $ addATerm (ShAAppl "None" [] []) att0
    Unqualified -> return $ addATerm (ShAAppl "Unqualified" [] []) att0
    Qualified -> return $ addATerm (ShAAppl "Qualified" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "None" [] _ -> (att0, None)
    ShAAppl "Unqualified" [] _ -> (att0, Unqualified)
    ShAAppl "Qualified" [] _ -> (att0, Qualified)
    u -> fromShATermError "NumberRestrictions" u

_tcOWLSubTc :: TyCon
_tcOWLSubTc = mkTyCon "OWL2.Sublogic.OWLSub"
instance Typeable OWLSub where
    typeOf _ = mkTyConApp _tcOWLSubTc []

_tcNumberRestrictionsTc :: TyCon
_tcNumberRestrictionsTc = mkTyCon "OWL2.Sublogic.NumberRestrictions"
instance Typeable NumberRestrictions where
    typeOf _ = mkTyConApp _tcNumberRestrictionsTc []

_tcExtEntityTypeTc :: TyCon
_tcExtEntityTypeTc = mkTyCon "OWL2.Symbols.ExtEntityType"
instance Typeable ExtEntityType where
    typeOf _ = mkTyConApp _tcExtEntityTypeTc []

_tcSymbItemsTc :: TyCon
_tcSymbItemsTc = mkTyCon "OWL2.Symbols.SymbItems"
instance Typeable SymbItems where
    typeOf _ = mkTyConApp _tcSymbItemsTc []

_tcSymbMapItemsTc :: TyCon
_tcSymbMapItemsTc = mkTyCon "OWL2.Symbols.SymbMapItems"
instance Typeable SymbMapItems where
    typeOf _ = mkTyConApp _tcSymbMapItemsTc []

_tcRawSymbTc :: TyCon
_tcRawSymbTc = mkTyCon "OWL2.Symbols.RawSymb"
instance Typeable RawSymb where
    typeOf _ = mkTyConApp _tcRawSymbTc []

instance ShATermConvertible ExtEntityType where
  toShATermAux att0 xv = case xv of
    AnyEntity -> return $ addATerm (ShAAppl "AnyEntity" [] []) att0
    Prefix -> return $ addATerm (ShAAppl "Prefix" [] []) att0
    EntityType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EntityType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnyEntity" [] _ -> (att0, AnyEntity)
    ShAAppl "Prefix" [] _ -> (att0, Prefix)
    ShAAppl "EntityType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EntityType a') }
    u -> fromShATermError "ExtEntityType" u

instance ShATermConvertible SymbItems where
  toShATermAux att0 xv = case xv of
    SymbItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SymbItems" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SymbItems a' b') }}
    u -> fromShATermError "SymbItems" u

instance ShATermConvertible SymbMapItems where
  toShATermAux att0 xv = case xv of
    SymbMapItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SymbMapItems" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbMapItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SymbMapItems a' b') }}
    u -> fromShATermError "SymbMapItems" u

instance ShATermConvertible RawSymb where
  toShATermAux att0 xv = case xv of
    ASymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ASymbol" [a'] []) att1
    AnUri a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnUri" [a'] []) att1
    APrefix a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "APrefix" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ASymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ASymbol a') }
    ShAAppl "AnUri" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnUri a') }
    ShAAppl "APrefix" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, APrefix a') }
    u -> fromShATermError "RawSymb" u
