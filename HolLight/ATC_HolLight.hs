{-# OPTIONS -w -O0 #-}
{- |
Module      :  HolLight/ATC_HolLight.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'HolLight.Sentence.Sentence'
'HolLight.Sign.Sign'
'HolLight.Sublogic.HolLightSL'
'HolLight.Term.HolType'
'HolLight.Term.HolProof'
'HolLight.Term.HolParseType'
'HolLight.Term.HolTermInfo'
'HolLight.Term.Term'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
HolLight/Sentence.hs
HolLight/Sign.hs
HolLight/Sublogic.hs
HolLight/Term.hs
-}

module HolLight.ATC_HolLight () where

import ATC.AS_Annotation
import ATerm.Lib
import Common.Doc
import Common.DocUtils
import Common.Result
import Data.Maybe (fromJust, catMaybes, isNothing)
import Data.Typeable
import HolLight.Helper
import HolLight.Sentence
import HolLight.Sign
import HolLight.Sublogic
import HolLight.Term
import qualified Data.Char as Char
import qualified Data.Map as Map

{-! for HolLight.Sentence.Sentence derive : Typeable !-}
{-! for HolLight.Sign.Sign derive : Typeable !-}
{-! for HolLight.Sublogic.HolLightSL derive : Typeable !-}
{-! for HolLight.Term.HolType derive : Typeable !-}
{-! for HolLight.Term.HolProof derive : Typeable !-}
{-! for HolLight.Term.HolParseType derive : Typeable !-}
{-! for HolLight.Term.HolTermInfo derive : Typeable !-}
{-! for HolLight.Term.Term derive : Typeable !-}

{-! for HolLight.Sentence.Sentence derive : ShATermConvertible !-}
{-! for HolLight.Sign.Sign derive : ShATermConvertible !-}
{-! for HolLight.Sublogic.HolLightSL derive : ShATermConvertible !-}
{-! for HolLight.Term.HolType derive : ShATermConvertible !-}
{-! for HolLight.Term.HolProof derive : ShATermConvertible !-}
{-! for HolLight.Term.HolParseType derive : ShATermConvertible !-}
{-! for HolLight.Term.HolTermInfo derive : ShATermConvertible !-}
{-! for HolLight.Term.Term derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible Sentence where
  toShATermAux att0 xv = case xv of
    Sentence a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Sentence" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sentence" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Sentence a' b') }}
    u -> fromShATermError "Sentence" u

_tcSentenceTc :: TyCon
_tcSentenceTc = mkTyCon "HolLight.Sentence.Sentence"
instance Typeable Sentence where
    typeOf _ = mkTyConApp _tcSentenceTc []

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "HolLight.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Sign" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Sign a' b') }}
    u -> fromShATermError "Sign" u

instance ShATermConvertible HolLightSL where
  toShATermAux att0 xv = case xv of
    Top -> return $ addATerm (ShAAppl "Top" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Top" [] _ -> (att0, Top)
    u -> fromShATermError "HolLightSL" u

_tcHolLightSLTc :: TyCon
_tcHolLightSLTc = mkTyCon "HolLight.Sublogic.HolLightSL"
instance Typeable HolLightSL where
    typeOf _ = mkTyConApp _tcHolLightSLTc []

_tcHolTypeTc :: TyCon
_tcHolTypeTc = mkTyCon "HolLight.Term.HolType"
instance Typeable HolType where
    typeOf _ = mkTyConApp _tcHolTypeTc []

_tcHolProofTc :: TyCon
_tcHolProofTc = mkTyCon "HolLight.Term.HolProof"
instance Typeable HolProof where
    typeOf _ = mkTyConApp _tcHolProofTc []

_tcHolParseTypeTc :: TyCon
_tcHolParseTypeTc = mkTyCon "HolLight.Term.HolParseType"
instance Typeable HolParseType where
    typeOf _ = mkTyConApp _tcHolParseTypeTc []

_tcHolTermInfoTc :: TyCon
_tcHolTermInfoTc = mkTyCon "HolLight.Term.HolTermInfo"
instance Typeable HolTermInfo where
    typeOf _ = mkTyConApp _tcHolTermInfoTc []

_tcTermTc :: TyCon
_tcTermTc = mkTyCon "HolLight.Term.Term"
instance Typeable Term where
    typeOf _ = mkTyConApp _tcTermTc []

instance ShATermConvertible HolType where
  toShATermAux att0 xv = case xv of
    TyVar a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TyVar" [a'] []) att1
    TyApp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TyApp" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TyVar" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TyVar a') }
    ShAAppl "TyApp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TyApp a' b') }}
    u -> fromShATermError "HolType" u

instance ShATermConvertible HolProof where
  toShATermAux att0 xv = case xv of
    NoProof -> return $ addATerm (ShAAppl "NoProof" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NoProof" [] _ -> (att0, NoProof)
    u -> fromShATermError "HolProof" u

instance ShATermConvertible HolParseType where
  toShATermAux att0 xv = case xv of
    Normal -> return $ addATerm (ShAAppl "Normal" [] []) att0
    Prefix -> return $ addATerm (ShAAppl "Prefix" [] []) att0
    InfixL a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "InfixL" [a'] []) att1
    InfixR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "InfixR" [a'] []) att1
    Binder -> return $ addATerm (ShAAppl "Binder" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Normal" [] _ -> (att0, Normal)
    ShAAppl "Prefix" [] _ -> (att0, Prefix)
    ShAAppl "InfixL" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, InfixL a') }
    ShAAppl "InfixR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, InfixR a') }
    ShAAppl "Binder" [] _ -> (att0, Binder)
    u -> fromShATermError "HolParseType" u

instance ShATermConvertible HolTermInfo where
  toShATermAux att0 xv = case xv of
    HolTermInfo a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "HolTermInfo" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "HolTermInfo" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, HolTermInfo a') }
    u -> fromShATermError "HolTermInfo" u

instance ShATermConvertible Term where
  toShATermAux att0 xv = case xv of
    Var a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Var" [a', b', c'] []) att3
    Const a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Const" [a', b', c'] []) att3
    Comb a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Comb" [a', b'] []) att2
    Abs a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Abs" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Var" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Var a' b' c') }}}
    ShAAppl "Const" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Const a' b' c') }}}
    ShAAppl "Comb" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Comb a' b') }}
    ShAAppl "Abs" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Abs a' b') }}
    u -> fromShATermError "Term" u
