{-# OPTIONS -w -O0 #-}
{- |
Module      :  DFOL/ATC_DFOL.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'DFOL.AS_DFOL.BASIC_SPEC'
'DFOL.AS_DFOL.BASIC_ITEM'
'DFOL.AS_DFOL.TYPE'
'DFOL.AS_DFOL.TERM'
'DFOL.AS_DFOL.FORMULA'
'DFOL.AS_DFOL.SYMB_ITEMS'
'DFOL.AS_DFOL.SYMB_MAP_ITEMS'
'DFOL.AS_DFOL.SYMB_OR_MAP'
'DFOL.Sign.KIND'
'DFOL.Sign.CONTEXT'
'DFOL.Sign.Sign'
'DFOL.Morphism.Morphism'
'DFOL.Symbol.Symbol'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
DFOL/AS_DFOL.hs
DFOL/Sign.hs
DFOL/Morphism.hs
DFOL/Symbol.hs
-}

module DFOL.ATC_DFOL () where

import ATC.AS_Annotation
import ATerm.Lib
import Common.AS_Annotation
import Common.Doc
import Common.DocUtils
import Common.ExtSign
import Common.Id
import Common.Result
import DFOL.AS_DFOL
import DFOL.Morphism
import DFOL.Sign
import DFOL.Symbol
import DFOL.Utils
import Data.List
import Data.Typeable
import qualified Common.Result as Result
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for DFOL.AS_DFOL.BASIC_SPEC derive : Typeable !-}
{-! for DFOL.AS_DFOL.BASIC_ITEM derive : Typeable !-}
{-! for DFOL.AS_DFOL.TYPE derive : Typeable !-}
{-! for DFOL.AS_DFOL.TERM derive : Typeable !-}
{-! for DFOL.AS_DFOL.FORMULA derive : Typeable !-}
{-! for DFOL.AS_DFOL.SYMB_ITEMS derive : Typeable !-}
{-! for DFOL.AS_DFOL.SYMB_MAP_ITEMS derive : Typeable !-}
{-! for DFOL.AS_DFOL.SYMB_OR_MAP derive : Typeable !-}
{-! for DFOL.Sign.KIND derive : Typeable !-}
{-! for DFOL.Sign.CONTEXT derive : Typeable !-}
{-! for DFOL.Sign.Sign derive : Typeable !-}
{-! for DFOL.Morphism.Morphism derive : Typeable !-}
{-! for DFOL.Symbol.Symbol derive : Typeable !-}

{-! for DFOL.AS_DFOL.BASIC_SPEC derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.BASIC_ITEM derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.TYPE derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.TERM derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.FORMULA derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.SYMB_ITEMS derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.SYMB_MAP_ITEMS derive : ShATermConvertible !-}
{-! for DFOL.AS_DFOL.SYMB_OR_MAP derive : ShATermConvertible !-}
{-! for DFOL.Sign.KIND derive : ShATermConvertible !-}
{-! for DFOL.Sign.CONTEXT derive : ShATermConvertible !-}
{-! for DFOL.Sign.Sign derive : ShATermConvertible !-}
{-! for DFOL.Morphism.Morphism derive : ShATermConvertible !-}
{-! for DFOL.Symbol.Symbol derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible SYMB_OR_MAP where
  toShATermAux att0 xv = case xv of
    Symb a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb" [a'] []) att1
    Symb_map a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Symb_map" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb a') }
    ShAAppl "Symb_map" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Symb_map a' b') }}
    u -> fromShATermError "SYMB_OR_MAP" u

instance ShATermConvertible SYMB_MAP_ITEMS where
  toShATermAux att0 xv = case xv of
    Symb_map_items a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb_map_items" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_map_items" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb_map_items a') }
    u -> fromShATermError "SYMB_MAP_ITEMS" u

instance ShATermConvertible SYMB_ITEMS where
  toShATermAux att0 xv = case xv of
    Symb_items a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb_items" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_items" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb_items a') }
    u -> fromShATermError "SYMB_ITEMS" u

instance ShATermConvertible FORMULA where
  toShATermAux att0 xv = case xv of
    T -> return $ addATerm (ShAAppl "T" [] []) att0
    F -> return $ addATerm (ShAAppl "F" [] []) att0
    Pred a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Pred" [a'] []) att1
    Equality a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Equality" [a', b'] []) att2
    Negation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Negation" [a'] []) att1
    Conjunction a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Conjunction" [a'] []) att1
    Disjunction a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Disjunction" [a'] []) att1
    Implication a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Implication" [a', b'] []) att2
    Equivalence a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Equivalence" [a', b'] []) att2
    Forall a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Forall" [a', b'] []) att2
    Exists a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Exists" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "T" [] _ -> (att0, T)
    ShAAppl "F" [] _ -> (att0, F)
    ShAAppl "Pred" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Pred a') }
    ShAAppl "Equality" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Equality a' b') }}
    ShAAppl "Negation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Negation a') }
    ShAAppl "Conjunction" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Conjunction a') }
    ShAAppl "Disjunction" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Disjunction a') }
    ShAAppl "Implication" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Implication a' b') }}
    ShAAppl "Equivalence" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Equivalence a' b') }}
    ShAAppl "Forall" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Forall a' b') }}
    ShAAppl "Exists" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Exists a' b') }}
    u -> fromShATermError "FORMULA" u

instance ShATermConvertible TERM where
  toShATermAux att0 xv = case xv of
    Identifier a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Identifier" [a'] []) att1
    Appl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Appl" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Identifier" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Identifier a') }
    ShAAppl "Appl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Appl a' b') }}
    u -> fromShATermError "TERM" u

instance ShATermConvertible TYPE where
  toShATermAux att0 xv = case xv of
    Sort -> return $ addATerm (ShAAppl "Sort" [] []) att0
    Form -> return $ addATerm (ShAAppl "Form" [] []) att0
    Univ a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Univ" [a'] []) att1
    Func a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Func" [a', b'] []) att2
    Pi a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Pi" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sort" [] _ -> (att0, Sort)
    ShAAppl "Form" [] _ -> (att0, Form)
    ShAAppl "Univ" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Univ a') }
    ShAAppl "Func" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Func a' b') }}
    ShAAppl "Pi" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Pi a' b') }}
    u -> fromShATermError "TYPE" u

instance ShATermConvertible BASIC_ITEM where
  toShATermAux att0 xv = case xv of
    Decl_item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Decl_item" [a'] []) att1
    Axiom_item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Axiom_item" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Decl_item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Decl_item a') }
    ShAAppl "Axiom_item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Axiom_item a') }
    u -> fromShATermError "BASIC_ITEM" u

instance ShATermConvertible BASIC_SPEC where
  toShATermAux att0 xv = case xv of
    Basic_spec a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Basic_spec" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Basic_spec" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Basic_spec a') }
    u -> fromShATermError "BASIC_SPEC" u

_tcSYMB_OR_MAPTc :: TyCon
_tcSYMB_OR_MAPTc = mkTyCon "DFOL.AS_DFOL.SYMB_OR_MAP"
instance Typeable SYMB_OR_MAP where
    typeOf _ = mkTyConApp _tcSYMB_OR_MAPTc []

_tcSYMB_MAP_ITEMSTc :: TyCon
_tcSYMB_MAP_ITEMSTc = mkTyCon "DFOL.AS_DFOL.SYMB_MAP_ITEMS"
instance Typeable SYMB_MAP_ITEMS where
    typeOf _ = mkTyConApp _tcSYMB_MAP_ITEMSTc []

_tcSYMB_ITEMSTc :: TyCon
_tcSYMB_ITEMSTc = mkTyCon "DFOL.AS_DFOL.SYMB_ITEMS"
instance Typeable SYMB_ITEMS where
    typeOf _ = mkTyConApp _tcSYMB_ITEMSTc []

_tcFORMULATc :: TyCon
_tcFORMULATc = mkTyCon "DFOL.AS_DFOL.FORMULA"
instance Typeable FORMULA where
    typeOf _ = mkTyConApp _tcFORMULATc []

_tcTERMTc :: TyCon
_tcTERMTc = mkTyCon "DFOL.AS_DFOL.TERM"
instance Typeable TERM where
    typeOf _ = mkTyConApp _tcTERMTc []

_tcTYPETc :: TyCon
_tcTYPETc = mkTyCon "DFOL.AS_DFOL.TYPE"
instance Typeable TYPE where
    typeOf _ = mkTyConApp _tcTYPETc []

_tcBASIC_ITEMTc :: TyCon
_tcBASIC_ITEMTc = mkTyCon "DFOL.AS_DFOL.BASIC_ITEM"
instance Typeable BASIC_ITEM where
    typeOf _ = mkTyConApp _tcBASIC_ITEMTc []

_tcBASIC_SPECTc :: TyCon
_tcBASIC_SPECTc = mkTyCon "DFOL.AS_DFOL.BASIC_SPEC"
instance Typeable BASIC_SPEC where
    typeOf _ = mkTyConApp _tcBASIC_SPECTc []

_tcMorphismTc :: TyCon
_tcMorphismTc = mkTyCon "DFOL.Morphism.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tcMorphismTc []

instance ShATermConvertible Morphism where
  toShATermAux att0 xv = case xv of
    Morphism a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Morphism" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Morphism a' b' c') }}}
    u -> fromShATermError "Morphism" u

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Sign" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Sign a') }
    u -> fromShATermError "Sign" u

instance ShATermConvertible CONTEXT where
  toShATermAux att0 xv = case xv of
    Context a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Context" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Context" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Context a') }
    u -> fromShATermError "CONTEXT" u

instance ShATermConvertible KIND where
  toShATermAux att0 xv = case xv of
    SortKind -> return $ addATerm (ShAAppl "SortKind" [] []) att0
    FuncKind -> return $ addATerm (ShAAppl "FuncKind" [] []) att0
    PredKind -> return $ addATerm (ShAAppl "PredKind" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SortKind" [] _ -> (att0, SortKind)
    ShAAppl "FuncKind" [] _ -> (att0, FuncKind)
    ShAAppl "PredKind" [] _ -> (att0, PredKind)
    u -> fromShATermError "KIND" u

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "DFOL.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

_tcCONTEXTTc :: TyCon
_tcCONTEXTTc = mkTyCon "DFOL.Sign.CONTEXT"
instance Typeable CONTEXT where
    typeOf _ = mkTyConApp _tcCONTEXTTc []

_tcKINDTc :: TyCon
_tcKINDTc = mkTyCon "DFOL.Sign.KIND"
instance Typeable KIND where
    typeOf _ = mkTyConApp _tcKINDTc []

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "DFOL.Symbol.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Symbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symbol" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symbol a') }
    u -> fromShATermError "Symbol" u
