{-# OPTIONS -w -O0 #-}
{- |
Module      :  OMDoc/ATC_OMDoc.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'OMDoc.OMDocInterface.OMDoc'
'OMDoc.OMDocInterface.Theory'
'OMDoc.OMDocInterface.ImportsType'
'OMDoc.OMDocInterface.Imports'
'OMDoc.OMDocInterface.Presentation'
'OMDoc.OMDocInterface.Use'
'OMDoc.OMDocInterface.SymbolRole'
'OMDoc.OMDocInterface.Symbol'
'OMDoc.OMDocInterface.Type'
'OMDoc.OMDocInterface.Constitutive'
'OMDoc.OMDocInterface.Axiom'
'OMDoc.OMDocInterface.CMP'
'OMDoc.OMDocInterface.FMP'
'OMDoc.OMDocInterface.Assumption'
'OMDoc.OMDocInterface.Conclusion'
'OMDoc.OMDocInterface.Definition'
'OMDoc.OMDocInterface.ADT'
'OMDoc.OMDocInterface.SortType'
'OMDoc.OMDocInterface.SortDef'
'OMDoc.OMDocInterface.Constructor'
'OMDoc.OMDocInterface.Insort'
'OMDoc.OMDocInterface.Recognizer'
'OMDoc.OMDocInterface.Conservativity'
'OMDoc.OMDocInterface.Inclusion'
'OMDoc.OMDocInterface.Morphism'
'OMDoc.OMDocInterface.MText'
'OMDoc.OMDocInterface.OMDocMathObject'
'OMDoc.OMDocInterface.OMObject'
'OMDoc.OMDocInterface.OMSymbol'
'OMDoc.OMDocInterface.OMInteger'
'OMDoc.OMDocInterface.OMVariable'
'OMDoc.OMDocInterface.OMSimpleVariable'
'OMDoc.OMDocInterface.OMAttribution'
'OMDoc.OMDocInterface.OMAttributionPart'
'OMDoc.OMDocInterface.OMBindingVariables'
'OMDoc.OMDocInterface.OMBase64'
'OMDoc.OMDocInterface.OMString'
'OMDoc.OMDocInterface.OMFloat'
'OMDoc.OMDocInterface.OMApply'
'OMDoc.OMDocInterface.OMError'
'OMDoc.OMDocInterface.OMReference'
'OMDoc.OMDocInterface.OMBind'
'OMDoc.OMDocInterface.OMElement'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
OMDoc/OMDocInterface.hs
-}

module OMDoc.ATC_OMDoc () where

import ATerm.Lib
import Common.Doc
import Common.DocUtils
import Common.Id
import Data.Char
import Data.Typeable
import OMDoc.ATerm
import OMDoc.OMDocInterface
import qualified Data.Word as Word
import qualified Network.URI as URI

{-! for OMDoc.OMDocInterface.OMDoc derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Theory derive : Typeable !-}
{-! for OMDoc.OMDocInterface.ImportsType derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Imports derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Presentation derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Use derive : Typeable !-}
{-! for OMDoc.OMDocInterface.SymbolRole derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Symbol derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Type derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Constitutive derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Axiom derive : Typeable !-}
{-! for OMDoc.OMDocInterface.CMP derive : Typeable !-}
{-! for OMDoc.OMDocInterface.FMP derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Assumption derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Conclusion derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Definition derive : Typeable !-}
{-! for OMDoc.OMDocInterface.ADT derive : Typeable !-}
{-! for OMDoc.OMDocInterface.SortType derive : Typeable !-}
{-! for OMDoc.OMDocInterface.SortDef derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Constructor derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Insort derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Recognizer derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Conservativity derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Inclusion derive : Typeable !-}
{-! for OMDoc.OMDocInterface.Morphism derive : Typeable !-}
{-! for OMDoc.OMDocInterface.MText derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMDocMathObject derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMObject derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMSymbol derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMInteger derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMVariable derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMSimpleVariable derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMAttribution derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMAttributionPart derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMBindingVariables derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMBase64 derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMString derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMFloat derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMApply derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMError derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMReference derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMBind derive : Typeable !-}
{-! for OMDoc.OMDocInterface.OMElement derive : Typeable !-}

{-! for OMDoc.OMDocInterface.OMDoc derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Theory derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.ImportsType derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Imports derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Presentation derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Use derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.SymbolRole derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Symbol derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Type derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Constitutive derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Axiom derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.CMP derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.FMP derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Assumption derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Conclusion derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Definition derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.ADT derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.SortType derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.SortDef derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Constructor derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Insort derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Recognizer derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Conservativity derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Inclusion derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.Morphism derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.MText derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMDocMathObject derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMObject derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMSymbol derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMInteger derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMVariable derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMSimpleVariable derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMAttribution derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMAttributionPart derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMBindingVariables derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMBase64 derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMString derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMFloat derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMApply derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMError derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMReference derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMBind derive : ShATermConvertible !-}
{-! for OMDoc.OMDocInterface.OMElement derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcOMDocTc :: TyCon
_tcOMDocTc = mkTyCon "OMDoc.OMDocInterface.OMDoc"
instance Typeable OMDoc where
    typeOf _ = mkTyConApp _tcOMDocTc []

_tcTheoryTc :: TyCon
_tcTheoryTc = mkTyCon "OMDoc.OMDocInterface.Theory"
instance Typeable Theory where
    typeOf _ = mkTyConApp _tcTheoryTc []

_tcImportsTypeTc :: TyCon
_tcImportsTypeTc = mkTyCon "OMDoc.OMDocInterface.ImportsType"
instance Typeable ImportsType where
    typeOf _ = mkTyConApp _tcImportsTypeTc []

_tcImportsTc :: TyCon
_tcImportsTc = mkTyCon "OMDoc.OMDocInterface.Imports"
instance Typeable Imports where
    typeOf _ = mkTyConApp _tcImportsTc []

_tcPresentationTc :: TyCon
_tcPresentationTc = mkTyCon "OMDoc.OMDocInterface.Presentation"
instance Typeable Presentation where
    typeOf _ = mkTyConApp _tcPresentationTc []

_tcUseTc :: TyCon
_tcUseTc = mkTyCon "OMDoc.OMDocInterface.Use"
instance Typeable Use where
    typeOf _ = mkTyConApp _tcUseTc []

_tcSymbolRoleTc :: TyCon
_tcSymbolRoleTc = mkTyCon "OMDoc.OMDocInterface.SymbolRole"
instance Typeable SymbolRole where
    typeOf _ = mkTyConApp _tcSymbolRoleTc []

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "OMDoc.OMDocInterface.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []

_tcTypeTc :: TyCon
_tcTypeTc = mkTyCon "OMDoc.OMDocInterface.Type"
instance Typeable Type where
    typeOf _ = mkTyConApp _tcTypeTc []

_tcConstitutiveTc :: TyCon
_tcConstitutiveTc = mkTyCon "OMDoc.OMDocInterface.Constitutive"
instance Typeable Constitutive where
    typeOf _ = mkTyConApp _tcConstitutiveTc []

_tcAxiomTc :: TyCon
_tcAxiomTc = mkTyCon "OMDoc.OMDocInterface.Axiom"
instance Typeable Axiom where
    typeOf _ = mkTyConApp _tcAxiomTc []

_tcCMPTc :: TyCon
_tcCMPTc = mkTyCon "OMDoc.OMDocInterface.CMP"
instance Typeable CMP where
    typeOf _ = mkTyConApp _tcCMPTc []

_tcFMPTc :: TyCon
_tcFMPTc = mkTyCon "OMDoc.OMDocInterface.FMP"
instance Typeable FMP where
    typeOf _ = mkTyConApp _tcFMPTc []

_tcAssumptionTc :: TyCon
_tcAssumptionTc = mkTyCon "OMDoc.OMDocInterface.Assumption"
instance Typeable Assumption where
    typeOf _ = mkTyConApp _tcAssumptionTc []

_tcConclusionTc :: TyCon
_tcConclusionTc = mkTyCon "OMDoc.OMDocInterface.Conclusion"
instance Typeable Conclusion where
    typeOf _ = mkTyConApp _tcConclusionTc []

_tcDefinitionTc :: TyCon
_tcDefinitionTc = mkTyCon "OMDoc.OMDocInterface.Definition"
instance Typeable Definition where
    typeOf _ = mkTyConApp _tcDefinitionTc []

_tcADTTc :: TyCon
_tcADTTc = mkTyCon "OMDoc.OMDocInterface.ADT"
instance Typeable ADT where
    typeOf _ = mkTyConApp _tcADTTc []

_tcSortTypeTc :: TyCon
_tcSortTypeTc = mkTyCon "OMDoc.OMDocInterface.SortType"
instance Typeable SortType where
    typeOf _ = mkTyConApp _tcSortTypeTc []

_tcSortDefTc :: TyCon
_tcSortDefTc = mkTyCon "OMDoc.OMDocInterface.SortDef"
instance Typeable SortDef where
    typeOf _ = mkTyConApp _tcSortDefTc []

_tcConstructorTc :: TyCon
_tcConstructorTc = mkTyCon "OMDoc.OMDocInterface.Constructor"
instance Typeable Constructor where
    typeOf _ = mkTyConApp _tcConstructorTc []

_tcInsortTc :: TyCon
_tcInsortTc = mkTyCon "OMDoc.OMDocInterface.Insort"
instance Typeable Insort where
    typeOf _ = mkTyConApp _tcInsortTc []

_tcRecognizerTc :: TyCon
_tcRecognizerTc = mkTyCon "OMDoc.OMDocInterface.Recognizer"
instance Typeable Recognizer where
    typeOf _ = mkTyConApp _tcRecognizerTc []

_tcConservativityTc :: TyCon
_tcConservativityTc = mkTyCon "OMDoc.OMDocInterface.Conservativity"
instance Typeable Conservativity where
    typeOf _ = mkTyConApp _tcConservativityTc []

_tcInclusionTc :: TyCon
_tcInclusionTc = mkTyCon "OMDoc.OMDocInterface.Inclusion"
instance Typeable Inclusion where
    typeOf _ = mkTyConApp _tcInclusionTc []

_tcMorphismTc :: TyCon
_tcMorphismTc = mkTyCon "OMDoc.OMDocInterface.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tcMorphismTc []

_tcMTextTc :: TyCon
_tcMTextTc = mkTyCon "OMDoc.OMDocInterface.MText"
instance Typeable MText where
    typeOf _ = mkTyConApp _tcMTextTc []

_tcOMDocMathObjectTc :: TyCon
_tcOMDocMathObjectTc = mkTyCon "OMDoc.OMDocInterface.OMDocMathObject"
instance Typeable OMDocMathObject where
    typeOf _ = mkTyConApp _tcOMDocMathObjectTc []

_tcOMObjectTc :: TyCon
_tcOMObjectTc = mkTyCon "OMDoc.OMDocInterface.OMObject"
instance Typeable OMObject where
    typeOf _ = mkTyConApp _tcOMObjectTc []

_tcOMSymbolTc :: TyCon
_tcOMSymbolTc = mkTyCon "OMDoc.OMDocInterface.OMSymbol"
instance Typeable OMSymbol where
    typeOf _ = mkTyConApp _tcOMSymbolTc []

_tcOMIntegerTc :: TyCon
_tcOMIntegerTc = mkTyCon "OMDoc.OMDocInterface.OMInteger"
instance Typeable OMInteger where
    typeOf _ = mkTyConApp _tcOMIntegerTc []

_tcOMVariableTc :: TyCon
_tcOMVariableTc = mkTyCon "OMDoc.OMDocInterface.OMVariable"
instance Typeable OMVariable where
    typeOf _ = mkTyConApp _tcOMVariableTc []

_tcOMSimpleVariableTc :: TyCon
_tcOMSimpleVariableTc = mkTyCon "OMDoc.OMDocInterface.OMSimpleVariable"
instance Typeable OMSimpleVariable where
    typeOf _ = mkTyConApp _tcOMSimpleVariableTc []

_tcOMAttributionTc :: TyCon
_tcOMAttributionTc = mkTyCon "OMDoc.OMDocInterface.OMAttribution"
instance Typeable OMAttribution where
    typeOf _ = mkTyConApp _tcOMAttributionTc []

_tcOMAttributionPartTc :: TyCon
_tcOMAttributionPartTc = mkTyCon "OMDoc.OMDocInterface.OMAttributionPart"
instance Typeable OMAttributionPart where
    typeOf _ = mkTyConApp _tcOMAttributionPartTc []

_tcOMBindingVariablesTc :: TyCon
_tcOMBindingVariablesTc = mkTyCon "OMDoc.OMDocInterface.OMBindingVariables"
instance Typeable OMBindingVariables where
    typeOf _ = mkTyConApp _tcOMBindingVariablesTc []

_tcOMBase64Tc :: TyCon
_tcOMBase64Tc = mkTyCon "OMDoc.OMDocInterface.OMBase64"
instance Typeable OMBase64 where
    typeOf _ = mkTyConApp _tcOMBase64Tc []

_tcOMStringTc :: TyCon
_tcOMStringTc = mkTyCon "OMDoc.OMDocInterface.OMString"
instance Typeable OMString where
    typeOf _ = mkTyConApp _tcOMStringTc []

_tcOMFloatTc :: TyCon
_tcOMFloatTc = mkTyCon "OMDoc.OMDocInterface.OMFloat"
instance Typeable OMFloat where
    typeOf _ = mkTyConApp _tcOMFloatTc []

_tcOMApplyTc :: TyCon
_tcOMApplyTc = mkTyCon "OMDoc.OMDocInterface.OMApply"
instance Typeable OMApply where
    typeOf _ = mkTyConApp _tcOMApplyTc []

_tcOMErrorTc :: TyCon
_tcOMErrorTc = mkTyCon "OMDoc.OMDocInterface.OMError"
instance Typeable OMError where
    typeOf _ = mkTyConApp _tcOMErrorTc []

_tcOMReferenceTc :: TyCon
_tcOMReferenceTc = mkTyCon "OMDoc.OMDocInterface.OMReference"
instance Typeable OMReference where
    typeOf _ = mkTyConApp _tcOMReferenceTc []

_tcOMBindTc :: TyCon
_tcOMBindTc = mkTyCon "OMDoc.OMDocInterface.OMBind"
instance Typeable OMBind where
    typeOf _ = mkTyConApp _tcOMBindTc []

_tcOMElementTc :: TyCon
_tcOMElementTc = mkTyCon "OMDoc.OMDocInterface.OMElement"
instance Typeable OMElement where
    typeOf _ = mkTyConApp _tcOMElementTc []

instance ShATermConvertible OMDoc where
  toShATermAux att0 xv = case xv of
    OMDoc a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "OMDoc" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMDoc" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, OMDoc a' b' c') }}}
    u -> fromShATermError "OMDoc" u

instance ShATermConvertible Theory where
  toShATermAux att0 xv = case xv of
    Theory a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Theory" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Theory" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Theory a' b' c' d') }}}}
    u -> fromShATermError "Theory" u

instance ShATermConvertible ImportsType where
  toShATermAux att0 xv = case xv of
    ITLocal -> return $ addATerm (ShAAppl "ITLocal" [] []) att0
    ITGlobal -> return $ addATerm (ShAAppl "ITGlobal" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ITLocal" [] _ -> (att0, ITLocal)
    ShAAppl "ITGlobal" [] _ -> (att0, ITGlobal)
    u -> fromShATermError "ImportsType" u

instance ShATermConvertible Imports where
  toShATermAux att0 xv = case xv of
    Imports a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "Imports" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Imports" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, Imports a' b' c' d' e') }}}}}
    u -> fromShATermError "Imports" u

instance ShATermConvertible Presentation where
  toShATermAux att0 xv = case xv of
    Presentation a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Presentation" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Presentation" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Presentation a' b' c') }}}
    u -> fromShATermError "Presentation" u

instance ShATermConvertible Use where
  toShATermAux att0 xv = case xv of
    Use a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Use" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Use" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Use a' b') }}
    u -> fromShATermError "Use" u

instance ShATermConvertible SymbolRole where
  toShATermAux att0 xv = case xv of
    SRType -> return $ addATerm (ShAAppl "SRType" [] []) att0
    SRSort -> return $ addATerm (ShAAppl "SRSort" [] []) att0
    SRObject -> return $ addATerm (ShAAppl "SRObject" [] []) att0
    SRBinder -> return $ addATerm (ShAAppl "SRBinder" [] []) att0
    SRAttribution -> return $ addATerm (ShAAppl "SRAttribution" [] []) att0
    SRSemanticAttribution ->
      return $ addATerm (ShAAppl "SRSemanticAttribution" [] []) att0
    SRError -> return $ addATerm (ShAAppl "SRError" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SRType" [] _ -> (att0, SRType)
    ShAAppl "SRSort" [] _ -> (att0, SRSort)
    ShAAppl "SRObject" [] _ -> (att0, SRObject)
    ShAAppl "SRBinder" [] _ -> (att0, SRBinder)
    ShAAppl "SRAttribution" [] _ -> (att0, SRAttribution)
    ShAAppl "SRSemanticAttribution" [] _ -> (att0, SRSemanticAttribution)
    ShAAppl "SRError" [] _ -> (att0, SRError)
    u -> fromShATermError "SymbolRole" u

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Symbol a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Symbol" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Symbol a' b' c' d') }}}}
    u -> fromShATermError "Symbol" u

instance ShATermConvertible Type where
  toShATermAux att0 xv = case xv of
    Type a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Type" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Type" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Type a' b') }}
    u -> fromShATermError "Type" u

instance ShATermConvertible Constitutive where
  toShATermAux att0 xv = case xv of
    CAx a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CAx" [a'] []) att1
    CDe a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CDe" [a'] []) att1
    CSy a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CSy" [a'] []) att1
    CIm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CIm" [a'] []) att1
    CAd a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CAd" [a'] []) att1
    CCo a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "CCo" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CAx" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CAx a') }
    ShAAppl "CDe" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CDe a') }
    ShAAppl "CSy" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CSy a') }
    ShAAppl "CIm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CIm a') }
    ShAAppl "CAd" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CAd a') }
    ShAAppl "CCo" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, CCo a' b') }}
    u -> fromShATermError "Constitutive" u

instance ShATermConvertible Axiom where
  toShATermAux att0 xv = case xv of
    Axiom a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Axiom" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Axiom" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Axiom a' b' c') }}}
    u -> fromShATermError "Axiom" u

instance ShATermConvertible CMP where
  toShATermAux att0 xv = case xv of
    CMP a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CMP" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CMP" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CMP a') }
    u -> fromShATermError "CMP" u

instance ShATermConvertible FMP where
  toShATermAux att0 xv = case xv of
    FMP a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FMP" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FMP" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FMP a' b') }}
    u -> fromShATermError "FMP" u

instance ShATermConvertible Assumption where
  toShATermAux att0 xv = case xv of
    Assumption -> return $ addATerm (ShAAppl "Assumption" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Assumption" [] _ -> (att0, Assumption)
    u -> fromShATermError "Assumption" u

instance ShATermConvertible Conclusion where
  toShATermAux att0 xv = case xv of
    Conclusion -> return $ addATerm (ShAAppl "Conclusion" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Conclusion" [] _ -> (att0, Conclusion)
    u -> fromShATermError "Conclusion" u

instance ShATermConvertible Definition where
  toShATermAux att0 xv = case xv of
    Definition a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Definition" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Definition" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Definition a' b' c') }}}
    u -> fromShATermError "Definition" u

instance ShATermConvertible ADT where
  toShATermAux att0 xv = case xv of
    ADT a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ADT" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ADT" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ADT a' b') }}
    u -> fromShATermError "ADT" u

instance ShATermConvertible SortType where
  toShATermAux att0 xv = case xv of
    STFree -> return $ addATerm (ShAAppl "STFree" [] []) att0
    STGenerated -> return $ addATerm (ShAAppl "STGenerated" [] []) att0
    STLoose -> return $ addATerm (ShAAppl "STLoose" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "STFree" [] _ -> (att0, STFree)
    ShAAppl "STGenerated" [] _ -> (att0, STGenerated)
    ShAAppl "STLoose" [] _ -> (att0, STLoose)
    u -> fromShATermError "SortType" u

instance ShATermConvertible SortDef where
  toShATermAux att0 xv = case xv of
    SortDef a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "SortDef" [a', b', c', d', e',
                                            f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SortDef" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, SortDef a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "SortDef" u

instance ShATermConvertible Constructor where
  toShATermAux att0 xv = case xv of
    Constructor a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Constructor" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Constructor" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Constructor a' b' c') }}}
    u -> fromShATermError "Constructor" u

instance ShATermConvertible Insort where
  toShATermAux att0 xv = case xv of
    Insort a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Insort" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Insort" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Insort a') }
    u -> fromShATermError "Insort" u

instance ShATermConvertible Recognizer where
  toShATermAux att0 xv = case xv of
    Recognizer a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Recognizer" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Recognizer" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Recognizer a') }
    u -> fromShATermError "Recognizer" u

instance ShATermConvertible Conservativity where
  toShATermAux att0 xv = case xv of
    CNone -> return $ addATerm (ShAAppl "CNone" [] []) att0
    CMonomorphism -> return $ addATerm (ShAAppl "CMonomorphism" [] []) att0
    CDefinitional -> return $ addATerm (ShAAppl "CDefinitional" [] []) att0
    CConservative -> return $ addATerm (ShAAppl "CConservative" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CNone" [] _ -> (att0, CNone)
    ShAAppl "CMonomorphism" [] _ -> (att0, CMonomorphism)
    ShAAppl "CDefinitional" [] _ -> (att0, CDefinitional)
    ShAAppl "CConservative" [] _ -> (att0, CConservative)
    u -> fromShATermError "Conservativity" u

instance ShATermConvertible Inclusion where
  toShATermAux att0 xv = case xv of
    TheoryInclusion a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "TheoryInclusion" [a', b', c', d',
                                                    e'] []) att5
    AxiomInclusion a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "AxiomInclusion" [a', b', c', d',
                                                   e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TheoryInclusion" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, TheoryInclusion a' b' c' d' e') }}}}}
    ShAAppl "AxiomInclusion" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, AxiomInclusion a' b' c' d' e') }}}}}
    u -> fromShATermError "Inclusion" u

instance ShATermConvertible Morphism where
  toShATermAux att0 xv = case xv of
    Morphism a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Morphism" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Morphism a' b' c' d') }}}}
    u -> fromShATermError "Morphism" u

instance ShATermConvertible MText where
  toShATermAux att0 xv = case xv of
    MTextText a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MTextText" [a'] []) att1
    MTextTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MTextTerm" [a'] []) att1
    MTextPhrase a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MTextPhrase" [a'] []) att1
    MTextOM a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MTextOM" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MTextText" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MTextText a') }
    ShAAppl "MTextTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MTextTerm a') }
    ShAAppl "MTextPhrase" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MTextPhrase a') }
    ShAAppl "MTextOM" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MTextOM a') }
    u -> fromShATermError "MText" u

instance ShATermConvertible OMDocMathObject where
  toShATermAux att0 xv = case xv of
    OMOMOBJ a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMOMOBJ" [a'] []) att1
    OMLegacy a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMLegacy" [a'] []) att1
    OMMath a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMMath" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMOMOBJ" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMOMOBJ a') }
    ShAAppl "OMLegacy" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMLegacy a') }
    ShAAppl "OMMath" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMMath a') }
    u -> fromShATermError "OMDocMathObject" u

instance ShATermConvertible OMObject where
  toShATermAux att0 xv = case xv of
    OMObject a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMObject" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMObject" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMObject a') }
    u -> fromShATermError "OMObject" u

instance ShATermConvertible OMSymbol where
  toShATermAux att0 xv = case xv of
    OMS a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "OMS" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMS" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, OMS a' b' c') }}}
    u -> fromShATermError "OMSymbol" u

instance ShATermConvertible OMInteger where
  toShATermAux att0 xv = case xv of
    OMI a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMI" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMI" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMI a') }
    u -> fromShATermError "OMInteger" u

instance ShATermConvertible OMVariable where
  toShATermAux att0 xv = case xv of
    OMVS a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMVS" [a'] []) att1
    OMVA a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMVA" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMVS" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMVS a') }
    ShAAppl "OMVA" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMVA a') }
    u -> fromShATermError "OMVariable" u

instance ShATermConvertible OMSimpleVariable where
  toShATermAux att0 xv = case xv of
    OMV a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMV" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMV" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMV a') }
    u -> fromShATermError "OMSimpleVariable" u

instance ShATermConvertible OMAttribution where
  toShATermAux att0 xv = case xv of
    OMATTR a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "OMATTR" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMATTR" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, OMATTR a' b') }}
    u -> fromShATermError "OMAttribution" u

instance ShATermConvertible OMAttributionPart where
  toShATermAux att0 xv = case xv of
    OMATP a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMATP" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMATP" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMATP a') }
    u -> fromShATermError "OMAttributionPart" u

instance ShATermConvertible OMBindingVariables where
  toShATermAux att0 xv = case xv of
    OMBVAR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMBVAR" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMBVAR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMBVAR a') }
    u -> fromShATermError "OMBindingVariables" u

instance ShATermConvertible OMBase64 where
  toShATermAux att0 xv = case xv of
    OMB a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMB" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMB" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMB a') }
    u -> fromShATermError "OMBase64" u

instance ShATermConvertible OMString where
  toShATermAux att0 xv = case xv of
    OMSTR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMSTR" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMSTR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMSTR a') }
    u -> fromShATermError "OMString" u

instance ShATermConvertible OMFloat where
  toShATermAux att0 xv = case xv of
    OMF a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMF" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMF" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMF a') }
    u -> fromShATermError "OMFloat" u

instance ShATermConvertible OMApply where
  toShATermAux att0 xv = case xv of
    OMA a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMA" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMA" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMA a') }
    u -> fromShATermError "OMApply" u

instance ShATermConvertible OMError where
  toShATermAux att0 xv = case xv of
    OME a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "OME" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OME" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, OME a' b') }}
    u -> fromShATermError "OMError" u

instance ShATermConvertible OMReference where
  toShATermAux att0 xv = case xv of
    OMR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMR" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMR a') }
    u -> fromShATermError "OMReference" u

instance ShATermConvertible OMBind where
  toShATermAux att0 xv = case xv of
    OMBIND a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "OMBIND" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMBIND" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, OMBIND a' b' c') }}}
    u -> fromShATermError "OMBind" u

instance ShATermConvertible OMElement where
  toShATermAux att0 xv = case xv of
    OMES a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMES" [a'] []) att1
    OMEV a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEV" [a'] []) att1
    OMEI a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEI" [a'] []) att1
    OMEB a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEB" [a'] []) att1
    OMESTR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMESTR" [a'] []) att1
    OMEF a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEF" [a'] []) att1
    OMEA a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEA" [a'] []) att1
    OMEBIND a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEBIND" [a'] []) att1
    OMEE a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEE" [a'] []) att1
    OMEATTR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMEATTR" [a'] []) att1
    OMER a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OMER" [a'] []) att1
    OMEC a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "OMEC" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OMES" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMES a') }
    ShAAppl "OMEV" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEV a') }
    ShAAppl "OMEI" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEI a') }
    ShAAppl "OMEB" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEB a') }
    ShAAppl "OMESTR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMESTR a') }
    ShAAppl "OMEF" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEF a') }
    ShAAppl "OMEA" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEA a') }
    ShAAppl "OMEBIND" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEBIND a') }
    ShAAppl "OMEE" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEE a') }
    ShAAppl "OMEATTR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMEATTR a') }
    ShAAppl "OMER" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OMER a') }
    ShAAppl "OMEC" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, OMEC a' b') }}
    u -> fromShATermError "OMElement" u
