{-# OPTIONS -w -O0 #-}
{- |
Module      :  HasCASL/ATC_HasCASL.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Common.Prec.PrecMap'
'HasCASL.As.BasicSpec'
'HasCASL.As.BasicItem'
'HasCASL.As.SigItems'
'HasCASL.As.OpBrand'
'HasCASL.As.Instance'
'HasCASL.As.ClassItem'
'HasCASL.As.ClassDecl'
'HasCASL.As.Variance'
'HasCASL.As.AnyKind'
'HasCASL.As.TypeItem'
'HasCASL.As.Vars'
'HasCASL.As.TypePattern'
'HasCASL.As.Type'
'HasCASL.As.TypeScheme'
'HasCASL.As.Partiality'
'HasCASL.As.OpItem'
'HasCASL.As.BinOpAttr'
'HasCASL.As.OpAttr'
'HasCASL.As.DatatypeDecl'
'HasCASL.As.Alternative'
'HasCASL.As.Component'
'HasCASL.As.Quantifier'
'HasCASL.As.TypeQual'
'HasCASL.As.LetBrand'
'HasCASL.As.BracketKind'
'HasCASL.As.InstKind'
'HasCASL.As.Term'
'HasCASL.As.ProgEq'
'HasCASL.As.PolyId'
'HasCASL.As.SeparatorKind'
'HasCASL.As.VarDecl'
'HasCASL.As.VarKind'
'HasCASL.As.TypeArg'
'HasCASL.As.GenVarDecl'
'HasCASL.As.SymbItems'
'HasCASL.As.SymbMapItems'
'HasCASL.As.SymbKind'
'HasCASL.As.Symb'
'HasCASL.As.SymbType'
'HasCASL.As.SymbOrMap'
'HasCASL.Le.ClassInfo'
'HasCASL.Le.GenKind'
'HasCASL.Le.AltDefn'
'HasCASL.Le.Selector'
'HasCASL.Le.DataEntry'
'HasCASL.Le.TypeDefn'
'HasCASL.Le.TypeInfo'
'HasCASL.Le.Sentence'
'HasCASL.Le.TypeVarDefn'
'HasCASL.Le.VarDefn'
'HasCASL.Le.ConstrInfo'
'HasCASL.Le.OpDefn'
'HasCASL.Le.OpInfo'
'HasCASL.Le.Env'
'HasCASL.Le.Constrain'
'HasCASL.Le.Morphism'
'HasCASL.Le.SymbolType'
'HasCASL.Le.Symbol'
'HasCASL.Le.RawSymbol'
'HasCASL.Sublogic.Formulas'
'HasCASL.Sublogic.Classes'
'HasCASL.Sublogic.Sublogic'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Common/Prec.hs
HasCASL/As.hs
HasCASL/Le.hs
HasCASL/Sublogic.hs
-}

module HasCASL.ATC_HasCASL () where

import ATC.GlobalAnnotations
import ATerm.Lib
import Common.AS_Annotation
import Common.AS_Annotation (Named)
import Common.GlobalAnnotations
import Common.Id
import Common.Keywords
import Common.Prec
import Common.Result
import Data.List (partition)
import Data.Maybe
import Data.Ord
import Data.Typeable
import HasCASL.As
import HasCASL.AsUtils
import HasCASL.Builtin
import HasCASL.FoldTerm
import HasCASL.FoldType
import HasCASL.Le
import HasCASL.Sublogic
import qualified Common.Lib.Rel as Rel
import qualified Common.Lib.State as State
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for Common.Prec.PrecMap derive : Typeable !-}
{-! for HasCASL.As.BasicSpec derive : Typeable !-}
{-! for HasCASL.As.BasicItem derive : Typeable !-}
{-! for HasCASL.As.SigItems derive : Typeable !-}
{-! for HasCASL.As.OpBrand derive : Typeable !-}
{-! for HasCASL.As.Instance derive : Typeable !-}
{-! for HasCASL.As.ClassItem derive : Typeable !-}
{-! for HasCASL.As.ClassDecl derive : Typeable !-}
{-! for HasCASL.As.Variance derive : Typeable !-}
{-! for HasCASL.As.AnyKind derive : Typeable !-}
{-! for HasCASL.As.TypeItem derive : Typeable !-}
{-! for HasCASL.As.Vars derive : Typeable !-}
{-! for HasCASL.As.TypePattern derive : Typeable !-}
{-! for HasCASL.As.Type derive : Typeable !-}
{-! for HasCASL.As.TypeScheme derive : Typeable !-}
{-! for HasCASL.As.Partiality derive : Typeable !-}
{-! for HasCASL.As.OpItem derive : Typeable !-}
{-! for HasCASL.As.BinOpAttr derive : Typeable !-}
{-! for HasCASL.As.OpAttr derive : Typeable !-}
{-! for HasCASL.As.DatatypeDecl derive : Typeable !-}
{-! for HasCASL.As.Alternative derive : Typeable !-}
{-! for HasCASL.As.Component derive : Typeable !-}
{-! for HasCASL.As.Quantifier derive : Typeable !-}
{-! for HasCASL.As.TypeQual derive : Typeable !-}
{-! for HasCASL.As.LetBrand derive : Typeable !-}
{-! for HasCASL.As.BracketKind derive : Typeable !-}
{-! for HasCASL.As.InstKind derive : Typeable !-}
{-! for HasCASL.As.Term derive : Typeable !-}
{-! for HasCASL.As.ProgEq derive : Typeable !-}
{-! for HasCASL.As.PolyId derive : Typeable !-}
{-! for HasCASL.As.SeparatorKind derive : Typeable !-}
{-! for HasCASL.As.VarDecl derive : Typeable !-}
{-! for HasCASL.As.VarKind derive : Typeable !-}
{-! for HasCASL.As.TypeArg derive : Typeable !-}
{-! for HasCASL.As.GenVarDecl derive : Typeable !-}
{-! for HasCASL.As.SymbItems derive : Typeable !-}
{-! for HasCASL.As.SymbMapItems derive : Typeable !-}
{-! for HasCASL.As.SymbKind derive : Typeable !-}
{-! for HasCASL.As.Symb derive : Typeable !-}
{-! for HasCASL.As.SymbType derive : Typeable !-}
{-! for HasCASL.As.SymbOrMap derive : Typeable !-}
{-! for HasCASL.Le.ClassInfo derive : Typeable !-}
{-! for HasCASL.Le.GenKind derive : Typeable !-}
{-! for HasCASL.Le.AltDefn derive : Typeable !-}
{-! for HasCASL.Le.Selector derive : Typeable !-}
{-! for HasCASL.Le.DataEntry derive : Typeable !-}
{-! for HasCASL.Le.TypeDefn derive : Typeable !-}
{-! for HasCASL.Le.TypeInfo derive : Typeable !-}
{-! for HasCASL.Le.Sentence derive : Typeable !-}
{-! for HasCASL.Le.TypeVarDefn derive : Typeable !-}
{-! for HasCASL.Le.VarDefn derive : Typeable !-}
{-! for HasCASL.Le.ConstrInfo derive : Typeable !-}
{-! for HasCASL.Le.OpDefn derive : Typeable !-}
{-! for HasCASL.Le.OpInfo derive : Typeable !-}
{-! for HasCASL.Le.Env derive : Typeable !-}
{-! for HasCASL.Le.Constrain derive : Typeable !-}
{-! for HasCASL.Le.Morphism derive : Typeable !-}
{-! for HasCASL.Le.SymbolType derive : Typeable !-}
{-! for HasCASL.Le.Symbol derive : Typeable !-}
{-! for HasCASL.Le.RawSymbol derive : Typeable !-}
{-! for HasCASL.Sublogic.Formulas derive : Typeable !-}
{-! for HasCASL.Sublogic.Classes derive : Typeable !-}
{-! for HasCASL.Sublogic.Sublogic derive : Typeable !-}

{-! for Common.Prec.PrecMap derive : ShATermConvertible !-}
{-! for HasCASL.As.BasicSpec derive : ShATermConvertible !-}
{-! for HasCASL.As.BasicItem derive : ShATermConvertible !-}
{-! for HasCASL.As.SigItems derive : ShATermConvertible !-}
{-! for HasCASL.As.OpBrand derive : ShATermConvertible !-}
{-! for HasCASL.As.Instance derive : ShATermConvertible !-}
{-! for HasCASL.As.ClassItem derive : ShATermConvertible !-}
{-! for HasCASL.As.ClassDecl derive : ShATermConvertible !-}
{-! for HasCASL.As.Variance derive : ShATermConvertible !-}
{-! for HasCASL.As.AnyKind derive : ShATermConvertible !-}
{-! for HasCASL.As.TypeItem derive : ShATermConvertible !-}
{-! for HasCASL.As.Vars derive : ShATermConvertible !-}
{-! for HasCASL.As.TypePattern derive : ShATermConvertible !-}
{-! for HasCASL.As.Type derive : ShATermConvertible !-}
{-! for HasCASL.As.TypeScheme derive : ShATermConvertible !-}
{-! for HasCASL.As.Partiality derive : ShATermConvertible !-}
{-! for HasCASL.As.OpItem derive : ShATermConvertible !-}
{-! for HasCASL.As.BinOpAttr derive : ShATermConvertible !-}
{-! for HasCASL.As.OpAttr derive : ShATermConvertible !-}
{-! for HasCASL.As.DatatypeDecl derive : ShATermConvertible !-}
{-! for HasCASL.As.Alternative derive : ShATermConvertible !-}
{-! for HasCASL.As.Component derive : ShATermConvertible !-}
{-! for HasCASL.As.Quantifier derive : ShATermConvertible !-}
{-! for HasCASL.As.TypeQual derive : ShATermConvertible !-}
{-! for HasCASL.As.LetBrand derive : ShATermConvertible !-}
{-! for HasCASL.As.BracketKind derive : ShATermConvertible !-}
{-! for HasCASL.As.InstKind derive : ShATermConvertible !-}
{-! for HasCASL.As.Term derive : ShATermConvertible !-}
{-! for HasCASL.As.ProgEq derive : ShATermConvertible !-}
{-! for HasCASL.As.PolyId derive : ShATermConvertible !-}
{-! for HasCASL.As.SeparatorKind derive : ShATermConvertible !-}
{-! for HasCASL.As.VarDecl derive : ShATermConvertible !-}
{-! for HasCASL.As.VarKind derive : ShATermConvertible !-}
{-! for HasCASL.As.TypeArg derive : ShATermConvertible !-}
{-! for HasCASL.As.GenVarDecl derive : ShATermConvertible !-}
{-! for HasCASL.As.SymbItems derive : ShATermConvertible !-}
{-! for HasCASL.As.SymbMapItems derive : ShATermConvertible !-}
{-! for HasCASL.As.SymbKind derive : ShATermConvertible !-}
{-! for HasCASL.As.Symb derive : ShATermConvertible !-}
{-! for HasCASL.As.SymbType derive : ShATermConvertible !-}
{-! for HasCASL.As.SymbOrMap derive : ShATermConvertible !-}
{-! for HasCASL.Le.ClassInfo derive : ShATermConvertible !-}
{-! for HasCASL.Le.GenKind derive : ShATermConvertible !-}
{-! for HasCASL.Le.AltDefn derive : ShATermConvertible !-}
{-! for HasCASL.Le.Selector derive : ShATermConvertible !-}
{-! for HasCASL.Le.DataEntry derive : ShATermConvertible !-}
{-! for HasCASL.Le.TypeDefn derive : ShATermConvertible !-}
{-! for HasCASL.Le.TypeInfo derive : ShATermConvertible !-}
{-! for HasCASL.Le.Sentence derive : ShATermConvertible !-}
{-! for HasCASL.Le.TypeVarDefn derive : ShATermConvertible !-}
{-! for HasCASL.Le.VarDefn derive : ShATermConvertible !-}
{-! for HasCASL.Le.ConstrInfo derive : ShATermConvertible !-}
{-! for HasCASL.Le.OpDefn derive : ShATermConvertible !-}
{-! for HasCASL.Le.OpInfo derive : ShATermConvertible !-}
{-! for HasCASL.Le.Env derive : ShATermConvertible !-}
{-! for HasCASL.Le.Constrain derive : ShATermConvertible !-}
{-! for HasCASL.Le.Morphism derive : ShATermConvertible !-}
{-! for HasCASL.Le.SymbolType derive : ShATermConvertible !-}
{-! for HasCASL.Le.Symbol derive : ShATermConvertible !-}
{-! for HasCASL.Le.RawSymbol derive : ShATermConvertible !-}
{-! for HasCASL.Sublogic.Formulas derive : ShATermConvertible !-}
{-! for HasCASL.Sublogic.Classes derive : ShATermConvertible !-}
{-! for HasCASL.Sublogic.Sublogic derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcPrecMapTc :: TyCon
_tcPrecMapTc = mkTyCon "Common.Prec.PrecMap"
instance Typeable PrecMap where
    typeOf _ = mkTyConApp _tcPrecMapTc []

instance ShATermConvertible PrecMap where
  toShATermAux att0 xv = case xv of
    PrecMap a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "PrecMap" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PrecMap" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, PrecMap a' b') }}
    u -> fromShATermError "PrecMap" u

_tcBasicSpecTc :: TyCon
_tcBasicSpecTc = mkTyCon "HasCASL.As.BasicSpec"
instance Typeable BasicSpec where
    typeOf _ = mkTyConApp _tcBasicSpecTc []

_tcBasicItemTc :: TyCon
_tcBasicItemTc = mkTyCon "HasCASL.As.BasicItem"
instance Typeable BasicItem where
    typeOf _ = mkTyConApp _tcBasicItemTc []

_tcSigItemsTc :: TyCon
_tcSigItemsTc = mkTyCon "HasCASL.As.SigItems"
instance Typeable SigItems where
    typeOf _ = mkTyConApp _tcSigItemsTc []

_tcOpBrandTc :: TyCon
_tcOpBrandTc = mkTyCon "HasCASL.As.OpBrand"
instance Typeable OpBrand where
    typeOf _ = mkTyConApp _tcOpBrandTc []

_tcInstanceTc :: TyCon
_tcInstanceTc = mkTyCon "HasCASL.As.Instance"
instance Typeable Instance where
    typeOf _ = mkTyConApp _tcInstanceTc []

_tcClassItemTc :: TyCon
_tcClassItemTc = mkTyCon "HasCASL.As.ClassItem"
instance Typeable ClassItem where
    typeOf _ = mkTyConApp _tcClassItemTc []

_tcClassDeclTc :: TyCon
_tcClassDeclTc = mkTyCon "HasCASL.As.ClassDecl"
instance Typeable ClassDecl where
    typeOf _ = mkTyConApp _tcClassDeclTc []

_tcVarianceTc :: TyCon
_tcVarianceTc = mkTyCon "HasCASL.As.Variance"
instance Typeable Variance where
    typeOf _ = mkTyConApp _tcVarianceTc []

_tcAnyKindTc :: TyCon
_tcAnyKindTc = mkTyCon "HasCASL.As.AnyKind"
instance Typeable1 AnyKind where
    typeOf1 _ = mkTyConApp _tcAnyKindTc []

_tcTypeItemTc :: TyCon
_tcTypeItemTc = mkTyCon "HasCASL.As.TypeItem"
instance Typeable TypeItem where
    typeOf _ = mkTyConApp _tcTypeItemTc []

_tcVarsTc :: TyCon
_tcVarsTc = mkTyCon "HasCASL.As.Vars"
instance Typeable Vars where
    typeOf _ = mkTyConApp _tcVarsTc []

_tcTypePatternTc :: TyCon
_tcTypePatternTc = mkTyCon "HasCASL.As.TypePattern"
instance Typeable TypePattern where
    typeOf _ = mkTyConApp _tcTypePatternTc []

_tcTypeTc :: TyCon
_tcTypeTc = mkTyCon "HasCASL.As.Type"
instance Typeable Type where
    typeOf _ = mkTyConApp _tcTypeTc []

_tcTypeSchemeTc :: TyCon
_tcTypeSchemeTc = mkTyCon "HasCASL.As.TypeScheme"
instance Typeable TypeScheme where
    typeOf _ = mkTyConApp _tcTypeSchemeTc []

_tcPartialityTc :: TyCon
_tcPartialityTc = mkTyCon "HasCASL.As.Partiality"
instance Typeable Partiality where
    typeOf _ = mkTyConApp _tcPartialityTc []

_tcOpItemTc :: TyCon
_tcOpItemTc = mkTyCon "HasCASL.As.OpItem"
instance Typeable OpItem where
    typeOf _ = mkTyConApp _tcOpItemTc []

_tcBinOpAttrTc :: TyCon
_tcBinOpAttrTc = mkTyCon "HasCASL.As.BinOpAttr"
instance Typeable BinOpAttr where
    typeOf _ = mkTyConApp _tcBinOpAttrTc []

_tcOpAttrTc :: TyCon
_tcOpAttrTc = mkTyCon "HasCASL.As.OpAttr"
instance Typeable OpAttr where
    typeOf _ = mkTyConApp _tcOpAttrTc []

_tcDatatypeDeclTc :: TyCon
_tcDatatypeDeclTc = mkTyCon "HasCASL.As.DatatypeDecl"
instance Typeable DatatypeDecl where
    typeOf _ = mkTyConApp _tcDatatypeDeclTc []

_tcAlternativeTc :: TyCon
_tcAlternativeTc = mkTyCon "HasCASL.As.Alternative"
instance Typeable Alternative where
    typeOf _ = mkTyConApp _tcAlternativeTc []

_tcComponentTc :: TyCon
_tcComponentTc = mkTyCon "HasCASL.As.Component"
instance Typeable Component where
    typeOf _ = mkTyConApp _tcComponentTc []

_tcQuantifierTc :: TyCon
_tcQuantifierTc = mkTyCon "HasCASL.As.Quantifier"
instance Typeable Quantifier where
    typeOf _ = mkTyConApp _tcQuantifierTc []

_tcTypeQualTc :: TyCon
_tcTypeQualTc = mkTyCon "HasCASL.As.TypeQual"
instance Typeable TypeQual where
    typeOf _ = mkTyConApp _tcTypeQualTc []

_tcLetBrandTc :: TyCon
_tcLetBrandTc = mkTyCon "HasCASL.As.LetBrand"
instance Typeable LetBrand where
    typeOf _ = mkTyConApp _tcLetBrandTc []

_tcBracketKindTc :: TyCon
_tcBracketKindTc = mkTyCon "HasCASL.As.BracketKind"
instance Typeable BracketKind where
    typeOf _ = mkTyConApp _tcBracketKindTc []

_tcInstKindTc :: TyCon
_tcInstKindTc = mkTyCon "HasCASL.As.InstKind"
instance Typeable InstKind where
    typeOf _ = mkTyConApp _tcInstKindTc []

_tcTermTc :: TyCon
_tcTermTc = mkTyCon "HasCASL.As.Term"
instance Typeable Term where
    typeOf _ = mkTyConApp _tcTermTc []

_tcProgEqTc :: TyCon
_tcProgEqTc = mkTyCon "HasCASL.As.ProgEq"
instance Typeable ProgEq where
    typeOf _ = mkTyConApp _tcProgEqTc []

_tcPolyIdTc :: TyCon
_tcPolyIdTc = mkTyCon "HasCASL.As.PolyId"
instance Typeable PolyId where
    typeOf _ = mkTyConApp _tcPolyIdTc []

_tcSeparatorKindTc :: TyCon
_tcSeparatorKindTc = mkTyCon "HasCASL.As.SeparatorKind"
instance Typeable SeparatorKind where
    typeOf _ = mkTyConApp _tcSeparatorKindTc []

_tcVarDeclTc :: TyCon
_tcVarDeclTc = mkTyCon "HasCASL.As.VarDecl"
instance Typeable VarDecl where
    typeOf _ = mkTyConApp _tcVarDeclTc []

_tcVarKindTc :: TyCon
_tcVarKindTc = mkTyCon "HasCASL.As.VarKind"
instance Typeable VarKind where
    typeOf _ = mkTyConApp _tcVarKindTc []

_tcTypeArgTc :: TyCon
_tcTypeArgTc = mkTyCon "HasCASL.As.TypeArg"
instance Typeable TypeArg where
    typeOf _ = mkTyConApp _tcTypeArgTc []

_tcGenVarDeclTc :: TyCon
_tcGenVarDeclTc = mkTyCon "HasCASL.As.GenVarDecl"
instance Typeable GenVarDecl where
    typeOf _ = mkTyConApp _tcGenVarDeclTc []

_tcSymbItemsTc :: TyCon
_tcSymbItemsTc = mkTyCon "HasCASL.As.SymbItems"
instance Typeable SymbItems where
    typeOf _ = mkTyConApp _tcSymbItemsTc []

_tcSymbMapItemsTc :: TyCon
_tcSymbMapItemsTc = mkTyCon "HasCASL.As.SymbMapItems"
instance Typeable SymbMapItems where
    typeOf _ = mkTyConApp _tcSymbMapItemsTc []

_tcSymbKindTc :: TyCon
_tcSymbKindTc = mkTyCon "HasCASL.As.SymbKind"
instance Typeable SymbKind where
    typeOf _ = mkTyConApp _tcSymbKindTc []

_tcSymbTc :: TyCon
_tcSymbTc = mkTyCon "HasCASL.As.Symb"
instance Typeable Symb where
    typeOf _ = mkTyConApp _tcSymbTc []

_tcSymbTypeTc :: TyCon
_tcSymbTypeTc = mkTyCon "HasCASL.As.SymbType"
instance Typeable SymbType where
    typeOf _ = mkTyConApp _tcSymbTypeTc []

_tcSymbOrMapTc :: TyCon
_tcSymbOrMapTc = mkTyCon "HasCASL.As.SymbOrMap"
instance Typeable SymbOrMap where
    typeOf _ = mkTyConApp _tcSymbOrMapTc []

instance ShATermConvertible BasicSpec where
  toShATermAux att0 xv = case xv of
    BasicSpec a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "BasicSpec" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "BasicSpec" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, BasicSpec a') }
    u -> fromShATermError "BasicSpec" u

instance ShATermConvertible BasicItem where
  toShATermAux att0 xv = case xv of
    SigItems a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SigItems" [a'] []) att1
    ProgItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ProgItems" [a', b'] []) att2
    ClassItems a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ClassItems" [a', b', c'] []) att3
    GenVarItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "GenVarItems" [a', b'] []) att2
    FreeDatatype a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FreeDatatype" [a', b'] []) att2
    GenItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "GenItems" [a', b'] []) att2
    AxiomItems a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "AxiomItems" [a', b', c'] []) att3
    Internal a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Internal" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SigItems" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SigItems a') }
    ShAAppl "ProgItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ProgItems a' b') }}
    ShAAppl "ClassItems" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ClassItems a' b' c') }}}
    ShAAppl "GenVarItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, GenVarItems a' b') }}
    ShAAppl "FreeDatatype" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FreeDatatype a' b') }}
    ShAAppl "GenItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, GenItems a' b') }}
    ShAAppl "AxiomItems" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, AxiomItems a' b' c') }}}
    ShAAppl "Internal" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Internal a' b') }}
    u -> fromShATermError "BasicItem" u

instance ShATermConvertible SigItems where
  toShATermAux att0 xv = case xv of
    TypeItems a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TypeItems" [a', b', c'] []) att3
    OpItems a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "OpItems" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeItems" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TypeItems a' b' c') }}}
    ShAAppl "OpItems" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, OpItems a' b' c') }}}
    u -> fromShATermError "SigItems" u

instance ShATermConvertible OpBrand where
  toShATermAux att0 xv = case xv of
    Pred -> return $ addATerm (ShAAppl "Pred" [] []) att0
    Op -> return $ addATerm (ShAAppl "Op" [] []) att0
    Fun -> return $ addATerm (ShAAppl "Fun" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Pred" [] _ -> (att0, Pred)
    ShAAppl "Op" [] _ -> (att0, Op)
    ShAAppl "Fun" [] _ -> (att0, Fun)
    u -> fromShATermError "OpBrand" u

instance ShATermConvertible Instance where
  toShATermAux att0 xv = case xv of
    Instance -> return $ addATerm (ShAAppl "Instance" [] []) att0
    Plain -> return $ addATerm (ShAAppl "Plain" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Instance" [] _ -> (att0, Instance)
    ShAAppl "Plain" [] _ -> (att0, Plain)
    u -> fromShATermError "Instance" u

instance ShATermConvertible ClassItem where
  toShATermAux att0 xv = case xv of
    ClassItem a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ClassItem" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ClassItem" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ClassItem a' b' c') }}}
    u -> fromShATermError "ClassItem" u

instance ShATermConvertible ClassDecl where
  toShATermAux att0 xv = case xv of
    ClassDecl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ClassDecl" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ClassDecl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ClassDecl a' b' c') }}}
    u -> fromShATermError "ClassDecl" u

instance ShATermConvertible Variance where
  toShATermAux att0 xv = case xv of
    InVar -> return $ addATerm (ShAAppl "InVar" [] []) att0
    CoVar -> return $ addATerm (ShAAppl "CoVar" [] []) att0
    ContraVar -> return $ addATerm (ShAAppl "ContraVar" [] []) att0
    NonVar -> return $ addATerm (ShAAppl "NonVar" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "InVar" [] _ -> (att0, InVar)
    ShAAppl "CoVar" [] _ -> (att0, CoVar)
    ShAAppl "ContraVar" [] _ -> (att0, ContraVar)
    ShAAppl "NonVar" [] _ -> (att0, NonVar)
    u -> fromShATermError "Variance" u

instance ShATermConvertible a => ShATermConvertible (AnyKind a) where
  toShATermAux att0 xv = case xv of
    ClassKind a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ClassKind" [a'] []) att1
    FunKind a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "FunKind" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ClassKind" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ClassKind a') }
    ShAAppl "FunKind" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, FunKind a' b' c' d') }}}}
    u -> fromShATermError "AnyKind" u

instance ShATermConvertible TypeItem where
  toShATermAux att0 xv = case xv of
    TypeDecl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TypeDecl" [a', b', c'] []) att3
    SubtypeDecl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SubtypeDecl" [a', b', c'] []) att3
    IsoDecl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "IsoDecl" [a', b'] []) att2
    SubtypeDefn a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "SubtypeDefn" [a', b', c', d',
                                                e'] []) att5
    AliasType a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "AliasType" [a', b', c', d'] []) att4
    Datatype a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Datatype" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeDecl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TypeDecl a' b' c') }}}
    ShAAppl "SubtypeDecl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SubtypeDecl a' b' c') }}}
    ShAAppl "IsoDecl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, IsoDecl a' b') }}
    ShAAppl "SubtypeDefn" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, SubtypeDefn a' b' c' d' e') }}}}}
    ShAAppl "AliasType" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, AliasType a' b' c' d') }}}}
    ShAAppl "Datatype" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Datatype a') }
    u -> fromShATermError "TypeItem" u

instance ShATermConvertible Vars where
  toShATermAux att0 xv = case xv of
    Var a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Var" [a'] []) att1
    VarTuple a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "VarTuple" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Var" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Var a') }
    ShAAppl "VarTuple" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, VarTuple a' b') }}
    u -> fromShATermError "Vars" u

instance ShATermConvertible TypePattern where
  toShATermAux att0 xv = case xv of
    TypePattern a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TypePattern" [a', b', c'] []) att3
    TypePatternToken a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypePatternToken" [a'] []) att1
    MixfixTypePattern a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MixfixTypePattern" [a'] []) att1
    BracketTypePattern a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "BracketTypePattern" [a', b',
                                                       c'] []) att3
    TypePatternArg a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TypePatternArg" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypePattern" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TypePattern a' b' c') }}}
    ShAAppl "TypePatternToken" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypePatternToken a') }
    ShAAppl "MixfixTypePattern" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MixfixTypePattern a') }
    ShAAppl "BracketTypePattern" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, BracketTypePattern a' b' c') }}}
    ShAAppl "TypePatternArg" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TypePatternArg a' b') }}
    u -> fromShATermError "TypePattern" u

instance ShATermConvertible Type where
  toShATermAux att0 xv = case xv of
    TypeName a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TypeName" [a', b', c'] []) att3
    TypeAppl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TypeAppl" [a', b'] []) att2
    ExpandedType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ExpandedType" [a', b'] []) att2
    TypeAbs a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TypeAbs" [a', b', c'] []) att3
    KindedType a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "KindedType" [a', b', c'] []) att3
    TypeToken a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypeToken" [a'] []) att1
    BracketType a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "BracketType" [a', b', c'] []) att3
    MixfixType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MixfixType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeName" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TypeName a' b' c') }}}
    ShAAppl "TypeAppl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TypeAppl a' b') }}
    ShAAppl "ExpandedType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ExpandedType a' b') }}
    ShAAppl "TypeAbs" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TypeAbs a' b' c') }}}
    ShAAppl "KindedType" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, KindedType a' b' c') }}}
    ShAAppl "TypeToken" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypeToken a') }
    ShAAppl "BracketType" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, BracketType a' b' c') }}}
    ShAAppl "MixfixType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MixfixType a') }
    u -> fromShATermError "Type" u

instance ShATermConvertible TypeScheme where
  toShATermAux att0 xv = case xv of
    TypeScheme a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TypeScheme" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeScheme" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TypeScheme a' b' c') }}}
    u -> fromShATermError "TypeScheme" u

instance ShATermConvertible Partiality where
  toShATermAux att0 xv = case xv of
    Partial -> return $ addATerm (ShAAppl "Partial" [] []) att0
    Total -> return $ addATerm (ShAAppl "Total" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Partial" [] _ -> (att0, Partial)
    ShAAppl "Total" [] _ -> (att0, Total)
    u -> fromShATermError "Partiality" u

instance ShATermConvertible OpItem where
  toShATermAux att0 xv = case xv of
    OpDecl a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "OpDecl" [a', b', c', d'] []) att4
    OpDefn a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "OpDefn" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpDecl" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, OpDecl a' b' c' d') }}}}
    ShAAppl "OpDefn" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, OpDefn a' b' c' d' e') }}}}}
    u -> fromShATermError "OpItem" u

instance ShATermConvertible BinOpAttr where
  toShATermAux att0 xv = case xv of
    Assoc -> return $ addATerm (ShAAppl "Assoc" [] []) att0
    Comm -> return $ addATerm (ShAAppl "Comm" [] []) att0
    Idem -> return $ addATerm (ShAAppl "Idem" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Assoc" [] _ -> (att0, Assoc)
    ShAAppl "Comm" [] _ -> (att0, Comm)
    ShAAppl "Idem" [] _ -> (att0, Idem)
    u -> fromShATermError "BinOpAttr" u

instance ShATermConvertible OpAttr where
  toShATermAux att0 xv = case xv of
    BinOpAttr a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "BinOpAttr" [a', b'] []) att2
    UnitOpAttr a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "UnitOpAttr" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "BinOpAttr" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, BinOpAttr a' b') }}
    ShAAppl "UnitOpAttr" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, UnitOpAttr a' b') }}
    u -> fromShATermError "OpAttr" u

instance ShATermConvertible DatatypeDecl where
  toShATermAux att0 xv = case xv of
    DatatypeDecl a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "DatatypeDecl" [a', b', c', d',
                                                 e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DatatypeDecl" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, DatatypeDecl a' b' c' d' e') }}}}}
    u -> fromShATermError "DatatypeDecl" u

instance ShATermConvertible Alternative where
  toShATermAux att0 xv = case xv of
    Constructor a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Constructor" [a', b', c', d'] []) att4
    Subtype a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Subtype" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Constructor" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Constructor a' b' c' d') }}}}
    ShAAppl "Subtype" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Subtype a' b') }}
    u -> fromShATermError "Alternative" u

instance ShATermConvertible Component where
  toShATermAux att0 xv = case xv of
    Selector a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "Selector" [a', b', c', d', e'] []) att5
    NoSelector a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NoSelector" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Selector" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, Selector a' b' c' d' e') }}}}}
    ShAAppl "NoSelector" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NoSelector a') }
    u -> fromShATermError "Component" u

instance ShATermConvertible Quantifier where
  toShATermAux att0 xv = case xv of
    Universal -> return $ addATerm (ShAAppl "Universal" [] []) att0
    Existential -> return $ addATerm (ShAAppl "Existential" [] []) att0
    Unique -> return $ addATerm (ShAAppl "Unique" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Universal" [] _ -> (att0, Universal)
    ShAAppl "Existential" [] _ -> (att0, Existential)
    ShAAppl "Unique" [] _ -> (att0, Unique)
    u -> fromShATermError "Quantifier" u

instance ShATermConvertible TypeQual where
  toShATermAux att0 xv = case xv of
    OfType -> return $ addATerm (ShAAppl "OfType" [] []) att0
    AsType -> return $ addATerm (ShAAppl "AsType" [] []) att0
    InType -> return $ addATerm (ShAAppl "InType" [] []) att0
    Inferred -> return $ addATerm (ShAAppl "Inferred" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OfType" [] _ -> (att0, OfType)
    ShAAppl "AsType" [] _ -> (att0, AsType)
    ShAAppl "InType" [] _ -> (att0, InType)
    ShAAppl "Inferred" [] _ -> (att0, Inferred)
    u -> fromShATermError "TypeQual" u

instance ShATermConvertible LetBrand where
  toShATermAux att0 xv = case xv of
    Let -> return $ addATerm (ShAAppl "Let" [] []) att0
    Where -> return $ addATerm (ShAAppl "Where" [] []) att0
    Program -> return $ addATerm (ShAAppl "Program" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Let" [] _ -> (att0, Let)
    ShAAppl "Where" [] _ -> (att0, Where)
    ShAAppl "Program" [] _ -> (att0, Program)
    u -> fromShATermError "LetBrand" u

instance ShATermConvertible BracketKind where
  toShATermAux att0 xv = case xv of
    Parens -> return $ addATerm (ShAAppl "Parens" [] []) att0
    Squares -> return $ addATerm (ShAAppl "Squares" [] []) att0
    Braces -> return $ addATerm (ShAAppl "Braces" [] []) att0
    NoBrackets -> return $ addATerm (ShAAppl "NoBrackets" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Parens" [] _ -> (att0, Parens)
    ShAAppl "Squares" [] _ -> (att0, Squares)
    ShAAppl "Braces" [] _ -> (att0, Braces)
    ShAAppl "NoBrackets" [] _ -> (att0, NoBrackets)
    u -> fromShATermError "BracketKind" u

instance ShATermConvertible InstKind where
  toShATermAux att0 xv = case xv of
    UserGiven -> return $ addATerm (ShAAppl "UserGiven" [] []) att0
    Infer -> return $ addATerm (ShAAppl "Infer" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "UserGiven" [] _ -> (att0, UserGiven)
    ShAAppl "Infer" [] _ -> (att0, Infer)
    u -> fromShATermError "InstKind" u

instance ShATermConvertible Term where
  toShATermAux att0 xv = case xv of
    QualVar a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "QualVar" [a'] []) att1
    QualOp a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "QualOp" [a', b', c', d', e',
                                           f'] []) att6
    ApplTerm a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ApplTerm" [a', b', c'] []) att3
    TupleTerm a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TupleTerm" [a', b'] []) att2
    TypedTerm a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "TypedTerm" [a', b', c', d'] []) att4
    AsPattern a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "AsPattern" [a', b', c'] []) att3
    QuantifiedTerm a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "QuantifiedTerm" [a', b', c',
                                                   d'] []) att4
    LambdaTerm a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "LambdaTerm" [a', b', c', d'] []) att4
    CaseTerm a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "CaseTerm" [a', b', c'] []) att3
    LetTerm a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "LetTerm" [a', b', c', d'] []) att4
    ResolvedMixTerm a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "ResolvedMixTerm" [a', b', c',
                                                    d'] []) att4
    TermToken a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TermToken" [a'] []) att1
    MixTypeTerm a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "MixTypeTerm" [a', b', c'] []) att3
    MixfixTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "MixfixTerm" [a'] []) att1
    BracketTerm a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "BracketTerm" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "QualVar" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, QualVar a') }
    ShAAppl "QualOp" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, QualOp a' b' c' d' e' f') }}}}}}
    ShAAppl "ApplTerm" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ApplTerm a' b' c') }}}
    ShAAppl "TupleTerm" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TupleTerm a' b') }}
    ShAAppl "TypedTerm" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, TypedTerm a' b' c' d') }}}}
    ShAAppl "AsPattern" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, AsPattern a' b' c') }}}
    ShAAppl "QuantifiedTerm" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, QuantifiedTerm a' b' c' d') }}}}
    ShAAppl "LambdaTerm" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, LambdaTerm a' b' c' d') }}}}
    ShAAppl "CaseTerm" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, CaseTerm a' b' c') }}}
    ShAAppl "LetTerm" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, LetTerm a' b' c' d') }}}}
    ShAAppl "ResolvedMixTerm" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, ResolvedMixTerm a' b' c' d') }}}}
    ShAAppl "TermToken" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TermToken a') }
    ShAAppl "MixTypeTerm" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, MixTypeTerm a' b' c') }}}
    ShAAppl "MixfixTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, MixfixTerm a') }
    ShAAppl "BracketTerm" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, BracketTerm a' b' c') }}}
    u -> fromShATermError "Term" u

instance ShATermConvertible ProgEq where
  toShATermAux att0 xv = case xv of
    ProgEq a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ProgEq" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ProgEq" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ProgEq a' b' c') }}}
    u -> fromShATermError "ProgEq" u

instance ShATermConvertible PolyId where
  toShATermAux att0 xv = case xv of
    PolyId a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "PolyId" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PolyId" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, PolyId a' b' c') }}}
    u -> fromShATermError "PolyId" u

instance ShATermConvertible SeparatorKind where
  toShATermAux att0 xv = case xv of
    Comma -> return $ addATerm (ShAAppl "Comma" [] []) att0
    Other -> return $ addATerm (ShAAppl "Other" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Comma" [] _ -> (att0, Comma)
    ShAAppl "Other" [] _ -> (att0, Other)
    u -> fromShATermError "SeparatorKind" u

instance ShATermConvertible VarDecl where
  toShATermAux att0 xv = case xv of
    VarDecl a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "VarDecl" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "VarDecl" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, VarDecl a' b' c' d') }}}}
    u -> fromShATermError "VarDecl" u

instance ShATermConvertible VarKind where
  toShATermAux att0 xv = case xv of
    VarKind a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "VarKind" [a'] []) att1
    Downset a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Downset" [a'] []) att1
    MissingKind -> return $ addATerm (ShAAppl "MissingKind" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "VarKind" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, VarKind a') }
    ShAAppl "Downset" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Downset a') }
    ShAAppl "MissingKind" [] _ -> (att0, MissingKind)
    u -> fromShATermError "VarKind" u

instance ShATermConvertible TypeArg where
  toShATermAux att0 xv = case xv of
    TypeArg a b c d e f g -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      return $ addATerm (ShAAppl "TypeArg" [a', b', c', d', e', f',
                                            g'] []) att7
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeArg" [a, b, c, d, e, f, g] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      (att7, TypeArg a' b' c' d' e' f' g') }}}}}}}
    u -> fromShATermError "TypeArg" u

instance ShATermConvertible GenVarDecl where
  toShATermAux att0 xv = case xv of
    GenVarDecl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GenVarDecl" [a'] []) att1
    GenTypeVarDecl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GenTypeVarDecl" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "GenVarDecl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GenVarDecl a') }
    ShAAppl "GenTypeVarDecl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GenTypeVarDecl a') }
    u -> fromShATermError "GenVarDecl" u

instance ShATermConvertible SymbItems where
  toShATermAux att0 xv = case xv of
    SymbItems a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "SymbItems" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbItems" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, SymbItems a' b' c' d') }}}}
    u -> fromShATermError "SymbItems" u

instance ShATermConvertible SymbMapItems where
  toShATermAux att0 xv = case xv of
    SymbMapItems a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "SymbMapItems" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbMapItems" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, SymbMapItems a' b' c' d') }}}}
    u -> fromShATermError "SymbMapItems" u

instance ShATermConvertible SymbKind where
  toShATermAux att0 xv = case xv of
    Implicit -> return $ addATerm (ShAAppl "Implicit" [] []) att0
    SyKtype -> return $ addATerm (ShAAppl "SyKtype" [] []) att0
    SyKsort -> return $ addATerm (ShAAppl "SyKsort" [] []) att0
    SyKfun -> return $ addATerm (ShAAppl "SyKfun" [] []) att0
    SyKop -> return $ addATerm (ShAAppl "SyKop" [] []) att0
    SyKpred -> return $ addATerm (ShAAppl "SyKpred" [] []) att0
    SyKclass -> return $ addATerm (ShAAppl "SyKclass" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Implicit" [] _ -> (att0, Implicit)
    ShAAppl "SyKtype" [] _ -> (att0, SyKtype)
    ShAAppl "SyKsort" [] _ -> (att0, SyKsort)
    ShAAppl "SyKfun" [] _ -> (att0, SyKfun)
    ShAAppl "SyKop" [] _ -> (att0, SyKop)
    ShAAppl "SyKpred" [] _ -> (att0, SyKpred)
    ShAAppl "SyKclass" [] _ -> (att0, SyKclass)
    u -> fromShATermError "SymbKind" u

instance ShATermConvertible Symb where
  toShATermAux att0 xv = case xv of
    Symb a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Symb" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Symb a' b' c') }}}
    u -> fromShATermError "Symb" u

instance ShATermConvertible SymbType where
  toShATermAux att0 xv = case xv of
    SymbType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SymbType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SymbType a') }
    u -> fromShATermError "SymbType" u

instance ShATermConvertible SymbOrMap where
  toShATermAux att0 xv = case xv of
    SymbOrMap a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SymbOrMap" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbOrMap" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SymbOrMap a' b' c') }}}
    u -> fromShATermError "SymbOrMap" u

instance ShATermConvertible RawSymbol where
  toShATermAux att0 xv = case xv of
    AnID a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnID" [a'] []) att1
    AKindedId a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "AKindedId" [a', b'] []) att2
    ASymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ASymbol" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnID" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnID a') }
    ShAAppl "AKindedId" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, AKindedId a' b') }}
    ShAAppl "ASymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ASymbol a') }
    u -> fromShATermError "RawSymbol" u

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Symbol a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Symbol" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Symbol a' b') }}
    u -> fromShATermError "Symbol" u

instance ShATermConvertible SymbolType where
  toShATermAux att0 xv = case xv of
    OpAsItemType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpAsItemType" [a'] []) att1
    TypeAsItemType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypeAsItemType" [a'] []) att1
    ClassAsItemType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ClassAsItemType" [a'] []) att1
    SuperClassSymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SuperClassSymbol" [a'] []) att1
    TypeKindInstance a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypeKindInstance" [a'] []) att1
    SuperTypeSymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SuperTypeSymbol" [a'] []) att1
    TypeAliasSymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "TypeAliasSymbol" [a'] []) att1
    PredAsItemType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PredAsItemType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpAsItemType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpAsItemType a') }
    ShAAppl "TypeAsItemType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypeAsItemType a') }
    ShAAppl "ClassAsItemType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ClassAsItemType a') }
    ShAAppl "SuperClassSymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SuperClassSymbol a') }
    ShAAppl "TypeKindInstance" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypeKindInstance a') }
    ShAAppl "SuperTypeSymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SuperTypeSymbol a') }
    ShAAppl "TypeAliasSymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, TypeAliasSymbol a') }
    ShAAppl "PredAsItemType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PredAsItemType a') }
    u -> fromShATermError "SymbolType" u

instance ShATermConvertible Morphism where
  toShATermAux att0 xv = case xv of
    Morphism a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "Morphism" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, Morphism a' b' c' d' e') }}}}}
    u -> fromShATermError "Morphism" u

instance ShATermConvertible Constrain where
  toShATermAux att0 xv = case xv of
    Kinding a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Kinding" [a', b'] []) att2
    Subtyping a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Subtyping" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Kinding" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Kinding a' b') }}
    ShAAppl "Subtyping" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Subtyping a' b') }}
    u -> fromShATermError "Constrain" u

instance ShATermConvertible Env where
  toShATermAux att0 xv = case xv of
    Env a b c d e f g h i j k l -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      (att8, h') <- toShATerm' att7 h
      (att9, i') <- toShATerm' att8 i
      (att10, j') <- toShATerm' att9 j
      (att11, k') <- toShATerm' att10 k
      (att12, l') <- toShATerm' att11 l
      return $ addATerm (ShAAppl "Env" [a', b', c', d', e', f', g', h',
                                        i', j', k', l'] []) att12
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Env" [a, b, c, d, e, f, g, h, i, j, k, l] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      case fromShATerm' h att7 of
      { (att8, h') ->
      case fromShATerm' i att8 of
      { (att9, i') ->
      case fromShATerm' j att9 of
      { (att10, j') ->
      case fromShATerm' k att10 of
      { (att11, k') ->
      case fromShATerm' l att11 of
      { (att12, l') ->
      (att12, Env a' b' c' d' e' f' g' h' i' j' k' l') }}}}}}}}}}}}
    u -> fromShATermError "Env" u

instance ShATermConvertible OpInfo where
  toShATermAux att0 xv = case xv of
    OpInfo a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "OpInfo" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpInfo" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, OpInfo a' b' c') }}}
    u -> fromShATermError "OpInfo" u

instance ShATermConvertible OpDefn where
  toShATermAux att0 xv = case xv of
    NoOpDefn a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NoOpDefn" [a'] []) att1
    ConstructData a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ConstructData" [a'] []) att1
    SelectData a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SelectData" [a', b'] []) att2
    Definition a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Definition" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NoOpDefn" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NoOpDefn a') }
    ShAAppl "ConstructData" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ConstructData a') }
    ShAAppl "SelectData" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SelectData a' b') }}
    ShAAppl "Definition" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Definition a' b') }}
    u -> fromShATermError "OpDefn" u

instance ShATermConvertible ConstrInfo where
  toShATermAux att0 xv = case xv of
    ConstrInfo a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ConstrInfo" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ConstrInfo" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ConstrInfo a' b') }}
    u -> fromShATermError "ConstrInfo" u

instance ShATermConvertible VarDefn where
  toShATermAux att0 xv = case xv of
    VarDefn a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "VarDefn" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "VarDefn" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, VarDefn a') }
    u -> fromShATermError "VarDefn" u

instance ShATermConvertible TypeVarDefn where
  toShATermAux att0 xv = case xv of
    TypeVarDefn a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "TypeVarDefn" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeVarDefn" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, TypeVarDefn a' b' c' d') }}}}
    u -> fromShATermError "TypeVarDefn" u

instance ShATermConvertible Sentence where
  toShATermAux att0 xv = case xv of
    Formula a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Formula" [a'] []) att1
    DatatypeSen a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DatatypeSen" [a'] []) att1
    ProgEqSen a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ProgEqSen" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Formula" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Formula a') }
    ShAAppl "DatatypeSen" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DatatypeSen a') }
    ShAAppl "ProgEqSen" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ProgEqSen a' b' c') }}}
    u -> fromShATermError "Sentence" u

instance ShATermConvertible TypeInfo where
  toShATermAux att0 xv = case xv of
    TypeInfo a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "TypeInfo" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TypeInfo" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, TypeInfo a' b' c' d') }}}}
    u -> fromShATermError "TypeInfo" u

instance ShATermConvertible TypeDefn where
  toShATermAux att0 xv = case xv of
    NoTypeDefn -> return $ addATerm (ShAAppl "NoTypeDefn" [] []) att0
    PreDatatype -> return $ addATerm (ShAAppl "PreDatatype" [] []) att0
    DatatypeDefn a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DatatypeDefn" [a'] []) att1
    AliasTypeDefn a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AliasTypeDefn" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NoTypeDefn" [] _ -> (att0, NoTypeDefn)
    ShAAppl "PreDatatype" [] _ -> (att0, PreDatatype)
    ShAAppl "DatatypeDefn" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DatatypeDefn a') }
    ShAAppl "AliasTypeDefn" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AliasTypeDefn a') }
    u -> fromShATermError "TypeDefn" u

instance ShATermConvertible DataEntry where
  toShATermAux att0 xv = case xv of
    DataEntry a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "DataEntry" [a', b', c', d', e',
                                              f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DataEntry" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, DataEntry a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "DataEntry" u

instance ShATermConvertible Selector where
  toShATermAux att0 xv = case xv of
    Select a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Select" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Select" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Select a' b' c') }}}
    u -> fromShATermError "Selector" u

instance ShATermConvertible AltDefn where
  toShATermAux att0 xv = case xv of
    Construct a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Construct" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Construct" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Construct a' b' c' d') }}}}
    u -> fromShATermError "AltDefn" u

instance ShATermConvertible GenKind where
  toShATermAux att0 xv = case xv of
    Free -> return $ addATerm (ShAAppl "Free" [] []) att0
    Generated -> return $ addATerm (ShAAppl "Generated" [] []) att0
    Loose -> return $ addATerm (ShAAppl "Loose" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Free" [] _ -> (att0, Free)
    ShAAppl "Generated" [] _ -> (att0, Generated)
    ShAAppl "Loose" [] _ -> (att0, Loose)
    u -> fromShATermError "GenKind" u

instance ShATermConvertible ClassInfo where
  toShATermAux att0 xv = case xv of
    ClassInfo a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ClassInfo" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ClassInfo" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ClassInfo a' b') }}
    u -> fromShATermError "ClassInfo" u

_tcRawSymbolTc :: TyCon
_tcRawSymbolTc = mkTyCon "HasCASL.Le.RawSymbol"
instance Typeable RawSymbol where
    typeOf _ = mkTyConApp _tcRawSymbolTc []

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "HasCASL.Le.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []

_tcSymbolTypeTc :: TyCon
_tcSymbolTypeTc = mkTyCon "HasCASL.Le.SymbolType"
instance Typeable SymbolType where
    typeOf _ = mkTyConApp _tcSymbolTypeTc []

_tcMorphismTc :: TyCon
_tcMorphismTc = mkTyCon "HasCASL.Le.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tcMorphismTc []

_tcConstrainTc :: TyCon
_tcConstrainTc = mkTyCon "HasCASL.Le.Constrain"
instance Typeable Constrain where
    typeOf _ = mkTyConApp _tcConstrainTc []

_tcEnvTc :: TyCon
_tcEnvTc = mkTyCon "HasCASL.Le.Env"
instance Typeable Env where
    typeOf _ = mkTyConApp _tcEnvTc []

_tcOpInfoTc :: TyCon
_tcOpInfoTc = mkTyCon "HasCASL.Le.OpInfo"
instance Typeable OpInfo where
    typeOf _ = mkTyConApp _tcOpInfoTc []

_tcOpDefnTc :: TyCon
_tcOpDefnTc = mkTyCon "HasCASL.Le.OpDefn"
instance Typeable OpDefn where
    typeOf _ = mkTyConApp _tcOpDefnTc []

_tcConstrInfoTc :: TyCon
_tcConstrInfoTc = mkTyCon "HasCASL.Le.ConstrInfo"
instance Typeable ConstrInfo where
    typeOf _ = mkTyConApp _tcConstrInfoTc []

_tcVarDefnTc :: TyCon
_tcVarDefnTc = mkTyCon "HasCASL.Le.VarDefn"
instance Typeable VarDefn where
    typeOf _ = mkTyConApp _tcVarDefnTc []

_tcTypeVarDefnTc :: TyCon
_tcTypeVarDefnTc = mkTyCon "HasCASL.Le.TypeVarDefn"
instance Typeable TypeVarDefn where
    typeOf _ = mkTyConApp _tcTypeVarDefnTc []

_tcSentenceTc :: TyCon
_tcSentenceTc = mkTyCon "HasCASL.Le.Sentence"
instance Typeable Sentence where
    typeOf _ = mkTyConApp _tcSentenceTc []

_tcTypeInfoTc :: TyCon
_tcTypeInfoTc = mkTyCon "HasCASL.Le.TypeInfo"
instance Typeable TypeInfo where
    typeOf _ = mkTyConApp _tcTypeInfoTc []

_tcTypeDefnTc :: TyCon
_tcTypeDefnTc = mkTyCon "HasCASL.Le.TypeDefn"
instance Typeable TypeDefn where
    typeOf _ = mkTyConApp _tcTypeDefnTc []

_tcDataEntryTc :: TyCon
_tcDataEntryTc = mkTyCon "HasCASL.Le.DataEntry"
instance Typeable DataEntry where
    typeOf _ = mkTyConApp _tcDataEntryTc []

_tcSelectorTc :: TyCon
_tcSelectorTc = mkTyCon "HasCASL.Le.Selector"
instance Typeable Selector where
    typeOf _ = mkTyConApp _tcSelectorTc []

_tcAltDefnTc :: TyCon
_tcAltDefnTc = mkTyCon "HasCASL.Le.AltDefn"
instance Typeable AltDefn where
    typeOf _ = mkTyConApp _tcAltDefnTc []

_tcGenKindTc :: TyCon
_tcGenKindTc = mkTyCon "HasCASL.Le.GenKind"
instance Typeable GenKind where
    typeOf _ = mkTyConApp _tcGenKindTc []

_tcClassInfoTc :: TyCon
_tcClassInfoTc = mkTyCon "HasCASL.Le.ClassInfo"
instance Typeable ClassInfo where
    typeOf _ = mkTyConApp _tcClassInfoTc []

_tcFormulasTc :: TyCon
_tcFormulasTc = mkTyCon "HasCASL.Sublogic.Formulas"
instance Typeable Formulas where
    typeOf _ = mkTyConApp _tcFormulasTc []

_tcClassesTc :: TyCon
_tcClassesTc = mkTyCon "HasCASL.Sublogic.Classes"
instance Typeable Classes where
    typeOf _ = mkTyConApp _tcClassesTc []

_tcSublogicTc :: TyCon
_tcSublogicTc = mkTyCon "HasCASL.Sublogic.Sublogic"
instance Typeable Sublogic where
    typeOf _ = mkTyConApp _tcSublogicTc []

instance ShATermConvertible Formulas where
  toShATermAux att0 xv = case xv of
    Atomic -> return $ addATerm (ShAAppl "Atomic" [] []) att0
    Horn -> return $ addATerm (ShAAppl "Horn" [] []) att0
    GHorn -> return $ addATerm (ShAAppl "GHorn" [] []) att0
    FOL -> return $ addATerm (ShAAppl "FOL" [] []) att0
    HOL -> return $ addATerm (ShAAppl "HOL" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Atomic" [] _ -> (att0, Atomic)
    ShAAppl "Horn" [] _ -> (att0, Horn)
    ShAAppl "GHorn" [] _ -> (att0, GHorn)
    ShAAppl "FOL" [] _ -> (att0, FOL)
    ShAAppl "HOL" [] _ -> (att0, HOL)
    u -> fromShATermError "Formulas" u

instance ShATermConvertible Classes where
  toShATermAux att0 xv = case xv of
    NoClasses -> return $ addATerm (ShAAppl "NoClasses" [] []) att0
    SimpleTypeClasses ->
      return $ addATerm (ShAAppl "SimpleTypeClasses" [] []) att0
    ConstructorClasses ->
      return $ addATerm (ShAAppl "ConstructorClasses" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NoClasses" [] _ -> (att0, NoClasses)
    ShAAppl "SimpleTypeClasses" [] _ -> (att0, SimpleTypeClasses)
    ShAAppl "ConstructorClasses" [] _ -> (att0, ConstructorClasses)
    u -> fromShATermError "Classes" u

instance ShATermConvertible Sublogic where
  toShATermAux att0 xv = case xv of
    Sublogic a b c d e f g h -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      (att8, h') <- toShATerm' att7 h
      return $ addATerm (ShAAppl "Sublogic" [a', b', c', d', e', f', g',
                                             h'] []) att8
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sublogic" [a, b, c, d, e, f, g, h] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      case fromShATerm' h att7 of
      { (att8, h') ->
      (att8, Sublogic a' b' c' d' e' f' g' h') }}}}}}}}
    u -> fromShATermError "Sublogic" u
