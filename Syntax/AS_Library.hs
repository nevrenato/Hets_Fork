{- |
Module      :  $Header$
Description :  abstract syntax of CASL specification libraries
Copyright   :  (c) Klaus Luettich, Uni Bremen 2002-2006
License     :  GPLv2 or higher, see LICENSE.txt
Maintainer  :  till@informatik.uni-bremen.de
Stability   :  provisional
Portability :  non-portable(Grothendieck)

Abstract syntax of HetCASL specification libraries
   Follows Sect. II:2.2.5 of the CASL Reference Manual.
-}

module Syntax.AS_Library where

-- DrIFT command:
{-! global: GetRange !-}

import Common.Id
import Common.IRI
import Common.AS_Annotation
import Common.LibName

import Logic.Grothendieck (G_basic_spec)

import Syntax.AS_Architecture
import Syntax.AS_Structured

import Framework.AS
import Framework.ATC_Framework ()

data LIB_DEFN = Lib_defn LibName [Annoted LIB_ITEM] Range [Annotation]
                {- pos: "library"
                list of annotations is parsed preceding the first LIB_ITEM
                the last LIB_ITEM may be annotated with a following comment
                the first LIB_ITEM cannot be annotated -}
                deriving Show

{- for information on the list of Pos see the documentation in
   AS_Structured.hs and AS_Architecture.hs -}

data LIB_ITEM = Spec_defn SPEC_NAME GENERICITY (Annoted SPEC) Range
              -- pos: "spec", "=", opt "end"
              | View_defn VIEW_NAME GENERICITY VIEW_TYPE [G_mapping] Range
              -- pos: "view", ":", opt "=", opt "end"
              | Align_defn ALIGN_NAME (Maybe ALIGN_ARITIES) ALIGN_TYPE
                [CORRESPONDENCE] Range
              | Module_defn MODULE_NAME MODULE_TYPE RESTRICTION_SIGNATURE Range
              -- G_symb_items_list is RESTRICTION-SIGNATURE
              -- TODO: CONSERVATIVE?
              | Arch_spec_defn ARCH_SPEC_NAME (Annoted ARCH_SPEC) Range
              -- pos: "arch", "spec", "=", opt "end"
              | Unit_spec_defn SPEC_NAME UNIT_SPEC Range
              -- pos: "unit", "spec", "=", opt "end"
              | Ref_spec_defn SPEC_NAME REF_SPEC Range
              -- pos: "ref", "spec", "=", opt "end"
              | Download_items LibName DownloadItems Range
              -- pos: "from", "get", "|->", commas, opt "end"
              | Logic_decl Logic_name (Maybe SYNTAX_REF) Range
              -- pos:  "logic", Logic_name
              | Newlogic_defn LogicDef Range
              -- pos:  "newlogic", Logic_name, "=", opt "end"
              | Newcomorphism_defn ComorphismDef Range
              -- pos: "newcomorphism", Comorphism_name, "=", opt "end"
                deriving Show

{- Item maps are the documented CASL renamed entities whereas a unique item
contains the new target name of the single arbitrarily named item from the
downloaded library. -}
data DownloadItems =
    ItemMaps [ItemNameMap]
  | UniqueItem ItemName
    deriving Show

data GENERICITY = Genericity PARAMS IMPORTED Range deriving Show
                  -- pos: many of "[","]" opt ("given", commas)

emptyGenericity :: GENERICITY
emptyGenericity = Genericity (Params []) (Imported []) nullRange

data PARAMS = Params [Annoted SPEC] deriving Show

data IMPORTED = Imported [Annoted SPEC] deriving Show

data VIEW_TYPE = View_type (Annoted SPEC) (Annoted SPEC) Range deriving Show
                 -- pos: "to"

data ALIGN_TYPE = Align_type (Annoted SPEC) (Annoted SPEC) Range deriving Show

data MODULE_TYPE = Module_type (Annoted SPEC) (Annoted SPEC) Range deriving Show

data ALIGN_ARITIES = Align_arities ALIGN_ARITY ALIGN_ARITY deriving (Show, Eq)

data ALIGN_ARITY = AA_InjectiveAndTotal | AA_Injective | AA_Total
                 | AA_NeitherInjectiveNorTotal
                   deriving (Show, Eq)

type SYNTAX_REF = IRI

data ItemNameMap =
    ItemNameMap ItemName (Maybe ItemName)
    deriving (Show, Eq)

type ItemName = IRI

fromBasicSpec :: LibName -> SPEC_NAME -> G_basic_spec -> LIB_DEFN
fromBasicSpec ln sn gbs =
    let rg = nullRange
        sp = Basic_spec gbs rg
        mkAnno = emptyAnno
        li = Spec_defn sn emptyGenericity (mkAnno sp) rg
    in Lib_defn ln [mkAnno li] rg []

-- Generated by DrIFT, look but don't touch!

instance GetRange LIB_DEFN where
  getRange x = case x of
    Lib_defn _ _ p _ -> p
  rangeSpan x = case x of
    Lib_defn a b c d -> joinRanges [rangeSpan a, rangeSpan b,
                                    rangeSpan c, rangeSpan d]

instance GetRange LIB_ITEM where
  getRange x = case x of
    Spec_defn _ _ _ p -> p
    View_defn _ _ _ _ p -> p
    Align_defn _ _ _ _ p -> p
    Module_defn _ _ _ p -> p
    Arch_spec_defn _ _ p -> p
    Unit_spec_defn _ _ p -> p
    Ref_spec_defn _ _ p -> p
    Download_items _ _ p -> p
    Logic_decl _ _ p -> p
    Newlogic_defn _ p -> p
    Newcomorphism_defn _ p -> p
  rangeSpan x = case x of
    Spec_defn a b c d -> joinRanges [rangeSpan a, rangeSpan b,
                                     rangeSpan c, rangeSpan d]
    View_defn a b c d e -> joinRanges [rangeSpan a, rangeSpan b,
                                       rangeSpan c, rangeSpan d, rangeSpan e]
    Align_defn a b c d e -> joinRanges [rangeSpan a, rangeSpan b,
                                        rangeSpan c, rangeSpan d, rangeSpan e]
    Module_defn a b c d -> joinRanges [rangeSpan a, rangeSpan b,
                                       rangeSpan c, rangeSpan d]
    Arch_spec_defn a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                        rangeSpan c]
    Unit_spec_defn a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                        rangeSpan c]
    Ref_spec_defn a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                       rangeSpan c]
    Download_items a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                        rangeSpan c]
    Logic_decl a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                    rangeSpan c]
    Newlogic_defn a b -> joinRanges [rangeSpan a, rangeSpan b]
    Newcomorphism_defn a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange DownloadItems where
  getRange = const nullRange
  rangeSpan x = case x of
    ItemMaps a -> joinRanges [rangeSpan a]
    UniqueItem a -> joinRanges [rangeSpan a]

instance GetRange GENERICITY where
  getRange x = case x of
    Genericity _ _ p -> p
  rangeSpan x = case x of
    Genericity a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                    rangeSpan c]

instance GetRange PARAMS where
  getRange = const nullRange
  rangeSpan x = case x of
    Params a -> joinRanges [rangeSpan a]

instance GetRange IMPORTED where
  getRange = const nullRange
  rangeSpan x = case x of
    Imported a -> joinRanges [rangeSpan a]

instance GetRange VIEW_TYPE where
  getRange x = case x of
    View_type _ _ p -> p
  rangeSpan x = case x of
    View_type a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                   rangeSpan c]

instance GetRange ALIGN_TYPE where
  getRange x = case x of
    Align_type _ _ p -> p
  rangeSpan x = case x of
    Align_type a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                    rangeSpan c]

instance GetRange MODULE_TYPE where
  getRange x = case x of
    Module_type _ _ p -> p
  rangeSpan x = case x of
    Module_type a b c -> joinRanges [rangeSpan a, rangeSpan b,
                                     rangeSpan c]

instance GetRange ALIGN_ARITIES where
  getRange = const nullRange
  rangeSpan x = case x of
    Align_arities a b -> joinRanges [rangeSpan a, rangeSpan b]

instance GetRange ALIGN_ARITY where
  getRange = const nullRange
  rangeSpan x = case x of
    AA_InjectiveAndTotal -> []
    AA_Injective -> []
    AA_Total -> []
    AA_NeitherInjectiveNorTotal -> []

instance GetRange ItemNameMap where
  getRange = const nullRange
  rangeSpan x = case x of
    ItemNameMap a b -> joinRanges [rangeSpan a, rangeSpan b]
