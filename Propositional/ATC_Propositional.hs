{-# OPTIONS -w -O0 #-}
{- |
Module      :  Propositional/ATC_Propositional.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Propositional.Sign.Sign'
'Propositional.Morphism.Morphism'
'Propositional.AS_BASIC_Propositional.PRED_ITEM'
'Propositional.AS_BASIC_Propositional.BASIC_SPEC'
'Propositional.AS_BASIC_Propositional.BASIC_ITEMS'
'Propositional.AS_BASIC_Propositional.FORMULA'
'Propositional.AS_BASIC_Propositional.SYMB_ITEMS'
'Propositional.AS_BASIC_Propositional.SYMB'
'Propositional.AS_BASIC_Propositional.SYMB_MAP_ITEMS'
'Propositional.AS_BASIC_Propositional.SYMB_OR_MAP'
'Propositional.Symbol.Symbol'
'Propositional.Sublogic.PropFormulae'
'Propositional.Sublogic.PropSL'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Propositional/Sign.hs
Propositional/Morphism.hs
Propositional/AS_BASIC_Propositional.hs
Propositional/Symbol.hs
Propositional/Sublogic.hs
-}

module Propositional.ATC_Propositional () where

import ATC.AS_Annotation
import ATerm.Lib
import Common.AS_Annotation as AS_Anno
import Common.Doc
import Common.DocUtils
import Common.Id
import Common.Id as Id
import Common.Keywords
import Common.Result
import Data.Typeable
import Propositional.AS_BASIC_Propositional
import Propositional.Morphism
import Propositional.Morphism as Morphism
import Propositional.Sign
import Propositional.Sign as Sign
import Propositional.Sublogic
import Propositional.Symbol
import qualified Common.AS_Annotation as AS_Anno
import qualified Common.Id as Id
import qualified Common.Lib.State as State
import qualified Common.Result as Result
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Propositional.AS_BASIC_Propositional as AS_BASIC
import qualified Propositional.Morphism as Morphism
import qualified Propositional.Sign as Sign
import qualified Propositional.Symbol as Symbol
import qualified Propositional.Tools as Tools

{-! for Propositional.Sign.Sign derive : Typeable !-}
{-! for Propositional.Morphism.Morphism derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.PRED_ITEM derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.BASIC_SPEC derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.BASIC_ITEMS derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.FORMULA derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB_ITEMS derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB_MAP_ITEMS derive : Typeable !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB_OR_MAP derive : Typeable !-}
{-! for Propositional.Symbol.Symbol derive : Typeable !-}
{-! for Propositional.Sublogic.PropFormulae derive : Typeable !-}
{-! for Propositional.Sublogic.PropSL derive : Typeable !-}

{-! for Propositional.Sign.Sign derive : ShATermConvertible !-}
{-! for Propositional.Morphism.Morphism derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.PRED_ITEM derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.BASIC_SPEC derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.BASIC_ITEMS derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.FORMULA derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB_ITEMS derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB_MAP_ITEMS derive : ShATermConvertible !-}
{-! for Propositional.AS_BASIC_Propositional.SYMB_OR_MAP derive : ShATermConvertible !-}
{-! for Propositional.Symbol.Symbol derive : ShATermConvertible !-}
{-! for Propositional.Sublogic.PropFormulae derive : ShATermConvertible !-}
{-! for Propositional.Sublogic.PropSL derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcPRED_ITEMTc :: TyCon
_tcPRED_ITEMTc = mkTyCon "Propositional.AS_BASIC_Propositional.PRED_ITEM"
instance Typeable PRED_ITEM where
    typeOf _ = mkTyConApp _tcPRED_ITEMTc []

_tcBASIC_SPECTc :: TyCon
_tcBASIC_SPECTc = mkTyCon "Propositional.AS_BASIC_Propositional.BASIC_SPEC"
instance Typeable BASIC_SPEC where
    typeOf _ = mkTyConApp _tcBASIC_SPECTc []

_tcBASIC_ITEMSTc :: TyCon
_tcBASIC_ITEMSTc = mkTyCon "Propositional.AS_BASIC_Propositional.BASIC_ITEMS"
instance Typeable BASIC_ITEMS where
    typeOf _ = mkTyConApp _tcBASIC_ITEMSTc []

_tcFORMULATc :: TyCon
_tcFORMULATc = mkTyCon "Propositional.AS_BASIC_Propositional.FORMULA"
instance Typeable FORMULA where
    typeOf _ = mkTyConApp _tcFORMULATc []

_tcSYMB_ITEMSTc :: TyCon
_tcSYMB_ITEMSTc = mkTyCon "Propositional.AS_BASIC_Propositional.SYMB_ITEMS"
instance Typeable SYMB_ITEMS where
    typeOf _ = mkTyConApp _tcSYMB_ITEMSTc []

_tcSYMBTc :: TyCon
_tcSYMBTc = mkTyCon "Propositional.AS_BASIC_Propositional.SYMB"
instance Typeable SYMB where
    typeOf _ = mkTyConApp _tcSYMBTc []

_tcSYMB_MAP_ITEMSTc :: TyCon
_tcSYMB_MAP_ITEMSTc = mkTyCon "Propositional.AS_BASIC_Propositional.SYMB_MAP_ITEMS"
instance Typeable SYMB_MAP_ITEMS where
    typeOf _ = mkTyConApp _tcSYMB_MAP_ITEMSTc []

_tcSYMB_OR_MAPTc :: TyCon
_tcSYMB_OR_MAPTc = mkTyCon "Propositional.AS_BASIC_Propositional.SYMB_OR_MAP"
instance Typeable SYMB_OR_MAP where
    typeOf _ = mkTyConApp _tcSYMB_OR_MAPTc []

instance ShATermConvertible PRED_ITEM where
  toShATermAux att0 xv = case xv of
    Pred_item a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Pred_item" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Pred_item" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Pred_item a' b') }}
    u -> fromShATermError "PRED_ITEM" u

instance ShATermConvertible BASIC_SPEC where
  toShATermAux att0 xv = case xv of
    Basic_spec a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Basic_spec" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Basic_spec" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Basic_spec a') }
    u -> fromShATermError "BASIC_SPEC" u

instance ShATermConvertible BASIC_ITEMS where
  toShATermAux att0 xv = case xv of
    Pred_decl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Pred_decl" [a'] []) att1
    Axiom_items a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Axiom_items" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Pred_decl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Pred_decl a') }
    ShAAppl "Axiom_items" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Axiom_items a') }
    u -> fromShATermError "BASIC_ITEMS" u

instance ShATermConvertible FORMULA where
  toShATermAux att0 xv = case xv of
    False_atom a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "False_atom" [a'] []) att1
    True_atom a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "True_atom" [a'] []) att1
    Predication a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Predication" [a'] []) att1
    Negation a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Negation" [a', b'] []) att2
    Conjunction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Conjunction" [a', b'] []) att2
    Disjunction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Disjunction" [a', b'] []) att2
    Implication a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Implication" [a', b', c'] []) att3
    Equivalence a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Equivalence" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "False_atom" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, False_atom a') }
    ShAAppl "True_atom" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, True_atom a') }
    ShAAppl "Predication" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Predication a') }
    ShAAppl "Negation" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Negation a' b') }}
    ShAAppl "Conjunction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Conjunction a' b') }}
    ShAAppl "Disjunction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Disjunction a' b') }}
    ShAAppl "Implication" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Implication a' b' c') }}}
    ShAAppl "Equivalence" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Equivalence a' b' c') }}}
    u -> fromShATermError "FORMULA" u

instance ShATermConvertible SYMB_ITEMS where
  toShATermAux att0 xv = case xv of
    Symb_items a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Symb_items" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_items" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Symb_items a' b') }}
    u -> fromShATermError "SYMB_ITEMS" u

instance ShATermConvertible SYMB where
  toShATermAux att0 xv = case xv of
    Symb_id a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb_id" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_id" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb_id a') }
    u -> fromShATermError "SYMB" u

instance ShATermConvertible SYMB_MAP_ITEMS where
  toShATermAux att0 xv = case xv of
    Symb_map_items a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Symb_map_items" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_map_items" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Symb_map_items a' b') }}
    u -> fromShATermError "SYMB_MAP_ITEMS" u

instance ShATermConvertible SYMB_OR_MAP where
  toShATermAux att0 xv = case xv of
    Symb a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb" [a'] []) att1
    Symb_map a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Symb_map" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb a') }
    ShAAppl "Symb_map" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Symb_map a' b' c') }}}
    u -> fromShATermError "SYMB_OR_MAP" u

instance ShATermConvertible Morphism where
  toShATermAux att0 xv = case xv of
    Morphism a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Morphism" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Morphism a' b' c') }}}
    u -> fromShATermError "Morphism" u

_tcMorphismTc :: TyCon
_tcMorphismTc = mkTyCon "Propositional.Morphism.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tcMorphismTc []

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Sign" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Sign a') }
    u -> fromShATermError "Sign" u

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "Propositional.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible PropSL where
  toShATermAux att0 xv = case xv of
    PropSL a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PropSL" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PropSL" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PropSL a') }
    u -> fromShATermError "PropSL" u

instance ShATermConvertible PropFormulae where
  toShATermAux att0 xv = case xv of
    PlainFormula -> return $ addATerm (ShAAppl "PlainFormula" [] []) att0
    HornClause -> return $ addATerm (ShAAppl "HornClause" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PlainFormula" [] _ -> (att0, PlainFormula)
    ShAAppl "HornClause" [] _ -> (att0, HornClause)
    u -> fromShATermError "PropFormulae" u

_tcPropSLTc :: TyCon
_tcPropSLTc = mkTyCon "Propositional.Sublogic.PropSL"
instance Typeable PropSL where
    typeOf _ = mkTyConApp _tcPropSLTc []

_tcPropFormulaeTc :: TyCon
_tcPropFormulaeTc = mkTyCon "Propositional.Sublogic.PropFormulae"
instance Typeable PropFormulae where
    typeOf _ = mkTyConApp _tcPropFormulaeTc []

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "Propositional.Symbol.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Symbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symbol" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symbol a') }
    u -> fromShATermError "Symbol" u
