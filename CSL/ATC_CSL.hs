{-# OPTIONS -w -O0 #-}
{- |
Module      :  CSL/ATC_CSL.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'CSL.Sign.OpType'
'CSL.Sign.Sign'
'CSL.Morphism.Morphism'
'CSL.AS_BASIC_CSL.OP_ITEM'
'CSL.AS_BASIC_CSL.VAR_ITEM'
'CSL.AS_BASIC_CSL.BASIC_SPEC'
'CSL.AS_BASIC_CSL.GroundConstant'
'CSL.AS_BASIC_CSL.AssDefinition'
'CSL.AS_BASIC_CSL.InstantiatedConstant'
'CSL.AS_BASIC_CSL.BASIC_ITEM'
'CSL.AS_BASIC_CSL.EXTPARAM'
'CSL.AS_BASIC_CSL.EPDecl'
'CSL.AS_BASIC_CSL.EPVal'
'CSL.AS_BASIC_CSL.OPNAME'
'CSL.AS_BASIC_CSL.OPID'
'CSL.AS_BASIC_CSL.ConstantName'
'CSL.AS_BASIC_CSL.EXPRESSION'
'CSL.AS_BASIC_CSL.VarDecl'
'CSL.AS_BASIC_CSL.OpDecl'
'CSL.AS_BASIC_CSL.CMD'
'CSL.AS_BASIC_CSL.SYMB_ITEMS'
'CSL.AS_BASIC_CSL.SYMB'
'CSL.AS_BASIC_CSL.SYMB_MAP_ITEMS'
'CSL.AS_BASIC_CSL.SYMB_OR_MAP'
'CSL.AS_BASIC_CSL.BindInfo'
'CSL.AS_BASIC_CSL.OpInfo'
'CSL.Symbol.Symbol'
'CSL.TreePO.Incomparable'
'CSL.TreePO.SetOrdering'
'CSL.TreePO.InfDev'
'CSL.TreePO.CIType'
'CSL.TreePO.SetOrInterval'
'CSL.TreePO.ClosedInterval'
'CSL.TreePO.InfInt'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
CSL/Sign.hs
CSL/Morphism.hs
CSL/AS_BASIC_CSL.hs
CSL/Symbol.hs
CSL/TreePO.hs
-}

module CSL.ATC_CSL () where

import ATC.AS_Annotation
import ATerm.Lib
import CSL.AS_BASIC_CSL
import CSL.Morphism
import CSL.Print_AS ()
import CSL.Sign
import CSL.Sign as Sign
import CSL.Symbol
import CSL.TreePO
import CSL.TreePO (ClosedInterval (ClosedInterval))
import Common.AS_Annotation as AS_Anno
import Common.Doc
import Common.DocUtils
import Common.Id
import Common.Id as Id
import Common.Result
import Data.Maybe
import Data.Ratio
import Data.Typeable
import qualified Common.Result as Result
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for CSL.Sign.OpType derive : Typeable !-}
{-! for CSL.Sign.Sign derive : Typeable !-}
{-! for CSL.Morphism.Morphism derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.OP_ITEM derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.VAR_ITEM derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.BASIC_SPEC derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.GroundConstant derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.AssDefinition derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.InstantiatedConstant derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.BASIC_ITEM derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.EXTPARAM derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.EPDecl derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.EPVal derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.OPNAME derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.OPID derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.ConstantName derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.EXPRESSION derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.VarDecl derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.OpDecl derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.CMD derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.SYMB_ITEMS derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.SYMB derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.SYMB_MAP_ITEMS derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.SYMB_OR_MAP derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.BindInfo derive : Typeable !-}
{-! for CSL.AS_BASIC_CSL.OpInfo derive : Typeable !-}
{-! for CSL.Symbol.Symbol derive : Typeable !-}
{-! for CSL.TreePO.Incomparable derive : Typeable !-}
{-! for CSL.TreePO.SetOrdering derive : Typeable !-}
{-! for CSL.TreePO.InfDev derive : Typeable !-}
{-! for CSL.TreePO.CIType derive : Typeable !-}
{-! for CSL.TreePO.SetOrInterval derive : Typeable !-}
{-! for CSL.TreePO.ClosedInterval derive : Typeable !-}
{-! for CSL.TreePO.InfInt derive : Typeable !-}

{-! for CSL.Sign.OpType derive : ShATermConvertible !-}
{-! for CSL.Sign.Sign derive : ShATermConvertible !-}
{-! for CSL.Morphism.Morphism derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.OP_ITEM derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.VAR_ITEM derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.BASIC_SPEC derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.GroundConstant derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.AssDefinition derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.InstantiatedConstant derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.BASIC_ITEM derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.EXTPARAM derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.EPDecl derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.EPVal derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.OPNAME derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.OPID derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.ConstantName derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.EXPRESSION derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.VarDecl derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.OpDecl derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.CMD derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.SYMB_ITEMS derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.SYMB derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.SYMB_MAP_ITEMS derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.SYMB_OR_MAP derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.BindInfo derive : ShATermConvertible !-}
{-! for CSL.AS_BASIC_CSL.OpInfo derive : ShATermConvertible !-}
{-! for CSL.Symbol.Symbol derive : ShATermConvertible !-}
{-! for CSL.TreePO.Incomparable derive : ShATermConvertible !-}
{-! for CSL.TreePO.SetOrdering derive : ShATermConvertible !-}
{-! for CSL.TreePO.InfDev derive : ShATermConvertible !-}
{-! for CSL.TreePO.CIType derive : ShATermConvertible !-}
{-! for CSL.TreePO.SetOrInterval derive : ShATermConvertible !-}
{-! for CSL.TreePO.ClosedInterval derive : ShATermConvertible !-}
{-! for CSL.TreePO.InfInt derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible OpInfo where
  toShATermAux att0 xv = case xv of
    OpInfo a b c d e f -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      return $ addATerm (ShAAppl "OpInfo" [a', b', c', d', e',
                                           f'] []) att6
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpInfo" [a, b, c, d, e, f] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      (att6, OpInfo a' b' c' d' e' f') }}}}}}
    u -> fromShATermError "OpInfo" u

instance ShATermConvertible BindInfo where
  toShATermAux att0 xv = case xv of
    BindInfo a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "BindInfo" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "BindInfo" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, BindInfo a' b') }}
    u -> fromShATermError "BindInfo" u

instance ShATermConvertible SYMB_OR_MAP where
  toShATermAux att0 xv = case xv of
    Symb a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb" [a'] []) att1
    Symb_map a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Symb_map" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb a') }
    ShAAppl "Symb_map" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Symb_map a' b' c') }}}
    u -> fromShATermError "SYMB_OR_MAP" u

instance ShATermConvertible SYMB_MAP_ITEMS where
  toShATermAux att0 xv = case xv of
    Symb_map_items a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Symb_map_items" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_map_items" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Symb_map_items a' b') }}
    u -> fromShATermError "SYMB_MAP_ITEMS" u

instance ShATermConvertible SYMB where
  toShATermAux att0 xv = case xv of
    Symb_id a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symb_id" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_id" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symb_id a') }
    u -> fromShATermError "SYMB" u

instance ShATermConvertible SYMB_ITEMS where
  toShATermAux att0 xv = case xv of
    Symb_items a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Symb_items" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symb_items" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Symb_items a' b') }}
    u -> fromShATermError "SYMB_ITEMS" u

instance ShATermConvertible CMD where
  toShATermAux att0 xv = case xv of
    Ass a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Ass" [a', b'] []) att2
    Cmd a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Cmd" [a', b'] []) att2
    Sequence a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Sequence" [a'] []) att1
    Cond a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Cond" [a'] []) att1
    Repeat a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Repeat" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Ass" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Ass a' b') }}
    ShAAppl "Cmd" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Cmd a' b') }}
    ShAAppl "Sequence" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Sequence a') }
    ShAAppl "Cond" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Cond a') }
    ShAAppl "Repeat" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Repeat a' b') }}
    u -> fromShATermError "CMD" u

instance ShATermConvertible OpDecl where
  toShATermAux att0 xv = case xv of
    OpDecl a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "OpDecl" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpDecl" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, OpDecl a' b' c' d') }}}}
    u -> fromShATermError "OpDecl" u

instance ShATermConvertible VarDecl where
  toShATermAux att0 xv = case xv of
    VarDecl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "VarDecl" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "VarDecl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, VarDecl a' b') }}
    u -> fromShATermError "VarDecl" u

instance ShATermConvertible EXPRESSION where
  toShATermAux att0 xv = case xv of
    Var a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Var" [a'] []) att1
    Op a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Op" [a', b', c', d'] []) att4
    List a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "List" [a', b'] []) att2
    Interval a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Interval" [a', b', c'] []) att3
    Int a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Int" [a', b'] []) att2
    Rat a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Rat" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Var" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Var a') }
    ShAAppl "Op" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Op a' b' c' d') }}}}
    ShAAppl "List" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, List a' b') }}
    ShAAppl "Interval" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Interval a' b' c') }}}
    ShAAppl "Int" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Int a' b') }}
    ShAAppl "Rat" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Rat a' b') }}
    u -> fromShATermError "EXPRESSION" u

instance ShATermConvertible ConstantName where
  toShATermAux att0 xv = case xv of
    SimpleConstant a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SimpleConstant" [a'] []) att1
    ElimConstant a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ElimConstant" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SimpleConstant" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SimpleConstant a') }
    ShAAppl "ElimConstant" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ElimConstant a' b') }}
    u -> fromShATermError "ConstantName" u

instance ShATermConvertible OPID where
  toShATermAux att0 xv = case xv of
    OpId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpId" [a'] []) att1
    OpUser a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpUser" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpId a') }
    ShAAppl "OpUser" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpUser a') }
    u -> fromShATermError "OPID" u

instance ShATermConvertible OPNAME where
  toShATermAux att0 xv = case xv of
    OP_mult -> return $ addATerm (ShAAppl "OP_mult" [] []) att0
    OP_div -> return $ addATerm (ShAAppl "OP_div" [] []) att0
    OP_plus -> return $ addATerm (ShAAppl "OP_plus" [] []) att0
    OP_minus -> return $ addATerm (ShAAppl "OP_minus" [] []) att0
    OP_neg -> return $ addATerm (ShAAppl "OP_neg" [] []) att0
    OP_pow -> return $ addATerm (ShAAppl "OP_pow" [] []) att0
    OP_fthrt -> return $ addATerm (ShAAppl "OP_fthrt" [] []) att0
    OP_sqrt -> return $ addATerm (ShAAppl "OP_sqrt" [] []) att0
    OP_abs -> return $ addATerm (ShAAppl "OP_abs" [] []) att0
    OP_max -> return $ addATerm (ShAAppl "OP_max" [] []) att0
    OP_min -> return $ addATerm (ShAAppl "OP_min" [] []) att0
    OP_sign -> return $ addATerm (ShAAppl "OP_sign" [] []) att0
    OP_cos -> return $ addATerm (ShAAppl "OP_cos" [] []) att0
    OP_sin -> return $ addATerm (ShAAppl "OP_sin" [] []) att0
    OP_tan -> return $ addATerm (ShAAppl "OP_tan" [] []) att0
    OP_cot -> return $ addATerm (ShAAppl "OP_cot" [] []) att0
    OP_Pi -> return $ addATerm (ShAAppl "OP_Pi" [] []) att0
    OP_reldist -> return $ addATerm (ShAAppl "OP_reldist" [] []) att0
    OP_minimize -> return $ addATerm (ShAAppl "OP_minimize" [] []) att0
    OP_minloc -> return $ addATerm (ShAAppl "OP_minloc" [] []) att0
    OP_maximize -> return $ addATerm (ShAAppl "OP_maximize" [] []) att0
    OP_maxloc -> return $ addATerm (ShAAppl "OP_maxloc" [] []) att0
    OP_factor -> return $ addATerm (ShAAppl "OP_factor" [] []) att0
    OP_approx -> return $ addATerm (ShAAppl "OP_approx" [] []) att0
    OP_divide -> return $ addATerm (ShAAppl "OP_divide" [] []) att0
    OP_factorize -> return $ addATerm (ShAAppl "OP_factorize" [] []) att0
    OP_int -> return $ addATerm (ShAAppl "OP_int" [] []) att0
    OP_rlqe -> return $ addATerm (ShAAppl "OP_rlqe" [] []) att0
    OP_simplify -> return $ addATerm (ShAAppl "OP_simplify" [] []) att0
    OP_solve -> return $ addATerm (ShAAppl "OP_solve" [] []) att0
    OP_neq -> return $ addATerm (ShAAppl "OP_neq" [] []) att0
    OP_lt -> return $ addATerm (ShAAppl "OP_lt" [] []) att0
    OP_leq -> return $ addATerm (ShAAppl "OP_leq" [] []) att0
    OP_eq -> return $ addATerm (ShAAppl "OP_eq" [] []) att0
    OP_gt -> return $ addATerm (ShAAppl "OP_gt" [] []) att0
    OP_geq -> return $ addATerm (ShAAppl "OP_geq" [] []) att0
    OP_convergence -> return $ addATerm (ShAAppl "OP_convergence" [] []) att0
    OP_reldistLe -> return $ addATerm (ShAAppl "OP_reldistLe" [] []) att0
    OP_in -> return $ addATerm (ShAAppl "OP_in" [] []) att0
    OP_undef -> return $ addATerm (ShAAppl "OP_undef" [] []) att0
    OP_failure -> return $ addATerm (ShAAppl "OP_failure" [] []) att0
    OP_false -> return $ addATerm (ShAAppl "OP_false" [] []) att0
    OP_true -> return $ addATerm (ShAAppl "OP_true" [] []) att0
    OP_not -> return $ addATerm (ShAAppl "OP_not" [] []) att0
    OP_and -> return $ addATerm (ShAAppl "OP_and" [] []) att0
    OP_or -> return $ addATerm (ShAAppl "OP_or" [] []) att0
    OP_impl -> return $ addATerm (ShAAppl "OP_impl" [] []) att0
    OP_ex -> return $ addATerm (ShAAppl "OP_ex" [] []) att0
    OP_all -> return $ addATerm (ShAAppl "OP_all" [] []) att0
    OP_hastype -> return $ addATerm (ShAAppl "OP_hastype" [] []) att0
    OP_real -> return $ addATerm (ShAAppl "OP_real" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OP_mult" [] _ -> (att0, OP_mult)
    ShAAppl "OP_div" [] _ -> (att0, OP_div)
    ShAAppl "OP_plus" [] _ -> (att0, OP_plus)
    ShAAppl "OP_minus" [] _ -> (att0, OP_minus)
    ShAAppl "OP_neg" [] _ -> (att0, OP_neg)
    ShAAppl "OP_pow" [] _ -> (att0, OP_pow)
    ShAAppl "OP_fthrt" [] _ -> (att0, OP_fthrt)
    ShAAppl "OP_sqrt" [] _ -> (att0, OP_sqrt)
    ShAAppl "OP_abs" [] _ -> (att0, OP_abs)
    ShAAppl "OP_max" [] _ -> (att0, OP_max)
    ShAAppl "OP_min" [] _ -> (att0, OP_min)
    ShAAppl "OP_sign" [] _ -> (att0, OP_sign)
    ShAAppl "OP_cos" [] _ -> (att0, OP_cos)
    ShAAppl "OP_sin" [] _ -> (att0, OP_sin)
    ShAAppl "OP_tan" [] _ -> (att0, OP_tan)
    ShAAppl "OP_cot" [] _ -> (att0, OP_cot)
    ShAAppl "OP_Pi" [] _ -> (att0, OP_Pi)
    ShAAppl "OP_reldist" [] _ -> (att0, OP_reldist)
    ShAAppl "OP_minimize" [] _ -> (att0, OP_minimize)
    ShAAppl "OP_minloc" [] _ -> (att0, OP_minloc)
    ShAAppl "OP_maximize" [] _ -> (att0, OP_maximize)
    ShAAppl "OP_maxloc" [] _ -> (att0, OP_maxloc)
    ShAAppl "OP_factor" [] _ -> (att0, OP_factor)
    ShAAppl "OP_approx" [] _ -> (att0, OP_approx)
    ShAAppl "OP_divide" [] _ -> (att0, OP_divide)
    ShAAppl "OP_factorize" [] _ -> (att0, OP_factorize)
    ShAAppl "OP_int" [] _ -> (att0, OP_int)
    ShAAppl "OP_rlqe" [] _ -> (att0, OP_rlqe)
    ShAAppl "OP_simplify" [] _ -> (att0, OP_simplify)
    ShAAppl "OP_solve" [] _ -> (att0, OP_solve)
    ShAAppl "OP_neq" [] _ -> (att0, OP_neq)
    ShAAppl "OP_lt" [] _ -> (att0, OP_lt)
    ShAAppl "OP_leq" [] _ -> (att0, OP_leq)
    ShAAppl "OP_eq" [] _ -> (att0, OP_eq)
    ShAAppl "OP_gt" [] _ -> (att0, OP_gt)
    ShAAppl "OP_geq" [] _ -> (att0, OP_geq)
    ShAAppl "OP_convergence" [] _ -> (att0, OP_convergence)
    ShAAppl "OP_reldistLe" [] _ -> (att0, OP_reldistLe)
    ShAAppl "OP_in" [] _ -> (att0, OP_in)
    ShAAppl "OP_undef" [] _ -> (att0, OP_undef)
    ShAAppl "OP_failure" [] _ -> (att0, OP_failure)
    ShAAppl "OP_false" [] _ -> (att0, OP_false)
    ShAAppl "OP_true" [] _ -> (att0, OP_true)
    ShAAppl "OP_not" [] _ -> (att0, OP_not)
    ShAAppl "OP_and" [] _ -> (att0, OP_and)
    ShAAppl "OP_or" [] _ -> (att0, OP_or)
    ShAAppl "OP_impl" [] _ -> (att0, OP_impl)
    ShAAppl "OP_ex" [] _ -> (att0, OP_ex)
    ShAAppl "OP_all" [] _ -> (att0, OP_all)
    ShAAppl "OP_hastype" [] _ -> (att0, OP_hastype)
    ShAAppl "OP_real" [] _ -> (att0, OP_real)
    u -> fromShATermError "OPNAME" u

instance ShATermConvertible EPVal where
  toShATermAux att0 xv = case xv of
    EPVal a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EPVal" [a'] []) att1
    EPConstRef a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EPConstRef" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EPVal" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EPVal a') }
    ShAAppl "EPConstRef" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EPConstRef a') }
    u -> fromShATermError "EPVal" u

instance ShATermConvertible EPDecl where
  toShATermAux att0 xv = case xv of
    EPDecl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "EPDecl" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EPDecl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, EPDecl a' b' c') }}}
    u -> fromShATermError "EPDecl" u

instance ShATermConvertible EXTPARAM where
  toShATermAux att0 xv = case xv of
    EP a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "EP" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EP" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, EP a' b' c') }}}
    u -> fromShATermError "EXTPARAM" u

instance ShATermConvertible BASIC_ITEM where
  toShATermAux att0 xv = case xv of
    Op_decl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Op_decl" [a'] []) att1
    EP_decl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EP_decl" [a'] []) att1
    EP_domdecl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EP_domdecl" [a'] []) att1
    EP_defval a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EP_defval" [a'] []) att1
    Var_decls a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Var_decls" [a'] []) att1
    Axiom_item a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Axiom_item" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Op_decl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Op_decl a') }
    ShAAppl "EP_decl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EP_decl a') }
    ShAAppl "EP_domdecl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EP_domdecl a') }
    ShAAppl "EP_defval" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EP_defval a') }
    ShAAppl "Var_decls" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Var_decls a') }
    ShAAppl "Axiom_item" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Axiom_item a') }
    u -> fromShATermError "BASIC_ITEM" u

instance ShATermConvertible InstantiatedConstant where
  toShATermAux att0 xv = case xv of
    InstantiatedConstant a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "InstantiatedConstant" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "InstantiatedConstant" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, InstantiatedConstant a' b') }}
    u -> fromShATermError "InstantiatedConstant" u

instance ShATermConvertible AssDefinition where
  toShATermAux att0 xv = case xv of
    ConstDef a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ConstDef" [a'] []) att1
    FunDef a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FunDef" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ConstDef" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ConstDef a') }
    ShAAppl "FunDef" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FunDef a' b') }}
    u -> fromShATermError "AssDefinition" u

instance ShATermConvertible GroundConstant where
  toShATermAux att0 xv = case xv of
    GCI a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GCI" [a'] []) att1
    GCR a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "GCR" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "GCI" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GCI a') }
    ShAAppl "GCR" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, GCR a') }
    u -> fromShATermError "GroundConstant" u

instance ShATermConvertible BASIC_SPEC where
  toShATermAux att0 xv = case xv of
    Basic_spec a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Basic_spec" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Basic_spec" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Basic_spec a') }
    u -> fromShATermError "BASIC_SPEC" u

instance ShATermConvertible VAR_ITEM where
  toShATermAux att0 xv = case xv of
    Var_item a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Var_item" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Var_item" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Var_item a' b' c') }}}
    u -> fromShATermError "VAR_ITEM" u

instance ShATermConvertible OP_ITEM where
  toShATermAux att0 xv = case xv of
    Op_item a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Op_item" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Op_item" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Op_item a' b') }}
    u -> fromShATermError "OP_ITEM" u

_tcOpInfoTc :: TyCon
_tcOpInfoTc = mkTyCon "CSL.AS_BASIC_CSL.OpInfo"
instance Typeable OpInfo where
    typeOf _ = mkTyConApp _tcOpInfoTc []

_tcBindInfoTc :: TyCon
_tcBindInfoTc = mkTyCon "CSL.AS_BASIC_CSL.BindInfo"
instance Typeable BindInfo where
    typeOf _ = mkTyConApp _tcBindInfoTc []

_tcSYMB_OR_MAPTc :: TyCon
_tcSYMB_OR_MAPTc = mkTyCon "CSL.AS_BASIC_CSL.SYMB_OR_MAP"
instance Typeable SYMB_OR_MAP where
    typeOf _ = mkTyConApp _tcSYMB_OR_MAPTc []

_tcSYMB_MAP_ITEMSTc :: TyCon
_tcSYMB_MAP_ITEMSTc = mkTyCon "CSL.AS_BASIC_CSL.SYMB_MAP_ITEMS"
instance Typeable SYMB_MAP_ITEMS where
    typeOf _ = mkTyConApp _tcSYMB_MAP_ITEMSTc []

_tcSYMBTc :: TyCon
_tcSYMBTc = mkTyCon "CSL.AS_BASIC_CSL.SYMB"
instance Typeable SYMB where
    typeOf _ = mkTyConApp _tcSYMBTc []

_tcSYMB_ITEMSTc :: TyCon
_tcSYMB_ITEMSTc = mkTyCon "CSL.AS_BASIC_CSL.SYMB_ITEMS"
instance Typeable SYMB_ITEMS where
    typeOf _ = mkTyConApp _tcSYMB_ITEMSTc []

_tcCMDTc :: TyCon
_tcCMDTc = mkTyCon "CSL.AS_BASIC_CSL.CMD"
instance Typeable CMD where
    typeOf _ = mkTyConApp _tcCMDTc []

_tcOpDeclTc :: TyCon
_tcOpDeclTc = mkTyCon "CSL.AS_BASIC_CSL.OpDecl"
instance Typeable OpDecl where
    typeOf _ = mkTyConApp _tcOpDeclTc []

_tcVarDeclTc :: TyCon
_tcVarDeclTc = mkTyCon "CSL.AS_BASIC_CSL.VarDecl"
instance Typeable VarDecl where
    typeOf _ = mkTyConApp _tcVarDeclTc []

_tcEXPRESSIONTc :: TyCon
_tcEXPRESSIONTc = mkTyCon "CSL.AS_BASIC_CSL.EXPRESSION"
instance Typeable EXPRESSION where
    typeOf _ = mkTyConApp _tcEXPRESSIONTc []

_tcConstantNameTc :: TyCon
_tcConstantNameTc = mkTyCon "CSL.AS_BASIC_CSL.ConstantName"
instance Typeable ConstantName where
    typeOf _ = mkTyConApp _tcConstantNameTc []

_tcOPIDTc :: TyCon
_tcOPIDTc = mkTyCon "CSL.AS_BASIC_CSL.OPID"
instance Typeable OPID where
    typeOf _ = mkTyConApp _tcOPIDTc []

_tcOPNAMETc :: TyCon
_tcOPNAMETc = mkTyCon "CSL.AS_BASIC_CSL.OPNAME"
instance Typeable OPNAME where
    typeOf _ = mkTyConApp _tcOPNAMETc []

_tcEPValTc :: TyCon
_tcEPValTc = mkTyCon "CSL.AS_BASIC_CSL.EPVal"
instance Typeable EPVal where
    typeOf _ = mkTyConApp _tcEPValTc []

_tcEPDeclTc :: TyCon
_tcEPDeclTc = mkTyCon "CSL.AS_BASIC_CSL.EPDecl"
instance Typeable EPDecl where
    typeOf _ = mkTyConApp _tcEPDeclTc []

_tcEXTPARAMTc :: TyCon
_tcEXTPARAMTc = mkTyCon "CSL.AS_BASIC_CSL.EXTPARAM"
instance Typeable EXTPARAM where
    typeOf _ = mkTyConApp _tcEXTPARAMTc []

_tcBASIC_ITEMTc :: TyCon
_tcBASIC_ITEMTc = mkTyCon "CSL.AS_BASIC_CSL.BASIC_ITEM"
instance Typeable BASIC_ITEM where
    typeOf _ = mkTyConApp _tcBASIC_ITEMTc []

_tcInstantiatedConstantTc :: TyCon
_tcInstantiatedConstantTc = mkTyCon "CSL.AS_BASIC_CSL.InstantiatedConstant"
instance Typeable InstantiatedConstant where
    typeOf _ = mkTyConApp _tcInstantiatedConstantTc []

_tcAssDefinitionTc :: TyCon
_tcAssDefinitionTc = mkTyCon "CSL.AS_BASIC_CSL.AssDefinition"
instance Typeable AssDefinition where
    typeOf _ = mkTyConApp _tcAssDefinitionTc []

_tcGroundConstantTc :: TyCon
_tcGroundConstantTc = mkTyCon "CSL.AS_BASIC_CSL.GroundConstant"
instance Typeable GroundConstant where
    typeOf _ = mkTyConApp _tcGroundConstantTc []

_tcBASIC_SPECTc :: TyCon
_tcBASIC_SPECTc = mkTyCon "CSL.AS_BASIC_CSL.BASIC_SPEC"
instance Typeable BASIC_SPEC where
    typeOf _ = mkTyConApp _tcBASIC_SPECTc []

_tcVAR_ITEMTc :: TyCon
_tcVAR_ITEMTc = mkTyCon "CSL.AS_BASIC_CSL.VAR_ITEM"
instance Typeable VAR_ITEM where
    typeOf _ = mkTyConApp _tcVAR_ITEMTc []

_tcOP_ITEMTc :: TyCon
_tcOP_ITEMTc = mkTyCon "CSL.AS_BASIC_CSL.OP_ITEM"
instance Typeable OP_ITEM where
    typeOf _ = mkTyConApp _tcOP_ITEMTc []

_tcMorphismTc :: TyCon
_tcMorphismTc = mkTyCon "CSL.Morphism.Morphism"
instance Typeable Morphism where
    typeOf _ = mkTyConApp _tcMorphismTc []

instance ShATermConvertible Morphism where
  toShATermAux att0 xv = case xv of
    Morphism a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Morphism" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Morphism" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Morphism a' b' c') }}}
    u -> fromShATermError "Morphism" u

_tcOpTypeTc :: TyCon
_tcOpTypeTc = mkTyCon "CSL.Sign.OpType"
instance Typeable OpType where
    typeOf _ = mkTyConApp _tcOpTypeTc []

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "CSL.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible OpType where
  toShATermAux att0 xv = case xv of
    OpType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "OpType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OpType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, OpType a') }
    u -> fromShATermError "OpType" u

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Sign" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Sign a' b' c') }}}
    u -> fromShATermError "Sign" u

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "CSL.Symbol.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Symbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symbol" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symbol a') }
    u -> fromShATermError "Symbol" u

instance ShATermConvertible InfInt where
  toShATermAux att0 xv = case xv of
    PosInf -> return $ addATerm (ShAAppl "PosInf" [] []) att0
    NegInf -> return $ addATerm (ShAAppl "NegInf" [] []) att0
    FinInt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "FinInt" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PosInf" [] _ -> (att0, PosInf)
    ShAAppl "NegInf" [] _ -> (att0, NegInf)
    ShAAppl "FinInt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, FinInt a') }
    u -> fromShATermError "InfInt" u

instance ShATermConvertible a => ShATermConvertible (ClosedInterval a) where
  toShATermAux att0 xv = case xv of
    ClosedInterval a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ClosedInterval" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ClosedInterval" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ClosedInterval a' b') }}
    u -> fromShATermError "ClosedInterval" u

instance (Ord a,
          ShATermConvertible a) => ShATermConvertible (SetOrInterval a) where
  toShATermAux att0 xv = case xv of
    Set a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Set" [a'] []) att1
    IntVal a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "IntVal" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Set" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Set a') }
    ShAAppl "IntVal" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, IntVal a' b') }}
    u -> fromShATermError "SetOrInterval" u

instance ShATermConvertible a => ShATermConvertible (CIType a) where
  toShATermAux att0 xv = case xv of
    CIType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "CIType" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "CIType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, CIType a') }
    u -> fromShATermError "CIType" u

instance ShATermConvertible InfDev where
  toShATermAux att0 xv = case xv of
    EpsLeft -> return $ addATerm (ShAAppl "EpsLeft" [] []) att0
    Zero -> return $ addATerm (ShAAppl "Zero" [] []) att0
    EpsRight -> return $ addATerm (ShAAppl "EpsRight" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EpsLeft" [] _ -> (att0, EpsLeft)
    ShAAppl "Zero" [] _ -> (att0, Zero)
    ShAAppl "EpsRight" [] _ -> (att0, EpsRight)
    u -> fromShATermError "InfDev" u

instance ShATermConvertible SetOrdering where
  toShATermAux att0 xv = case xv of
    Comparable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Comparable" [a'] []) att1
    Incomparable a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Incomparable" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Comparable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Comparable a') }
    ShAAppl "Incomparable" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Incomparable a') }
    u -> fromShATermError "SetOrdering" u

instance ShATermConvertible Incomparable where
  toShATermAux att0 xv = case xv of
    Disjoint -> return $ addATerm (ShAAppl "Disjoint" [] []) att0
    Overlap -> return $ addATerm (ShAAppl "Overlap" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Disjoint" [] _ -> (att0, Disjoint)
    ShAAppl "Overlap" [] _ -> (att0, Overlap)
    u -> fromShATermError "Incomparable" u

_tcInfIntTc :: TyCon
_tcInfIntTc = mkTyCon "CSL.TreePO.InfInt"
instance Typeable InfInt where
    typeOf _ = mkTyConApp _tcInfIntTc []

_tcClosedIntervalTc :: TyCon
_tcClosedIntervalTc = mkTyCon "CSL.TreePO.ClosedInterval"
instance Typeable1 ClosedInterval where
    typeOf1 _ = mkTyConApp _tcClosedIntervalTc []

_tcSetOrIntervalTc :: TyCon
_tcSetOrIntervalTc = mkTyCon "CSL.TreePO.SetOrInterval"
instance Typeable1 SetOrInterval where
    typeOf1 _ = mkTyConApp _tcSetOrIntervalTc []

_tcCITypeTc :: TyCon
_tcCITypeTc = mkTyCon "CSL.TreePO.CIType"
instance Typeable1 CIType where
    typeOf1 _ = mkTyConApp _tcCITypeTc []

_tcInfDevTc :: TyCon
_tcInfDevTc = mkTyCon "CSL.TreePO.InfDev"
instance Typeable InfDev where
    typeOf _ = mkTyConApp _tcInfDevTc []

_tcSetOrderingTc :: TyCon
_tcSetOrderingTc = mkTyCon "CSL.TreePO.SetOrdering"
instance Typeable SetOrdering where
    typeOf _ = mkTyConApp _tcSetOrderingTc []

_tcIncomparableTc :: TyCon
_tcIncomparableTc = mkTyCon "CSL.TreePO.Incomparable"
instance Typeable Incomparable where
    typeOf _ = mkTyConApp _tcIncomparableTc []
