<?xml version="1.0" encoding="UTF-8"?>
<Worksheet><Version major="6" minor="0"/><View-Properties><Zoom percentage="100"/></View-Properties><Styles><Layout name="_pstyle262"/><Layout name="_pstyle261"/><Layout name="_pstyle260"/><Layout name="Normal"/><Layout name="_pstyle259"/><Layout name="_pstyle258"/><Layout name="_pstyle257"/><Layout name="_pstyle256"/><Font background="[0,0,0]" bold="true" executable="true" family="Monospaced" foreground="[255,0,0]" name="Maple Input"/><Font background="[0,0,0]" bold="false" family="Times New Roman" foreground="[0,0,0]" italic="false" name="Text" opaque="false" size="12" underline="false"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle262"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle261"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle260"/><Font background="[0,0,0]" name="Normal"/><Font background="[0,0,0]" family="Times New Roman" name="Page Number" underline="false"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle259"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle258"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle257"/><Font background="[0,0,0]" family="Times New Roman" name="_pstyle256"/></Styles><Page-Numbers enabled="false" first-number="1" first-numbered-page="1" horizontal-location="right" style="Page Number" vertical-location="bottom"/><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">restart;</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font bold="true" family="Times New Roman" size="14">intpakX v1.2 - Interval Arithmetic in Maple </Font><Font family="Times New Roman">

This is a new, integrated version of the Maple package intpakX for interval computations.
It integrates and updates the package</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">- intpak by R. Corless and A. Connell
and its extension
- intpakX by I. Geulig and W. Kraemer</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">intpakX v1.2 was written/updated by M. Grimmer.
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">intpakX v1.2 provides basic data types and operations for interval arithmetic as well as additional 
features for further interval computation.
Through this package, the features of the above mentioned packages are combined in one version.

v1.2 is an update of versions v1.0, v1.0.1, v1.1.

intpakX v1.2 (c) 2005 Scientific Computing/Software Engineering Research Group,
Department of Mathematics, University of Wuppertal, Germany</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
Contact: 
kraemer@math.uni-wuppertal.de
markus.grimmer@math.uni-wuppertal.de 
http://www.math.uni-wuppertal.de/wrswt</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Disclaimer: see end of module</Font></Text-field><Text-field layout="Normal" style="Normal"><Font executable="false" family="Times New Roman">###########################################################################
intpakX v1.2: New version of  intpakX incorporating minor changes, including:
- Modified graphics for interval newton with graphical output
 ("compute_all_zeros_with_plot" function)</Font><Font family="Times New Roman">

###########################################################################<Font bold="true" executable="false" size="14">
How to create the intpakX library from this worksheet </Font><Font bold="false" executable="false" size="14">and</Font><Font bold="true" executable="false" size="14">
How to load intpakX once the library has been created</Font>

Please see the last two sections of this worksheet for instructions on creating the package library 
from this worksheet and on starting off once the library has been created.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font executable="false" family="Times New Roman">###########################################################################
###########################################################################</Font><Font bold="true" family="Times New Roman" size="14">
intpakX v1.2 </Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################<Font executable="false">
Module header
###########################################################################</Font>
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">intpakX:=module()
export init,Evalf,min,intpakX_min,max,intpakX_max,ilog10,intpakX_ilog10,
  Interval_ulp,ulp,
  Interval_Round_Up,Interval_Round_Down,ru,rd,
  intpakX_greater,is_in,construct,expinfinity,
  Interval_exp,infinityln,`&amp;exp`,`&amp;ln`,
  Interval_ln,addinfinity,Interval_add,`&amp;+`,subtractinfinity,
  Interval_subtract,`&amp;-`,timesinfinity,Interval_times,`&amp;*`,
  Interval_reciprocal,inv,Interval_divide,`&amp;/`,sqrtinfinity,Interval_sqrt,`&amp;sqrt`,
  sqrinfinity,Interval_sqr,`&amp;sqr`,
  Interval_option_zero,powerinfinity,Interval_Integerpower,`&amp;intpower`,
  Interval_power,`&amp;**`,Interval_midpoint,midpoint,
  Interval_width,width,Interval_intersect,`&amp;intersect`,
  Interval_union,`&amp;union`,Interval_trig_ru,Interval_trig_rd,
  Interval_scale,Interval_range_values,Interval_sin,Interval_cos,Interval_tan,
  Interval_arcsin,Interval_arccos,Interval_arctan,Interval_hyp_rd,Interval_hyp_ru,
  Interval_cosh,Interval_sinh,Interval_tanh,`&amp;sin`,`&amp;cos`,`&amp;tan`,`&amp;arcsin`,
  `&amp;arccos`,`&amp;arctan`,`&amp;sinh`,`&amp;cosh`,`&amp;tanh`,
  ext_int_div,rel_diam,mid,compute_naive_interval_range,compute_mean_value_range,
  compute_monotonic_range,compute_combined_range,compute_taylor_form_range,`&amp;Convex_Hull`,
  subdivide_equidistant,subdivide_adaptive,interval_list_plot,compute_range,
  max_abs_error,cni_range3d,
  subdivide_equi3d,interval_list_plot3d,compute_range3d,newton,compute_all_zeros,newton_plot,
  newton_with_plot,compute_all_zeros_with_plot,
  `&amp;cabs`,complex_disc_plot,complex_polynom_plot,`&amp;cadd`,`&amp;csub`,`&amp;cmult`,`&amp;cdiv`,x0_start,
  `&amp;cmult_opt`,`&amp;cdiv_opt`,horner_eval_cent,horner_eval_opt,centred_form_eval,cexp;
option package;</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Name definitions (see below for body of corresponding procedures)</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input">min:=intpakX_min;
max:=intpakX_max; 
ilog10:=intpakX_ilog10;
width:=Interval_width;
ulp:=Interval_ulp;
ru:=Interval_Round_Up;
rd:=Interval_Round_Down;
`&amp;exp`:=Interval_exp;
`&amp;ln`:=Interval_ln;
`&amp;+`:=Interval_add;
`&amp;-`:=Interval_subtract;
`&amp;*`:=Interval_times;
inv:=Interval_reciprocal;
`&amp;/`:=Interval_divide;
`&amp;sqrt`:=Interval_sqrt;
`&amp;sqr`:=Interval_sqr;
`&amp;intpower`:=Interval_Integerpower;
`&amp;**`:=Interval_power;
midpoint:=Interval_midpoint;
`&amp;intersect`:=Interval_intersect;
`&amp;union`:=Interval_union;
`&amp;sin`:=Interval_sin;
`&amp;cos`:=Interval_cos;
`&amp;tan`:=Interval_tan;
`&amp;arcsin`:=Interval_arcsin;
`&amp;arccos`:=Interval_arccos;
`&amp;arctan`:=Interval_arctan;
`&amp;cosh`:=Interval_cosh;
`&amp;sinh`:=Interval_sinh;
`&amp;tanh`:=Interval_tanh;</Font><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Initialization </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The init procedure contains type definitions for the various (procedural) interval types.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">In Maple, type defintions must be global; they seemingly cannot be module exports.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">init:=proc()</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">global Interval_fnlist,`type/num_or_FAIL`,`type/interval_comp`,`type/interval`,
       `type/complex_disc`,`type/complex_interval`,`convert/interval`,inapply;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_fnlist:=[sqrt=`&amp;sqrt`,ln=`&amp;ln`,exp=`&amp;exp`,sin=`&amp;sin`,cos=`&amp;cos`,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    tan=`&amp;tan`,arcsin=`&amp;arcsin`,arccos=`&amp;arccos`,arctan=`&amp;arctan`,sinh=`&amp;sinh`,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input">    cosh=`&amp;cosh`];</Font><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  </Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   This type is included for ease of writing and clarity of code.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    `type/num_or_FAIL`:=proc(a)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    local bool,Constants:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Constants:={constants}:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    bool:=type(a,numeric) or a=-infinity or a=infinity or a=FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     or member(a,Constants):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    bool:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
  </Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   Simplified version of type interval_comp (cf. intpak/intpakX).
   Pi, gamma, Catalan, false, true are not allowed as interval borders.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    `type/interval_comp`:=proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         local bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         bool:=type(x,float) or x=FAIL or x=-infinity or x=infinity or x=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    end:
 </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
   PROCEDURE - TYPE/INTERVAL</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   This procedure defines the procedural type interval. 
   It tests an argument to see if it is an interval. An interval</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   is defined here to be a list with either zero elements,+/- infinity,FAIL</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   or a list with two floating point members.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font style="Maple Input">    `type/interval`:=proc(x)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       local bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       bool:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if type(x,list) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if nops(x) = 2 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if type(x[1],interval_comp) and type(x[2],interval_comp) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if intpakX_greater(x[2],x[1]) then bool:=true</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                elif x[1] = FAIL or x[2] = FAIL then bool:=true</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else ERROR(`enter the lowest endpoint first`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           elif nops(x)=0 then bool:=true</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
   PROCEDURE - TYPE/COMPLEX_DISC

   This procedure implements (i.e. tests an argument to be of) the procedural type complex disc
   for use in complex interval arithmetic.
   </Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    `type/complex_disc`:=proc(z)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         local bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         bool:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if type(z,list) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if nops(z)=3 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               if type(z[3],numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                  if z[3] &gt;= 0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                     bool:= type(z[1],numeric) and </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                            type(z[2],numeric);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                  fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
   PROCEDURE - TYPE/COMPLEX_INTERVAL

   This procedure implements (i.e. tests an argument to be of) the procedural type complex interval
   (~rectangular interval)
   for use in complex interval arithmetic.
   </Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    `type/complex_interval`:=proc(z)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       local bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       bool:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if type(z,list(interval)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if nops(z)=2 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if z[1]=[] then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                ERROR(`First Element of List must be a real interval.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif z[2]=[] then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                ERROR(`Second Element of List must be a real interval.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                bool:=type(z[1][1],numeric) and type(z[1][2],numeric) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   type(z[2][1],numeric) and type(z[2][2],numeric);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       bool;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    end:
    </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
   PROCEDURE `CONVERT/INTERVAL`
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   A utility program to convert Maple expressions to interval arithmetic.  
   convert(1+x + x^2,'interval') returns (1 &amp;+ x) &amp;+ (x &amp;^ 2),</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   whereas inapply(1+x+x^2,x) yields the operator x -&gt; (1 &amp;+ x) etc.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input">   `convert/interval`:=proc(e)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        local ope, mope, fn;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        # option system:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if type(e,interval) or type(e,interval_comp) then e;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(e,`+`) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if type(op(2,e),`*`) and op(1,op(2,e)) = (-1) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             `convert/interval`(op(1,e)) &amp;- `convert/interval`(op(1,e)-e);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             `convert/interval`(op(1,e)) &amp;+ `convert/interval`(e-op(1,e));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(e,`*`) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if op(1,e)=1.0 then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              `convert/interval`(subs(op(1,e)=1,e));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              `convert/interval`(op(1,e)) &amp;*</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    (`convert/interval`(e/op(1,e)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    ### WARNING: note that `I` is no longer of type `^`</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(e,`^`) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if type(op(2,e),posint) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               `convert/interval`(op(1,e)) &amp;intpower op(2,e);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            elif type(op(2,e),integer) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               inv(`convert/interval`(op(1,e)) &amp;intpower (-op(2,e)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            elif op(2,e)=(1/2) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               &amp;sqrt(`convert/interval`(op(1,e)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            else (`convert/interval`(op(1,e)) &amp;** `convert/interval`(op(2,e)))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(e,function) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            ope:=[op(e)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            mope:=op(map(`convert/interval`,ope));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fn:=subs(Interval_fnlist,op(0,e));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fn(mope):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else e</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    end:    </Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - in proc init  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
   PROCEDURE INAPPLY

  Converts the argument to an interval function.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    inapply := proc(); unapply(convert(args[1],'interval'),args[2..nargs]); end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">   -  - end proc init global type definitions  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    with(plots):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    with(geometry):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
macro(evalf=Evalf);
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">init();</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">#### end initialization</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Evalf := proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         local e;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             e := evalf(x); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if e = -1.*infinity then -infinity
             elif e = 1.*infinity then infinity
             else e fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">BASIC INTERVAL DEFINITIONS
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Definition of `type/num_or_FAIL`:</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">## see init procedure!</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Definition of `type/interval_comp`:</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">## see init procedure!</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_ulp := proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if x=0 then (0) else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Float(1,length(op(1,x))+op(2,x)-Digits)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_Round_Up := proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if x=-infinity then x</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else x + ulp(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_Round_Down := proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if x=-infinity then x</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif x=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else x - ulp(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Definition of `type/interval`:</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">## moved to init procedure!</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">OPERATOR &amp;GREATER/INTERVAL_GREATER

Checks if (Arg1&gt;=Arg2) applies.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">intpakX_greater:=proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local a_rational, b_rational;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if (a=FAIL) or (b=FAIL) then FAIL; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif not(type(a,numeric) or member(a,{infinity,-infinity})) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     ERROR(`first argument must be a numeric, FAIL, infinity or</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">-infinity`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif not(type(b,numeric) or member(b,{infinity,-infinity})) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   ERROR(`second argument must be a numeric, FAIL, infinity or</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">-infinity`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (a=infinity) then true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (b=-infinity) then true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (a = -infinity) then false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (b=infinity) then false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif a &gt; b then true</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,rational) and type(b,rational) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if a &gt;= b then true else false fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,rational) and type(b,float) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     b_rational:=op(1,b)*(10^(op(2,b)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if a &gt;= b_rational then true else false fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,float) and type(b,rational) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     a_rational:=op(1,a)*(10^(op(2,a)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if a_rational &gt;= b then true else false fi;      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,float) and type(b,float) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     a_rational:=op(1,a)*(10^(op(2,a)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     b_rational:=op(1,b)*(10^(op(2,b)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if a_rational &gt;= b_rational then true else false fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> PROCEDURE - IS_IN</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This procedure takes two parameters. It tests to see whether the interval,</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">or numeric x is contained in the interval a. If a is a float then</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">the procedure constructs an interval to test.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The operator &amp;greater/Interval_greater is used here.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">is_in:=proc(x,a)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(a,interval) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif x=infinity then member(infinity,{a[1],a[2]})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif x=-infinity then member(-infinity,{a[1],a[2]})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif not(type(x,{numeric,interval})) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            ERROR(`first argument must be a numeric or an interval`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif a=[] and x&lt;&gt;[] then false</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif a[1]=FAIL or a[2]=FAIL then FAIL </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(x,numeric) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          intpakX_greater(x,a[1]) and  intpakX_greater(a[2],x) </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(x,interval) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if x=[] then false #????????????</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         elif x[1]=FAIL or x[2]=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         else intpakX_greater(x[1],a[1]) and intpakX_greater(a[2],x[2]) </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif a=infinity then evalb(x=infinity)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif a=-infinity then evalb(x=-infinity) </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif a=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(a,numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if x=FAIL then FAIL </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         elif x=infinity or x=-infinity then false</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         elif type(x,numeric) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              intpakX_greater(a,x) and intpakX_greater(x,a);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         elif type(x,interval) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              if x=[] then false</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              else  intpakX_greater(x[1],a) and intpakX_greater(a,x[2])</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         else ERROR(`first argument must be a numeric or an interval`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else ERROR(`second argument must be an interval or a numeric`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE - CONSTRUCT</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This procedure can accept a single argument, to construct a degenerate</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">interval, two arguments, to construct an interval form the low/high</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">endpoints. The option `rounded` can be entered as the last argument in</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">each case to construct a rounded interval.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Special type checking is performed to find (Evalf(-infinity)). Where it</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">occurs as an argument, Evalf(-infinity) is always rounded to -infinity, to</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">eliminate Evalf(-infinity) from being an interval endpoint.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Suitable arguments are numeric, FAIL, +-infinity and constants.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">construct:=proc()</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local p,q,Constants;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if member(false,{args}) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      ERROR(`false and true ar not accepted as arguments`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if member(FAIL,{args}) then RETURN([FAIL,FAIL]) fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Constants:={Pi,gamma,Catalan};</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if nargs = 3 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if args[3] = 'rounded' and </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         type(args[1],num_or_FAIL) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         type(args[2],num_or_FAIL) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              p:=Evalf(args[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              q:=Evalf(args[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              [rd(intpakX_min(p,q)),ru(intpakX_max(p,q))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else ERROR(`first,second args must be numeric,third arg must be "rounded"`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif nargs=2 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if args[2]=rounded and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         type(args[1],num_or_FAIL) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [rd(Evalf(args[1])),ru(Evalf(args[1]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">      elif type(args[1],interval) and             #</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">           type(args[2],interval) then            #</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"><Font italic="false" size="12" underline="false">           &amp;Convex_Hull(args[1],args[2])          # new for v1.0.1 08.03.2004 M. Grimmer</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif type(args[1],num_or_FAIL) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           type(args[2],num_or_FAIL) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        p:=(args[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        q:=(args[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if member(p,Constants) and member(q,Constants)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        then construct(p,q,rounded);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif member(p,Constants) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if Evalf(p) &lt; q then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if intpakX_greater(Evalf(q),q) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   [rd(Evalf(p)),Evalf(q)]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else [rd(Evalf(p)),ru(Evalf(q))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif Evalf(p) &gt; q then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if intpakX_greater(q,Evalf(q)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   [Evalf(q),ru(Evalf(p))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else [rd(Evalf(q)),ru(Evalf(p))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             else construct(p,q,rounded);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif member(q,Constants) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if Evalf(q) &lt; p then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if intpakX_greater(Evalf(p),p) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   [rd(Evalf(q)),Evalf(p)]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else [rd(Evalf(q)),ru(Evalf(p))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif Evalf(q) &gt; p then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if intpakX_greater(p,Evalf(p)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   [Evalf(p),ru(Evalf(q))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else [rd(Evalf(p)),ru(Evalf(q))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             else construct(p,q,rounded);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif intpakX_greater(q,p) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if intpakX_greater(Evalf(q),q) and </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                intpakX_greater(p,Evalf(p)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 [Evalf(p),Evalf(q)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif intpakX_greater(Evalf(q),q) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                [rd(Evalf(p)),Evalf(q)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif intpakX_greater(p,Evalf(p)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 [Evalf(p),ru(Evalf(q))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             else [rd(Evalf(p)),ru(Evalf(q))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if intpakX_greater(Evalf(p),p) and </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                intpakX_greater(q,Evalf(q)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 [Evalf(q),Evalf(p)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif intpakX_greater(Evalf(p),p) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                [rd(Evalf(q)),Evalf(p)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif intpakX_greater(q,Evalf(q)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 [Evalf(q),ru(Evalf(p))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             else [rd(Evalf(q)),ru(Evalf(p))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else ERROR(`incorrect arguments entered`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif nargs=1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if type(args[1],num_or_FAIL) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p:=args[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if member(p,Constants) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [rd(Evalf(p)),ru(Evalf(p))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         elif is_in(p,Evalf(p)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [Evalf(p),Evalf(p)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         elif intpakX_greater(p,Evalf(p)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [Evalf(p),ru(Evalf(p))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         else [rd(Evalf(p)),Evalf(p)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else ERROR(`incorrect arguments entered`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else ERROR(`maximum of three arguments accepted`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:    </Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Logarithm and Exponential Functions:

PROCEDURE &amp;EXP/INTERVAL_EXP</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
 expinfinity is only called from &amp;exp. It deals with FAIL and +/- infinity.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> Like most of the other subroutines &amp;exp takes floating point intervals</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> or numerics (which are converted into intervals).
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">expinfinity:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=-infinity then 0</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else Evalf(exp(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input">Interval_exp:=proc(x):</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif x[1]=FAIL or x[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [rd(expinfinity(x[1])),ru(expinfinity(x[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(x,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_exp(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">         Return unevaluated.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    'Interval_exp(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">         ERROR(`floating point interval or scalar arguments are required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi: end:
</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">---------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> PROCEDURE  &amp;LN
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">infinityln:=proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=0 then -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (min(x,0)=x ) then FAIL</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
       The above line returns FAIL, as opposed to Maple`s ln function which</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">       returns an ERROR message stating that a singularity has been encountered.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else ln(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_ln:=proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [rd(infinityln(x[1])),ru(infinityln(x[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(x,'num_or_FAIL') then Interval_ln(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">        Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    'Interval_ln(x)' </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">        ERROR (`floating point intervals or scalars required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">---------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">BASIC INTERVAL ARITHMETIC OPERATIONS
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">All the interval arithmetic subroutines perform type checking.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">They accept scalars (of type numeric) or intervals (floating point).</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Floating point and integer scalars are made into intervals.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The ***infinity subroutines correct any problems that may occur with</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">infinite and FAIL results</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE  &amp;+
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">addinfinity:=proc(x,y)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if (x=infinity and y=(-infinity)) or (x=(-infinity) and y=infinity)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=FAIL or y=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=infinity or y=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=-infinity or y=-infinity then -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else x+y</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_add:=proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if type(a,'interval') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if a=[] or b=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [rd(addinfinity(a[1],b[1])),ru(addinfinity(a[2],b[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(a,'interval') and type(b,'num_or_FAIL') then Interval_add(a,construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(a,'num_or_FAIL') and type(b,'interval') then Interval_add(construct(a),b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(a,'num_or_FAIL') and type(b,'num_or_FAIL')</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    then Interval_add(construct(a),construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_add'(a,b)</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating point interval and scalar arguments required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;-</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">subtractinfinity:=proc(x,y)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if (x=infinity and y=(infinity)) or (x=(-infinity) and y=(-infinity))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=FAIL or y=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=infinity  then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif y=infinity then -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x=-infinity then -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif y=-infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else x-y</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_subtract := proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(a,'interval') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if a=[] or b=[] then [] else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    [rd(subtractinfinity(a[1],b[2])),ru(subtractinfinity(a[2],b[1]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'interval') and type(b,'num_or_FAIL')</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   then Interval_subtract(a,construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'num_or_FAIL') and type(b,'interval')</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   then Interval_subtract(construct(a),b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'num_or_FAIL') and type(b,'num_or_FAIL')</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   then Interval_subtract(construct(a),construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_subtract(a,b)'  </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> ERROR(`floating point interval and scalar arguments are required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE  &amp;*</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">timesinfinity:=proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if a=0 or b=0 then 0</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif a=FAIL or b=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (a=-infinity and min(b,0)=0) or (b=-infinity and min(a,0)=0)then -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (a=-infinity and min(b,0)=b) or (b=-infinity and min(a,0)=a) then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (a=infinity and min(b,0)=0) or (b=infinity and min(a,0)=0) then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif (a=infinity and min(b,0)=b) or (b=infinity and min(a,0)=a)then -infinity</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">the min function is called so that infinity*(-infinity) will give -infinity</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">if either of the arguments in Interval_times are FAIL the result will</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">be [FAIL,FAIL].</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The above code is long but takes into account every possibility.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else a*b</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_times := proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local xy,xY,Xy,XY:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(a,'interval') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if a=[] or b=[] then [] else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xy := timesinfinity(a[1],b[1]):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xY := timesinfinity(a[1],b[2]):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Xy := timesinfinity(a[2],b[1]):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       XY := timesinfinity(a[2],b[2]):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       [ rd(min(xy,xY,Xy,XY)),ru(max(xy,xY,Xy,XY))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(a,'interval') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Interval_times(a,construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(a,'num_or_FAIL') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Interval_times(construct(a),b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(a,'num_or_FAIL') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Interval_times(construct(a),construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    'Interval_times(a,b)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating point interval and scalar arguments are required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">---------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE   INV/INTERVAL_RECIPROCAL
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This procedure returns 1/infinity =0.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">If zero is contained in the denominator(interval) the procedure returns</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">[-infinity,infinity]</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_reciprocal := proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif x[1]=FAIL or x[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif is_in(0.0,x) then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif abs(x[1])=infinity and abs(x[2])=infinity then [0,0]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif abs(x[1])=infinity then [rd(1./x[2]),0]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif abs(x[2])=infinity then [0,ru(1./x[1])]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else  [rd(1./x[2]),ru(1./x[1])]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(x,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_reciprocal(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_reciprocal(x)' </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`a floating point interval or scalar argument is required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">----------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE   `&amp;/`/INTERVAL_DIVIDE</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
This procedure also performs type checking. A check is also done</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">to see if 0.0 is contained in the denominator. [-infinity,infinity] is</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">returned.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_divide := proc(a,b):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if type(a,'interval') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if a=[] or b=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif is_in(0.0,b) then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (abs(b[1])=infinity or abs(b[2])=infinity) and (abs(a[1])=infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         or abs(a[2])=infinity) then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else a &amp;* inv(b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(a,'interval') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  Interval_divide(a,construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(a,'num_or_FAIL') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_divide(construct(a),b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(a,'num_or_FAIL') and type(b,'num_or_FAIL')  then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_divide(construct(a),construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   'Interval_divide(a,b)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating point interval and scalar arguments are required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">---------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE  &amp;SQRT
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">An error message is returned if a negative argument is entered.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">sqrtinfinity:=proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif x=0 then 0</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif x=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif min(x,0)=x then ERROR (`cannot compute the sqrt of a negative number`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else sqrt(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_sqrt := proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x=[] then [] else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     [rd(sqrtinfinity(x[1])),ru(sqrtinfinity(x[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(x,'num_or_FAIL') then Interval_sqrt(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_sqrt(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating point interval or scalar argument is required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">----------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;SQR
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">sqrinfinity:=proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif abs(x)=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else x**2</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_sqr:=proc(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local a,b:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if x=[] then [] </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif is_in(0,x) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   [0,ru(max(sqrinfinity(x[1]),sqrinfinity(x[2])))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   a := min(abs(x[1]),abs(x[2])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   b := max(abs(x[1]),abs(x[2])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   [rd(sqrinfinity(a)),ru(sqrinfinity(b))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input"> fi:</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(x,'num_or_FAIL') then Interval_sqr(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_sqr(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR (`a floating point interval or scalar argument is required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_option_zero:=false:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
If option zero is true then 0**0=1</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">If Interval_option_zero is false then 0**0=FAIL.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This global variable can be changed by the user depending on which they</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">prefer. The disadvantage with the false case is that even if only one of</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">the endpoints is zero raised to zero, the resulting interval will</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">be [FAIL,FAIL].</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;INTPOWER / INTERVAL_INTEGERPOWER
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Integerpower: This takes interval or num_or_FAIL arguments, x, and raises</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">them to an integer power.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Powerinfinity is a subroutine used to evaluate such cases as</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">infinity**2 etc.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">powerinfinity:=proc(x,n)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if n=0 then 1.</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif n=infinity and min(x,0)=x then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif n=infinity then infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif n=-infinity then 0</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif x=0 then 0</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This is included to prevent error messages for such cases as 0**(-3)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif x=infinity then if n&gt;0 then infinity else 0 fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif x=-infinity then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if type(n/2,integer) and n&gt;0 then infinity else (-infinity) fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif x=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else x**n</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_Integerpower:=proc(x,n)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local a,b:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type (x,'interval') and type(n,integer) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    a:=powerinfinity(x[1],n):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    b:=powerinfinity(x[2],n):</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following is a check for monotonicity. If n is even and n&gt;0 then</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">if zero is in the interval it represents the lowest endpoint in the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">returned interval, and the the max endpoint is the max of x[1] and x[2]</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">to the power n.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Otherwise the function is monotonic, n&gt;0 and the endpoints are evaluated</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">directly for the maximum, and minimum values the function takes on the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">interval,x.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">If n&lt;0 and 0 is contained in the interval, x, then [-infinity,infinity]</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is returned. Otherwise the value of the two endpoints raised to the negative</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">power n are returned.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if n&lt;0 and type(n/2,integer) and is_in(0,x) then [rd(min(a,b)),infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif n&lt;0 and (not type(n/2,integer)) and is_in(0,x) then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif (n&lt;0) then [rd(min(a,b)),ru(max(a,b))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif n&gt;0 and type(n/2,integer) and is_in(0,x) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      [0,ru(max(a,b))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [rd(min(a,b)),ru(max(a,b))]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The else case covers n=0, n&gt;0 and odd (ie monotonic).</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(x,'num_or_FAIL') then Interval_Integerpower(construct(x),n)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_Integerpower(x,n)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">(`arg[1] must be a float interval or numeric, arg[2] must be an integer`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;** / INTERVAL_POWER</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This procedure calculates an interval raised to the power of another interval.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Digits is extended to reduce rounding error.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Note the conditions on the ops of x, that they be numeric, so that the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ilog10 function can be applied.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The procedure has been enhanced to accept numbers of type fraction as exponents.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_power:=proc(x,n)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local logx,prod,result,oldDigits;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(x,interval) and (type(n,interval) 
      or type(n,interval_comp) or type(n,fraction)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       oldDigits:=Digits;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if x = [] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif n = [] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif not(type(x[1],numeric) and type(x[2],numeric)) then Digits:=Digits</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif not type(x[1],numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            Digits:=Digits + 2 + intpakX_ilog10(x[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif not type(x[2],numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            Digits:=Digits + 2 + intpakX_ilog10(x[1])</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         Digits:=intpakX_max(intpakX_ilog10(x[1]),intpakX_ilog10(x[2])) + Digits + 2</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if type(n,interval) and (abs(n[1])=infinity or abs(n[2])=infinity) 
          and (x[1]=0 or x[2]=0) then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(n,interval_comp) and abs(n)=infinity and (x[1]=0 or x[2]=0) then 
            [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(n,interval) and (n[1]=0 or n[2]=0) and (x[1]=0 or x[2]=0) 
            and not Interval_option_zero then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(n,interval_comp) and n=0 and (x[1]=0 or x[2]=0) 
            and not Interval_option_zero then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(n,fraction) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if n=(1/2) then &amp;sqrt(x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                logx:=&amp;ln(x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                prod:=construct(n,rounded) &amp;* logx;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                result:=&amp;exp(prod);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                Digits:=oldDigits;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                construct(result[1],result[2],rounded)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             logx:=&amp;ln(x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             prod:=n &amp;* logx;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             result:= &amp;exp(prod);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             Digits:=oldDigits;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             construct(result[1],result[2],rounded)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(x,num_or_FAIL) then construct(x) &amp;** n</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(n,integer) then x &amp;intpower n</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else 'x &amp;** n'</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE MIDPOINT / INTERVAL_MIDPOINT
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_midpoint:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if x=[] then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif x[1]=FAIL or x[2]=FAIL then FAIL</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else (addinfinity(x[1],x[2]))&amp;/2.:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type (x,'num_or_FAIL') then Interval_midpoint(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_midpoint(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating interval or scalar argument required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE WIDTH / INTERVAL_WIDTH
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> Interval_width:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif x[1]=FAIL or x[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else subtractinfinity(x[2],x[1])</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(x,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if not (x=infinity or x=-infinity)  then 0</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else Interval_width(construct(x)) fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    'Interval_width(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating interval or scalar argument required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:
</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Union and Intersect
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;INTERSECT / INTERVAL_INTERSECT
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_intersect:=proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(a,'interval') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if a=[] or b=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif a[1]=FAIL or a[2]=FAIL or b[1]=FAIL or b[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (max(a[1],b[2])=a[1] and not a[1]=b[2])</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  or (max(b[1],a[2])=b[1] and not b[1]=a[2])  then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else [(max(a[1],b[1])),(min(a[2],b[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'num_or_FAIL') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_intersect(construct(a),b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'interval') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_intersect(a,construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'num_or_FAIL') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_intersect(construct(a),construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_intersect(a,b)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating point interval or scalar arguments required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;UNION / INTERVAL_UNION </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This accepts floating point interval or scalar arguments. If the intersection</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of the two arguments is the empty interval then the union of the two arguments</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">are the arguments themselves.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_union:=proc(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(a,'interval') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if a=[] then b</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif b=[] then a</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif a[1]=FAIL or a[2]=FAIL or b[1]=FAIL or b[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif &amp;intersect(a,b)=[] then RETURN(a,b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else [(min(a[1],b[1])),(max(a[2],b[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'num_or_FAIL') and type(b,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_union(construct(a),b)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a,'interval') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_union(a, construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(a, 'num_or_FAIL') and type(b,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   Interval_union(construct(a), construct(b))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_union(a,b)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`floating point interval or scalar arguments required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###############################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">TRIGONOMETRIC FUNCTIONS
(sin, cos, tan and corresponding arc and hyperbolic procedures)</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Auxiliary functions

The following two procedures are called from &amp;cos and &amp;sin to ensure</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">that the maximum and minimum the result can take are 1. and -1.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">There is no rounding out of 1. and -1.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_trig_ru:=proc(x) if x= 1. then  1. else ru(x) fi; end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_trig_rd:=proc(x) if x=-1. then -1. else rd(x) fi; end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following was written by Dr Dave Hare.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">intpakX_ilog10:=proc(x) if x=0 then 0 else length(op(1,x))+op(2,x)-1;  fi;  end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following code is similar to Dr Dave Hare's code for scaling in</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Maple's sin function, except the arguments are scaled down</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">as follows:</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">     k:=xx/2*Pi    and    x:=xx-2*Pi*k , where x is returned.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">In order that the shape of the interval be preserved, the arguments</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">are divided by 2*Pi.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The two endpoints of the interval argument, xx, are scaled to the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">same degree, to the minimum k value.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">After scaling the interval 'result' is rounded out.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_scale:=proc(xx)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> local k,x,d,k1,k2,mag_x1,mag_x2,mag_x,x1E,x2E,result,digits_orig:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> mag_x1:=ilog10(xx[1]):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> mag_x2:=ilog10(xx[2]):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> mag_x:=max(mag_x1,mag_x2):
 digits_orig:=Digits:                 # added 06/2005 for V.1.1., M. Grimmer</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if mag_x1 &gt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    d:=max(Digits, 2+mag_x):
    Digits:=Digits+d+mag_x:           # added 06/2005 for V.1.1., M. Grimmer</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    k1:=round(Evalf(xx[1]/(2*Pi),d)):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if mag_x2&gt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    d:=max(Digits,2+mag_x):
    Digits:=Digits+d+mag_x:           # added 06/2005 for V.1.1., M. Grimmer</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    k2:=round(Evalf(xx[2]/(2*Pi),d)):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if mag_x1&gt;=0  and mag_x2&gt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    k:=min(k1,k2):
    x1E:=Evalf((xx[1])-2*Pi*k,Digits+d+mag_x):  #
    x2E:=Evalf((xx[2])-2*Pi*k,Digits+d+mag_x):  #
    Digits:=digits_orig:                        #</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x[1]:=rd(x1E):                              #</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x[2]:=ru(x2E):                              #  modified 06/2005 for V.1.1., M. Grimmer</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    result:= [x[1],x[2]]:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else
    Digits:=digits_orig:              # added 06/2005 for V.1.1., M. Grimmer
    result:= [xx[1],xx[2]]:
 fi:
 result</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  Interval_range_values:=proc(x,y1,y2)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  local k1,k2,p1,p2,int:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following code is used to test for maxima and minima in the &amp;sin</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">and &amp;cos subroutines.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">(In order for this testing to work for &amp;cos, Pi/2 must first be added to the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">arguments. This is done in &amp;cos.)</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">First the number of the 2Pi interval, k, in which the endpoint occurs</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is assigned. The 2Pi intervals either side of x=zero have value k=0.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">In the positive x axis k&gt;=0 , in the negative x axis k&lt;=0. It is then</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">possible to compare the k1 and k2 values. Testing is done for both the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">positive and negative cases if abs(k2-k1)=1. If x[2]-x[1]&gt;=2*Pi then</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">obviously there is a maximum and a minimum in the interval and [-1.,1.]</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is returned.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      k1:=trunc(Evalf(x[1]/(2.*Pi))):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      k2:=trunc(Evalf(x[2]/(2.*Pi))):</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The interval(x) is scaled down to `int`. Int is then tested for containment</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of 1/4 and 3/4, those fractions of the 2*Pi interval at which the maxima and</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">minima occur.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      p1:=frac(Evalf(x[1]/(2.*Pi))):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      p2:=frac(Evalf(x[2]/(2.*Pi))):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      int:=construct(p1,p2):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if abs(x[1]-x[2])&gt;=Evalf(2*Pi) then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif abs(k2-k1)=1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if Evalf(x[1])&gt;=0 and Evalf(x[2])&gt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if p1&lt;=(1/4) then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;=(1/4) and p1&lt;=(3/4) and p2&gt;=1/4 then [-1.,1. ]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;=(1/4) and p1&lt;=3/4 and p2&lt;=(1/4) then [-1.,Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;=3/4 and p2&gt;=1/4 and p2&lt;=3/4 then [Interval_trig_rd(min(y1,y2)),1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;=3/4 and p2&gt;=3/4 then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;=3/4 and p2&lt;=1/4 then [rd(min(y1,y2)),ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The case for all negative endpoints</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif Evalf(x[1])&lt;=0 and Evalf(x[2])&lt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if p1&lt;=-3/4 then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;-3/4 and p1&lt;=-1/4 and p2&gt;=-3/4 then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;-3/4 and p1&lt;=-1/4 and p2&lt;=-3/4 then [-1.,ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;-1/4 and p2&gt;=-3/4 and p2&lt;=-1/4 then [rd(min(y1,y2)),1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;-1/4 and p2&gt;=-1/4 then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          elif p1&gt;-1/4 and p2&lt;=-3/4 then [rd(min(y1,y2)),ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This is the case for k values the same, on the positive x axis.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif x[1]&gt;=0 and x[2]&gt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if is_in(1/4,int) and is_in(3/4,int) then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(1/4,int) then [Interval_trig_rd(min(y1,y2)),1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(3/4,int) then [-1.,Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else [Interval_trig_rd(min(y1,y2)),Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This is the case for k values the same, on the negative x axis.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif x[1]&lt;=0 and x[2]&lt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if is_in(-3/4,int) and is_in(-1/4,int) then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(-3/4,int) then [Interval_trig_rd(min(y1,y2)),1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(-1/4,int) then [-1.,Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else [Interval_trig_rd(min(y1,y2)),Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This is the case for k values the same, 0, either side of x=0.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif x[1]&lt;=0 and x[2]&gt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if is_in(-3/4,int) or is_in(3/4,int) then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(-1/4,int) and is_in(1/4,int) then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(-1/4,int) then [-1.,Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif is_in(1/4,int) then [Interval_trig_rd(min(y1,y2)),1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else [Interval_trig_rd(min(y1,y2)),Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">--------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;SIN / INTERVAL_SIN
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This function accepts floating-point interval arguments, or floating point</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">or integer scalar arguments.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_sin:=proc(s)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local x,y1,y2:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type (s,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if s=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif s[1]=-infinity or s[2]=-infinity or s[1]=infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        or s[2]=infinity then  [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif s[1]=FAIL or s[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following test ensures that if the argument entered at either of the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">endpoints has error in its last digit, then if the ulp of the last digit is</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">greater than 2*Pi, [-1.,1.] is returned.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (ulp(s[1])/10.&gt;=Evalf(2*Pi) or ulp(s[2])/10.&gt;=Evalf(2*Pi)) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      not s[1]=s[2] then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:=Interval_scale(s):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    y1:=Evalf(sin(x[1])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    y2:=Evalf(sin(x[2])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_range_values(x,y1,y2):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(s,'num_or_FAIL') then Interval_sin(construct(s))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_sin(s)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(` floating point intervals or scalars required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">---------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;COS / INTERVAL_COS</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> </Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This function uses identical testing code from &amp;sin to test for maximas</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">and minimas by adding Pi/2 to the argument of the cos function.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This saves repetition of code that has already been written and tested.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The actual values of cos at the endpoints are calculated before the Pi/2 is</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">added. </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This function accepts floating point interval arguments, or floating point</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">or integer scalar arguments.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_cos:=proc(s)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local y1,y2,r,t,x:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type (s,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if s=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif s[1]=-infinity or s[2]=-infinity or s[1]=infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        or s[2]=infinity then  [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif s[1]=FAIL or s[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The same test as in &amp;sin occurs here.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (ulp(s[1])&gt;=Evalf(2*Pi) or ulp(s[2])&gt;=Evalf(2*Pi)) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   not s[1]=s[2]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  then [-1.,1.]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    r:=Interval_scale(s):</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Digits are increased for accuracy.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    t:=[Evalf(s[1]+Evalf(.5*Pi,Digits+3),Digits+3),Evalf(s[2]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            +Evalf(.5*Pi,Digits+3),Digits+3)]:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:=Interval_scale(t):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    y1:=Evalf(cos(r[1])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    y2:=Evalf(cos(r[2])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_range_values(x,y1,y2):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(s,'num_or_FAIL') then Interval_cos(construct(s))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_cos(s)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(` floating point intervals or scalars required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">--------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;TAN / INTERVAL_TAN
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This function accepts floating-point interval arguments, or floating point</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">or integer scalar arguments.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">For ease of testing, like &amp;cos, Pi/2 is added, with increased Digits.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">In the same way as for &amp;cos and &amp;sin, the interval is scaled down to a 2*Pi</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">interval and the k1 and k2 values are calculated.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The testing for this function is simpler than the &amp;sin and &amp;cos due</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">to the monotonicity of tan over the regions on which it is defined.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_tan:=proc(s)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local int,k1,k2,p1,p2,y1,y2,r,t,x:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type (s,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if s=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif s[1]=-infinity or s[2]=-infinity or s[1]=infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        or s[2]=infinity then  [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif s[1]=FAIL or s[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following test ensures that if the argument entered at either of the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">two endpoints (providing it's not a degenerate interval) has ulp greater than</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Pi then [-infinity,infinity] is returned.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (ulp(s[1])&gt;=Evalf(Pi) or ulp(s[2])&gt;=Evalf(Pi)) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      not s[1]=s[2] then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    r:=Interval_scale(s):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    t:=[Evalf(s[1]+Evalf(.5*Pi),Digits+3),Evalf(s[2]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            +Evalf(.5*Pi),Digits+3)]:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:=Interval_scale(t):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    y1:=Evalf(tan(r[1])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    y2:=Evalf(tan(r[2])):</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">First the number of the 2Pi interval, k, in which</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">the endpoint occurs is assigned. The 2Pi intervals either side of x=zero</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">have value k=0. In the positive x axis k&gt;=0 , in the negative x axis k&lt;=0.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">It is then possible to compare the k1 and k2 values.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    k1:=trunc(Evalf(x[1]/(2.*Pi))):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    k2:=trunc(Evalf(x[2]/(2.*Pi))):</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The fraction of the 2*Pi interval is then assigned.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The interval(x) is scaled down to `int`. Int is then tested for containment</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of 1/2, that fraction of the 2*Pi interval at which the singularity is</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">encountered. </Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    p1:=frac(Evalf(x[1]/(2.*Pi))):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    p2:=frac(Evalf(x[2]/(2.*Pi))):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    int:=construct(p1,p2):</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">If x[2]-x[1]&gt;=Pi then obviously there is a singularity encountered in the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">interval and [-infinity,infinity] is returned.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if abs(x[1]-x[2])&gt;=Evalf(Pi) then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif abs(k2-k1)=1 then [-infinity,infinity]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">After scaling, x=0 is a singularity.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif k1=0 and k2=0 and x[1]&lt;=0 and x[2]&gt;=0 then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif k1=k2 and x[1]&gt;=0 and x[2]&gt;=0 then</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">If one of the endpoints is a singularity , for example [-Pi/2,0], then</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">[-infinity,infinity] is returned.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if is_in(.5,int) or is_in (-.5,int) or is_in(0,int)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else [Interval_trig_rd(min(y1,y2)),Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif k1=k2 and x[1]&lt;=0 and x[2]&lt;=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if is_in(.5,int)  or is_in(-.5,int) or is_in (0,int)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         then [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else [Interval_trig_rd(min(y1,y2)), Interval_trig_ru(max(y1,y2))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(s,'num_or_FAIL') then Interval_tan(construct(s))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_tan(s)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(` floating point intervals or scalars required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;ARCSIN / INTERVAL_ARCSIN</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following simple function returns the rounded interval of the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">inverse sin function. The Maple V arcsin function carries one guard digit.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Here simply rounding the interval out ensures that the solution(s)</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is/are always contained in the interval.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The results returned are in the interval [-Pi/2,Pi/2].
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_arcsin:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type (x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif x[1]=FAIL or [2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The testing for the correct argument range is complicated by the possiblity</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of infinite arguments.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif (max(abs(x[1]),abs(1.))=abs(x[1]) and not (x[1]=1. or x[1]=-1.))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      or (max(abs(x[2]), abs(1.))=abs(x[2]) and not (x[2]=1. or x[2]=-1.)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         ERROR ( `the arguments must be in the range [-1.,1.]`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [rd(Evalf(arcsin(x[1]))),ru(Evalf(arcsin(x[2])))]:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(x,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_arcsin(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_arcsin(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(` floating point intervals or scalars required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;ARCCOS / INTERVAL_ARCCOS
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following simple function returns the rounded interval of the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">arccos function. The Maple V arccos function carries one guard digit.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Here simply rounding the interval out ensures that the solution(s)</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is/are always contained in the interval.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The results returned are in the interval [0, Pi].
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_arccos:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type (x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif x[1]=FAIL or [2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The testing for the correct argument range is complicated by the possiblity</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of infinite arguments.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif (max(abs(x[1]),abs(1.))=abs(x[1]) and not (x[1]=1. or x[1]=-1.))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      or (max(abs(x[2]), abs(1.))=abs(x[2]) and not (x[2]=1. or x[2]=-1.)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ERROR ( `the arguments must be in the range [-1.,1.]`)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [rd(Evalf(arccos(x[2]))),ru(Evalf(arccos(x[1])))]:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type(x,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_arccos(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_arccos(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(` floating point intervals or scalars required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;ARCTAN / INTERVAL_ARCTAN 
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following procedure calculates the range of the arctan function,</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">given the x coordinate and the y coordinate of a point.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The default value for x is 1, and the answer returned is in the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">[-Pi/2,Pi/2] interval. The arctan of the high and low endpoints of the</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">interval arguments are calculated. The rounded, widest possible interval</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is returned.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_arctan:=proc(y,x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">local a,b,c,d:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if nargs=2 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if type(y,'interval') and (type(x,'interval') or x=[1,1]) then</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The integer interval is needed for cases where only one argument is given</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">and [1,1] is the default value for the second argument. It is important for</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">cases involving infinity that the 1 be an integer as Maple's arctan function</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">returns cannot calculate such examples as arctan(infinity,1.0).</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This may be amended in the next version  of Maple, as a result of suggestions</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">to the writers of maple.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x[1]=FAIL or x[2]=FAIL or y[1]=FAIL or y[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       a:=Evalf(arctan(y[1],x[1])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       b:=Evalf(arctan(y[1],x[2])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       c:=Evalf(arctan(y[2],x[1])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       d:=Evalf(arctan(y[2],x[2])):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       [rd(min(a,b,c,d)),ru(max(a,b,c,d))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(y,'interval') and type(x,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_arctan(y,construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif (type(x,'interval') or x=[1,1]) and type(y,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_arctan(construct(y),x)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(x,'num_or_FAIL') and type(y,'num_or_FAIL') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Interval_arctan(construct(y),construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif nargs=1 then Interval_arctan(y,[1,1])</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_arctan(y,x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR(`up to two floating point interval or scalar arguments accepted`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Auxiliary procedures for sinh, cosh, tanh
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following rounding procedure ensure that the results of the hyperbolic</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">functions are always in the correct range. e.g. -1.&lt;= tanh(x) &lt;=1.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">1.&lt;=cosh(x).
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_hyp_rd:=proc(x); if x=-1. then x else rd(x) fi; end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_hyp_ru:=proc(x); if x= 1. then x else ru(x) fi; end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;COSH / INTERVAL_COSH </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following simple function returns the rounded interval result</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of the cosh function over an interval range. Maple's cosh function is</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">called. A check is done for the inclusion of 0, a minimum.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_cosh:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif x[1]=FAIL or x[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif is_in(0,x) then [1.,ru(Evalf(max(cosh(x[1]),cosh(x[2]))))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else [Interval_hyp_rd(Evalf(cosh(x[1]))),ru(Evalf(cosh(x[2])))]</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The absolute minimum of the cosh function is 1., so the lower endpoint is not</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">rounded below 1.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif type (x,'num_or_FAIL') then Interval_cosh(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_cosh(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR (`floating point interval or scalar argument required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;SINH / INTERVAL_SINH
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following simple function returns the rounded interval result</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of the sinh function over an interval range. Maple's sinh function</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is called.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_sinh:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif x[1]=FAIL or x[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else [rd(sinh(x[1])),ru(sinh(x[2]))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif  type(x,'num_or_FAIL') then Interval_sinh(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_sinh(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR (`floating point interval or scalar argument required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">------------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE &amp;TANH / INTERVAL_TANH</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman"> </Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The following simple function returns the rounded interval result</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of the tanh function over an interval range. Maple's tanh function</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">is called. Results are in the range [-1.,1.].</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">Interval_tanh:=proc(x):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if type(x,'interval') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if x=[] then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif x[1]=FAIL or x[2]=FAIL then [FAIL,FAIL]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else [Interval_hyp_rd(Evalf(tanh(x[1]))),Interval_hyp_ru(Evalf(tanh(x[2])))]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">elif  type(x,'num_or_FAIL') then Interval_tanh(construct(x))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">else </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Return unevaluated</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  'Interval_tanh(x)'</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ERROR (`floating point interval or scalar argument required`)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###############################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURES `CONVERT/INTERVAL` AND INAPPLY</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Definitions of `convert/interval` and inapply:</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">--&gt; moved to init procedure!</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###############################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Minimum and Maximum </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE MIN / INTPAKXI_MIN
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This is called from &amp;*, and numerous other procedures. It finds the minimum</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">of n arguments, of type(numeric) or infinity.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Note if one the n arguments given is FAIL then FAIL is returned
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">intpakX_min:=proc() local a,i,result:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  a:={args} minus {infinity}:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if nops(a)=0 then RETURN(infinity)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif member(FAIL,a) then RETURN (FAIL)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif member(-infinity,a) then RETURN (-infinity)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    result :=a[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    for i from 2 to nops(a) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">	if a[i]&lt;result then result := a[i] fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    od:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    result</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE MAX / INTPAKXI_MAX
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Note if FAIL is one of the n arguments given FAIL is returned.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">intpakX_max:=proc() local a,i,result:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   a:={args} minus {-infinity}:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if nops(a)=0 then RETURN(-infinity)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif member (FAIL,a) then RETURN(FAIL)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif member (infinity,a) then RETURN(infinity)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     result:=a[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     for i from 2 to nops(a) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if a[i]&gt;result then result:=a[i] fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     od:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    result</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">EXTENSIONS (from intpakX by I. Geulig and W. Kraemer)</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">03/2002: If there is any code or output in German left in this part, please contact me at</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">markus.grimmer@math.uni-wuppertal.de </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE EXT_INT_DIV

Extended Interval Division.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">ext_int_div:=proc(x,y)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if (type(x,interval) and type(y,interval)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if not( type(x[1],numeric) and type(x[2],numeric) ) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           ERROR(`first arg must be a finite interval or a numeric`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if not( type(y[1],numeric) and type(y[2],numeric) ) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           ERROR(`second arg must be a finite interval or a numeric`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if is_in(0,y) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if is_in(0,x) then          </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [-infinity,infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (y[1]=0) and (y[2]=0) then []</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (x[2]&lt;0) and (y[1]&lt;y[2]) and (y[2]=0) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [rd(x[2]/y[1]),infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (x[2]&lt;0) and (y[1]&lt;0) and (0&lt;y[2]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [-infinity,ru(x[2]/y[2])] &amp;union [rd(x[2]/y[1]),infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (x[2]&lt;0) and (0=y[1]) and (y[1]&lt;y[2]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [-infinity,ru(x[2]/y[2])]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (0&lt;x[1]) and (y[1]&lt;y[2]) and (y[2]=0) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [-infinity,ru(x[1]/y[1])]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (0&lt;x[1]) and (y[1]&lt;0) and (0&lt;y[2]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [-infinity,ru(x[1]/y[1])] &amp;union [rd(x[1]/y[2]),infinity]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif (0&lt;x[1]) and (0=y[1]) and (y[1]&lt;y[2]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           [rd(x[1]/y[2]),infinity];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     else (x &amp;/ y)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(x,num_or_FAIL) and type(y,interval) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ext_int_div(construct(x),y);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(x,interval) and type(y,num_or_FAIL) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ext_int_div(x,construct(y));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  elif type(x,num_or_FAIL) and type(y,num_or_FAIL) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ext_int_div(construct(x),construct(y));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else (x &amp;/ y)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE REL_DIAM

Relative Diameter of an interval.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">rel_diam:=proc(x::interval)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if x[1]=FAIL or x[2]=FAIL then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            ERROR(`Interval must be real.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if (-infinity &lt; x[1]) and (x[2] &lt; infinity) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               if is_in(0,x) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                  width(x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                  width(x) / (min(abs(x[1]),abs(x[2])));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               ERROR(`Interval must be real.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        end: </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE MID</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Midpoint of a real interval. The procedure returns a number which is guaranteed to be in the input interval.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">mid:=proc(z)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local m;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(z,interval) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if z=[] or z[1]=FAIL or z[2]=FAIL or </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       is_in(infinity,z) or is_in(-infinity,z) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        ERROR(` Parameter must be real Interval! `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if width(z)=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           m:=z[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           m:=z[1] + 0.5 * width(z);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if not( (z[1] &lt; m) and (m &lt; z[2])) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              m:=z[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(z,numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        m:=z;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        RETURN('mid(z)');</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   RETURN(m);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">RANGE ENCLOSURE WITH GRAPHICAL REPRESENTATION</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">FUNCTIONS OF ONE REAL VARIABLE</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_NAIVE_INTERVAL_RANGE

Range enclosure using interval evaluation.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_naive_interval_range:=proc(f,T)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     local F;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     F:=inapply(f(t),t);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     RETURN(F(T));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_MEAN_VALUE_RANGE

Range enclosure using mean value form.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font style="Maple Input">compute_mean_value_range:=proc(f,t_0,T)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local dF, F_Bound, MeanValueForm;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   dF:=inapply(diff(f(t),t),t);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   F_Bound:=dF(T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   MeanValueForm:=inapply(f(t),t)(t_0) &amp;+    (F_Bound &amp;* (T &amp;- t_0));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   RETURN(MeanValueForm);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_MONOTONIC_RANGE

Range Enclodure of a monotone twice continuously differentiable function.
If monotony cannot be proven, FAIL will be returned.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_monotonic_range:=proc(f,T::interval)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local df,dfBound,fLeft,fRight,c;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     df:=D(f);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     dfBound:=compute_naive_interval_range(df,T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fLeft:=compute_naive_interval_range(f,construct(T[1]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fRight:=compute_naive_interval_range(f,construct(T[2]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if dfBound[2] &lt;= 0. then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Function is monotonously decreasing</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN([fRight[1],fLeft[2]]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     elif 0. &lt;= dfBound[1] then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Function is monotonously increasing</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN([fLeft[1],fRight[2]]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     c:=T[1] + 0.5 * (T[2]-T[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     dfBound:=dfBound &amp;intersect compute_mean_value_range(df,c,T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if dfBound[2] &lt;= 0. then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Function is monotonously decreasing</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN([fRight[1],fLeft[2]]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     elif 0. &lt;= dfBound[1] then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Function is monotonously increasing</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN([fLeft[1],fRight[2]]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"># Monotony couldn't be proven</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     RETURN(FAIL)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMBINED_RANGE

Range enclosure combining the above three methods</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_combined_range:=proc(f,T)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local fBound,c;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fBound:=compute_monotonic_range(f,T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(fBound = FAIL) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN(fBound)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   c:=T[1] + 0.5*(T[2]-T[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fBound:=compute_naive_interval_range(f,T)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     &amp;intersect compute_mean_value_range(f,c,T); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   RETURN(fBound);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_TAYLOR_FORM_RANGE

Range enclosure using second order Taylor form
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_taylor_form_range:=proc(f,t_0,T)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local dF2, tf_bound, taylor_form;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   dF2:=inapply(diff(f(t),t$2),t);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   tf_bound:=dF2(T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   taylor_form:=inapply(f(t),t)(t_0) &amp;+</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                (inapply(diff(f(t),t),t)(t_0) &amp;* (T &amp;- t_0)) &amp;+</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                ((tf_bound &amp;/ 2) &amp;* ((T &amp;- t_0) &amp;intpower 2));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   RETURN(taylor_form);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURES &amp;CONVEX_HULL 

Computes convex hull of two intervals.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;Convex_Hull`:=proc(x::interval,y::interval)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   RETURN([min(x[1],y[1]),max(x[2],y[2])]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE SUBDIVIDE_EQUIDISTANT, SUBDIVIDE_ADAPTIVE

Methods for interval subdivision during the computation of range enclosures.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">subdivide_equidistant:=proc(f::{function,procedure},</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                            list_of_intervals::evaln,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                            list_of_ranges::evaln)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      local N, n, i, iter_counter, T, T1, T2, F1, F2, temp, t_mid,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            temp_list_of_intervals, temp_list_of_ranges;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      N:=3;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if not(type(eval(list_of_intervals),listlist)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         lprint(`Second Parameter must be list of intervals!`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         T:=readstat(`Enter Start interval: `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         list_of_intervals:=[construct(T[1],T[2])];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      n:=nops(eval(list_of_intervals));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_list_of_intervals:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_list_of_ranges:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        T:=list_of_intervals[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      # Bisection of current interval</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        t_mid:=T[1] + 0.5*(T[2]-T[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        T1:=construct(T[1],t_mid);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        T2:=construct(t_mid,T[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      
      # Optional 4th parameter: Iteration counter iter_counter
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if (nargs &gt;= 4) and (type(args[4],nonnegint)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           iter_counter:=args[4];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           iter_counter:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if iter_counter &lt;= N then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          F1:=compute_naive_interval_range(f,T1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          F2:=compute_naive_interval_range(f,T2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         F1:=compute_combined_range(f,T1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         F2:=compute_combined_range(f,T2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                                              </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       temp_list_of_intervals:=[op(temp_list_of_intervals),T1,T2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       temp_list_of_ranges:=[op(temp_list_of_ranges),F1,F2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      od:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      list_of_intervals:=[op(temp_list_of_intervals)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      list_of_ranges:=[op(temp_list_of_ranges)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp:=list_of_ranges[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      for i from 2 to nops(eval(list_of_ranges)) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          temp:=&amp;Convex_Hull(temp,list_of_ranges[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN(temp);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">     -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">subdivide_adaptive:=proc(f::{function,procedure},</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                         list_of_intervals::evaln,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                         list_of_ranges::evaln)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      local N, n, iter_counter, temp_max, temp_min,i, T, T1, T2,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            F1, F2, temp, t_mid, temp_list_of_intervals,            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            temp_list_of_ranges, eps;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      N:=3;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if not(type(eval(list_of_intervals),listlist)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         lprint(`Second parameter must be list of intervals!`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         T:=readstat(`Enter start interval: `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         T:=construct(T[1],T[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         list_of_intervals:=[T];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         list_of_ranges:=[compute_naive_interval_range(f,T)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      n:=nops(eval(list_of_intervals));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if nops(eval(list_of_ranges)) &lt; n then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         ERROR(`Second list is too short!`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_min:=min(seq(list_of_ranges[i][1],i=1..n));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_max:=max(seq(list_of_ranges[i][2],i=1..n));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      eps:=0.1*width(construct(temp_min,temp_max));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_list_of_intervals:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_list_of_ranges:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        T:=list_of_intervals[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
     # If T satisfies the selection criterion, T will be subdivided into halves</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if (list_of_ranges[i][1] &lt;= temp_min + eps) or </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           (list_of_ranges[i][2] &gt;= temp_max -eps ) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           # Bisection of current interval</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           t_mid:=T[1] + 0.5*(T[2] - T[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           T1:=construct(T[1],t_mid);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           T2:=construct(t_mid,T[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if (nargs &gt;= 4) and (type(args[4],nonnegint)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           iter_counter:=args[4];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           iter_counter:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if iter_counter &lt;= N then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              F1:=compute_naive_interval_range(f,T1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              F2:=compute_naive_interval_range(f,T2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              F1:=compute_combined_range(f,T1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              F2:=compute_combined_range(f,T2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           temp_list_of_intervals:=[op(temp_list_of_intervals),</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                                   T1,T2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           temp_list_of_ranges:=[op(temp_list_of_ranges),F1,F2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           temp_list_of_intervals:=[op(temp_list_of_intervals),T];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           temp_list_of_ranges:=[op(temp_list_of_ranges),</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                                   list_of_ranges[i]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      od:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      list_of_intervals:=[op(temp_list_of_intervals)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      list_of_ranges:=[op(temp_list_of_ranges)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp:=list_of_ranges[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      for i from 2 to nops(eval(list_of_ranges)) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          temp:=&amp;Convex_Hull(temp,list_of_ranges[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN(temp);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE INTERVAL_LIST_PLOT</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">interval_list_plot:=proc(interval_list::list(list(numeric)),</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                         range_list::list(list(numeric)))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     local n, i, T, F, c, opts, p;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if nops(interval_list) &gt; nops(range_list) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ERROR(`Second list is too short!`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     opts:=[args[3..nargs]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     n:=nops(interval_list);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        T:=interval_list[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        F:=range_list[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        c:=plottools[rectangle]([T[1],F[2]],[T[2],F[1]]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        p[i]:=display(c,op(opts));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  RETURN(display([seq(p[i],i=1..n)]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_RANGE</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_range:=proc(f::{function,procedure},xstart,iterationsteps::nonnegint)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    global list_of_intervals, list_of_ranges, max_iter_counter, q, </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r, iter_counter;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    local T, F, S, xrange, i, m, nx, h, arg_list, conv_linear,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          conv_quadratic, div_adaptive, c_list, j,x;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Initialization of global variables</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:='x';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(simplify(f(x)),numeric) or (simplify(diff(f(x),x)) = 0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`Function is constant = `, simplify(f(x)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(xstart,{interval,numeric..numeric}) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       T:=construct(op(1,xstart),op(2,xstart));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(xstart,{identical('X'),identical('x')} = {interval,numeric..numeric}) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       T:=construct(op(1,rhs(xstart)),op(2,rhs(xstart)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ERROR(`Second argument must be an interval or a range.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(type(compute_naive_interval_range(f,T),interval)) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ERROR(`First argument must be function in one real variable with real values.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    list_of_intervals:=[T];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    max_iter_counter:=iterationsteps; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    nx:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    conv_linear:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    conv_quadratic:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    div_adaptive:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    arg_list:=[args[4..nargs]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    for i from 1 to  nops(arg_list) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if type(arg_list[i],identical('Nx') = nonnegint) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         nx:=rhs(arg_list[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif arg_list[i] = 'linear' then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         conv_linear:=true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif (arg_list[i] = 'quadratic') or (arg_list[i] = 'quadratisch') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         conv_quadratic:=true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif (arg_list[i] = 'adaptive') or (arg_list[i] = 'adaptiv') then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         div_adaptive:=true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif type(arg_list[i],identical('colorlist') = list) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         c_list:=rhs(arg_list[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if conv_quadratic then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       F:=compute_combined_range(f,T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`Start range enclosure =  `,F);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       list_of_ranges:=[F];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r[0]:=F;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        F:=compute_naive_interval_range(f,T);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        lprint(`Start range enclosure =  `,F);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        list_of_ranges:=[F];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        r[0]:=F;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"># Subdivision of Start interval in Nx subparts,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"># given the optional parameter Nx</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if nx &gt; 1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       h:=width(T)/nx;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       list_of_intervals:=[seq([T[1] + (i-1)*h, T[1] + i*h],i=1..nx)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if conv_quadratic then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         list_of_ranges:=[seq(compute_combined_range(f,S),S=list_of_intervals)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         list_of_ranges:=[seq(compute_naive_interval_range(f,S),S=list_of_intervals)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r[0]:=[min(seq(list_of_ranges[i][1],i=1..nx)),              </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              max(seq(list_of_ranges[i][2],i=1..nx))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       printf(`%s %d %s = \n[%.10g,%.10g]\n`,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              `Range enclosure after subdivision into `,nx,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              ` intervals`,r[0][1],r[0][2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    xrange:=T[1]..T[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Colour list for graphical representation</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if c_list = 'c_list' then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       c_list:=[blue,red];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    q[0]:=interval_list_plot(list_of_intervals,list_of_ranges,color=c_list[1],</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           style=line,thickness=2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:='x';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    q[max_iter_counter+1]:=plot(f(x),x=xrange,color=black,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                                numpoints=500,linestyle=1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Iteration</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    iter_counter:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    for i from 1 to  max_iter_counter do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        iter_counter:=iter_counter + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if conv_linear then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if div_adaptive then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r[i]:=subdivide_adaptive(f,list_of_intervals,list_of_ranges);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r[i]:=subdivide_equidistant(f,list_of_intervals,list_of_ranges);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        elif conv_quadratic then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if div_adaptive then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r[i]:=subdivide_adaptive(f,list_of_intervals,list_of_ranges,100);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r[i]:=subdivide_equidistant(f,list_of_intervals,list_of_ranges,100);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if div_adaptive then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r[i]:=subdivide_adaptive(f,list_of_intervals,list_of_ranges,i);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r[i]:=subdivide_equidistant(f,list_of_intervals,list_of_ranges,i);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        j:= (i mod nops(c_list)) + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if i &lt; max_iter_counter then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          q[i]:=interval_list_plot(list_of_intervals,list_of_ranges,color=c_list[j],</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      style=line,thickness=2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          q[i]:=interval_list_plot(list_of_intervals,list_of_ranges,color=yellow,style=patch);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    m:=max_iter_counter;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    printf(`%s %s %s %d = %s[%.10g,%.10g]\n`,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Range_enclosure ,after,step,m,` `,r[m][1],r[m][2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"># Graphical representation of the last three steps of the iteration</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if m &lt;= 1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      display([seq(q[i],i=0..(m+1))],axes=framed,
           title=`Iterative range enclosure of f`,titlefont=[TIMES,BOLD,12]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      display([seq(q[i],i=(m-2)..m),q[m+1]],axes=framed,
           title=`Iterative range enclosure of f`,titlefont=[TIMES,BOLD,12]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
 </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE MAX_ABS_ERROR
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">max_abs_error:=proc(list_of_ranges::list(interval))</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  local index_of_max, index_of_min,temp_max,temp_min, n, i, new_list;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  index_of_max:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  index_of_min:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  n:=nops(list_of_ranges);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if n=0 or (n=1 and list_of_ranges[1]=[]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     ERROR(`Input parameter must contain at least one real interval. `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  temp_max:=list_of_ranges[1][2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  temp_min:=list_of_ranges[1][1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if list_of_ranges[i][2] &gt; temp_max then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        temp_max:=list_of_ranges[i][2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        index_of_max:=i;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     if list_of_ranges[i][1] &lt; temp_min then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        temp_min:=list_of_ranges[i][1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        index_of_min:=i;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   temp_max:=list_of_ranges[index_of_max][1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   temp_min:=list_of_ranges[index_of_min][2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if temp_min &gt; temp_max then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     RETURN(max(seq(width(list_of_ranges[i]),i=1..n)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     new_list:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if is_in(list_of_ranges[i],[temp_min,temp_max]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           next;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           new_list:=[op(new_list),list_of_ranges[i]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      n:=nops(new_list);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      lprint(`Number of intervals: `,n);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN(max(seq(width(new_list[i]),i=1..nops(new_list))));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">FUNCTIONS OF TWO  REAL VARIABLES</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE CNI_RANGE3D</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Interval evaluation of a function f: R^2 -&gt; R.
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">cni_range3d:=proc(f,T,S)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  local F;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  F:=inapply(f(t,s),t,s);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  RETURN(F(T,S));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">The procedure subdivide_equi3d computes a range enclosure for a function of two real variables by 
subdivision of the intervals in list_of_intervals2d in two intervals each. If k is odd, subdivision is 
performed in x direction, if k is even, subdivision is performed in y direction.</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">An element of the global variable list_of_intervals2d should be a two dimensional interval, defined as
a list of two intervals, i.e. XY:=[[x1,x2],[y1,y2]].
The variable list_of_ranges contains the range enclosures
for the corresponding (sub-)intervals in list_of_intervals2d.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">subdivide_equi3d:=proc(f,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                       list_of_intervals2d::evaln, </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                       list_of_ranges::evaln,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                       k::nonnegint)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local n, i, temp_loi, temp_lor, TS, T, S, T1, T2, S1, S2, F1, F2,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         F3, F4, t_mid, s_mid, temp;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  if not(type(eval(list_of_intervals2d),listlist)) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    TS:=readstat(`Enter two-dimensional start interval [[x1,x2],[y1,y2]]:`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    T:=construct(TS[1][1],TS[1][2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    S:=construct(TS[2][1],TS[2][2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    list_of_intervals2d:=[[T,S]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    list_of_ranges:=[cni_range3d(f,T,S)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  n:=nops(eval(list_of_ranges));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  temp_loi:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  temp_lor:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    TS:=list_of_intervals2d[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    T:=TS[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    S:=TS[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(k,odd) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      t_mid:=T[1] + 0.5*(T[2] - T[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      T1:=construct(T[1],t_mid);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      T2:=construct(t_mid,T[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      F1:=cni_range3d(f,T1,S);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      F2:=cni_range3d(f,T2,S);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_loi:=[op(temp_loi),[T1,S],[T2,S]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_lor:=[op(temp_lor),F1,F2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      s_mid:=S[1] + 0.5*(S[2] - S[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      S1:=construct(S[1],s_mid);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      S2:=construct(s_mid,S[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      F1:=cni_range3d(f,T,S1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      F2:=cni_range3d(f,T,S2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_loi:=[op(temp_loi),[T,S1],[T,S2]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp_lor:=[op(temp_lor),F1,F2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  list_of_intervals2d:=[op(temp_loi)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  list_of_ranges:=[op(temp_lor)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  temp:=list_of_ranges[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  for i from 2 to nops(eval(list_of_ranges)) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      temp:=&amp;Convex_Hull(temp,list_of_ranges[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  RETURN(temp);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE INTERVAL_LIST_PLOT3D</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Graphical representation of a single iteration step
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">interval_list_plot3d:=proc(interval_list,range_list)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     local n, i, j, TS, T, S, F, c, c_list, p, opts, c_out;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> opts:=[args[3..nargs]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> for i from 1 to  nops(opts) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(opts[i],identical('colorlist') = list) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         c_list:=rhs(opts[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(opts[i],identical('cutout') = rational) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         c_out:=rhs(opts[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if c_list = 'c_list' then    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> c_list:=[blue,red,green,magenta];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if c_out = 'c_out' then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    c_out := 8/10;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> n:=nops(range_list);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          TS:=interval_list[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          T:=TS[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          S:=TS[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          F:=range_list[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          c:=plottools[cuboid]([T[1],S[1],F[1]],[T[2],S[2],F[2]]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        # Different colours are applied for individual intervals  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          p[i]:=display(plottools[cutout](c,c_out),</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              color=c_list[(i mod nops(c_list)) + 1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        # p[i]:=display([c],color=c_list[(i mod nops(c_list)) + 1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    RETURN(display([seq(p[i],i=1..n)]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_RANGE3D</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_range3d:=proc(f::{function,procedure},X,Y,iterationsteps::nonnegint)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> global list_of_intervals2d,list_of_ranges,q, r;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> local TS, T, S, iter_counter, max_iter_counter, i, j, m, nx, ny, hx,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">hy, lx, ly, opts, c_list,c_out,n,opts_new,x,y;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> x:='x';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> y:='y';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if type(simplify(f(x,y)),numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`Funktion ist konstant = `, simplify(f(x,y)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if type(X,{interval,numeric..numeric}) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      T:=construct(op(1,X),op(2,X));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(X,{identical('X'),identical('x')} =</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">{interval,numeric..numeric})  then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      T:=construct(op(1,rhs(X)),op(2,rhs(X)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else ERROR(`Second argument must be an interval or a range`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if type(Y,{interval,numeric..numeric}) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      S:=construct(op(1,Y),op(2,Y));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> elif type(Y,{identical('Y'),identical('y')} =</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">{interval,numeric..numeric})  then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      S:=construct(op(1,rhs(Y)),op(2,rhs(Y)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else ERROR(`Third argument must be an interval or a range`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if not(type(cni_range3d(f,T,S),interval)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    ERROR(`First argument must be real function of two real variables!`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> lprint(`Start range enclosure = `,cni_range3d(f,T,S));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> # Initialization of global variables</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> max_iter_counter:=iterationsteps;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> nx:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> ny:=1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> opts:=[args[5..nargs]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> n:=nops(opts);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> opts_new:=[];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> for i from 1 to  n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(opts[i],identical('Nx') = nonnegint) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         nx:=rhs(opts[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(opts[i],identical('Ny') = nonnegint) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         ny:=rhs(opts[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(opts[i],identical('colorlist') = list) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         c_list:=rhs(opts[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(opts[i],identical('cutout') = numeric) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         c_out:=rhs(opts[i]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else opts_new:=[op(opts_new),opts[i]]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">q[max_iter_counter+1]:=plot3d(f(x,y),x=T[1]..T[2],y=S[1]..S[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> # Subdivision of the start interval into in nx*ny subparts,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> # given an optional parameter [nx, ny].</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if nx &gt; 1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    hx:=width(T)/nx;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lx:=[seq([T[1] + (i-1)*hx, T[1] + i*hx],i=1..nx)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lx:=[T];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> if ny &gt; 1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    hy:=width(S)/ny;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    ly:=[seq([S[1] + (i-1)*hy, S[1] + i*hy],i=1..ny)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    ly:=[S];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    list_of_intervals2d:=[seq(seq([lx[i],ly[j]],j=1..ny),i=1..nx)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">list_of_ranges:=[seq(cni_range3d(f,TS[1],TS[2]),TS=list_of_intervals2d)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    r[0]:=[min(seq(list_of_ranges[i][1],i=1..(nx*ny))),</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           max(seq(list_of_ranges[i][2],i=1..(nx*ny)))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if nx &gt;1 or ny &gt; 1 then    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  printf(`%s %d %s = \n[%.10g,%.10g]\n`, `Range enclosure after subdivision into`,nx*ny,  `intervals`,r[0][1],r[0][2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> fi; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if c_list = 'c_list' then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   c_list:=[blue,red,green,magenta];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">if c_out = 'c_out' or not(type(c_out,rational) and (0 &lt;= c_out) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">(c_out &lt;= 1)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   c_out:=8/10;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">q[0]:=interval_list_plot3d(list_of_intervals2d,list_of_ranges,colorlist=c_list,cutout=c_out);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  iter_counter:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> for i from 1 to max_iter_counter do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    iter_counter:=iter_counter + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">r[i]:=subdivide_equi3d(f,list_of_intervals2d,list_of_ranges,iter_counter);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # lprint(`Range enclosure after Iteration step`,i,` = `,r[i]);

    printf(`%s %s %s %s %d = %s[%.10g,%.10g]\n`,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Range,enclosure,after,step,i,` `,r[i][1],r[i][2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
 q[i]:=interval_list_plot3d(list_of_intervals2d,list_of_ranges,colorlist=c_list,cutout=c_out);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  m:=max_iter_counter;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  display([q[m],q[m+1]],op(opts_new),axes=framed);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">EXTENDED INTERVAL NEWTON METHOD</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE NEWTON

Newton-Iteration
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">newton:=proc(f,df,xold::interval,eps::float,xunique::boolean)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  global zeros,infos,N,iter_counter;  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  local c,ynew,xnew,i,unique,j,insert;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(type(xold[1],numeric) and type(xold[2],numeric)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN(`Start_interval_must_be_real!`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Cancel Iteration if no zero exists in start interval</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(is_in(0.,f(xold))) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Increase number of iteration steps by 1</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    iter_counter:=iter_counter + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Extended interval Newton step</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    c:=midpoint(xold);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # c:=mid(xold);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    ynew:=ext_int_div(f(c),df(xold));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (nops([ynew]) &gt;= 2) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[1]:=(c &amp;- op(1,[ynew])) &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[2]:=(c &amp;- op(2,[ynew])) &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       unique:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ynew:=(c &amp;- ynew);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[1]:=ynew &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if xnew[1] = [] then RETURN() fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     # Strict inclusion implies existence and uniqueness</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     # of zero in xold</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       unique:=xunique or </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               ((xold[1] &lt; xnew[1][1]) and (xnew[1][2] &lt; xold[2]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[2]:=[]; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Bisection, if no reduction of interval is achieved</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (xnew[1] = xold) or (xnew[2] = xold) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       c:=c[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if (xold[1] &lt; c) and (c &lt; xold[2]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         xnew[1]:=[xold[1],c];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         xnew[2]:=[c,xold[2]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         N:=N+1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         zeros[N]:=xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         infos[N]:=unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Output of computed enclosures or further iteration steps</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    for i from 1 to 2 do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if (xnew[i] &lt;&gt; []) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if (rel_diam(xnew[i]) &lt; eps) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if (is_in(0.,f(xnew[i]))) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if unique=false then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   insert:=true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Combine enclosure intervals with equal end points</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   for j from 1 to N do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      if ((xnew[i] &amp;intersect zeros[j]) &lt;&gt; []) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                         (infos[j] = false) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                           zeros[j]:=zeros[j] &amp;union xnew[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                           insert:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                           break;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    if insert then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      N:=N + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      zeros[N]:=xnew[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      infos[N]:=unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   N:=N + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   zeros[N]:=xnew[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   infos[N]:=unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             newton(f,df,xnew[i],eps,unique);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     od:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    RETURN();    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------
PROCEDURE COMPUTE_ALL_ZEROS</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_all_zeros:=proc(g::{function,procedure},xstart::interval,eps)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    global zeros,infos,N,iter_counter;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    local f,df,xold,unique,i,x,x1,x2,n;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Convert g and g' to interval functions</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:='x';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(simplify(g(x)),numeric) or (simplify(diff(g(x),x)) = 0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`Function is constant = `, simplify(g(x)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    f:=inapply(g(x),x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    df:=inapply(diff(g(x),x),x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(type(f(xstart),interval)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      ERROR(`First argument must be real function of one real variable.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(type(xstart[1],numeric) and type(xstart[2],numeric)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ERROR(`Start_interval_must_be_real.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x1:=xstart[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x2:=xstart[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Determine precision of computation</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (nargs &gt; 3) and type(args[4],nonnegint) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Digits:=max(args[4],10,Digits);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    while not(is_in(Evalf(x1),x1) and is_in(Evalf(x2),x2)) </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          and (Digits &lt;= 100) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Digits:=eval(Digits) + 5;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Digits:= max(ceil(abs(Evalf(log10(eps)))) + 5,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                                Digits);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Digits = `,Digits);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`       `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if width(xstart)=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xold:=[rd(x1),ru(x2)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Digits:=Digits+2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else xold:=xstart;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Initialization</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    zeros:=table();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    infos:=table();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    N:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    iter_counter:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    unique:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Perform Iteration</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    newton(f,df,xold,Evalf(eps),unique);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Output</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if N = 0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`No zero contained in start interval.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     for i from 1 to N do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        print(eval(zeros[i]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if infos[i]=true then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           print(`contains exactly one zero.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           print(`potential enclosure of zero`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`       `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Number of enclosures of zeros: `,N);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Number of Iterations steps: `,iter_counter);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE NEWTON_PLOT</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Graphical representation of one interval newton step.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">newton_plot:=proc(g,f,xold::interval,ynew::list,xnew::list)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         xrange,yrange,xrangelb,xrangeub,yrangelb,yrangeub,viewrange,
         p,hy,h1,h2,i,intxold,intxnew,n,punkt,punkt1,punkt2,punkt3,cx,x,c,tangent1x,tangent1y,tangent2x,tangent2y,
         tunit1,tunit2; 
                                                                                           # modified in v1.2 08/2005, M.Grimmer</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   lprint(`xold=`,xold);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   lprint(`xnew1=`,xnew[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if (xnew[2] &lt;&gt; []) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      lprint(`xnew2=`,xnew[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   xrangelb:=(xold[1]-(width(xold)/10.));  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   xrangeub:=(xold[2]+(width(xold)/10.));  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   xrange:=xrangelb..xrangeub;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   yrangelb:=(f(xold)[1]-width(f(xold))/10.);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   yrangeub:=(f(xold)[2]+width(f(xold))/10.);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   yrange:=yrangelb..yrangeub;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   viewrange:=max(xrangeub-xrangelb,yrangeub-yrangelb);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   x:='x';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   p[1]:=plot(g(x),x=xrange,color=black,numpoints=200):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   hy:=width(f(xold));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   h1:=hy/25.;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   h2:=hy/50.;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   # Representation of old interval - yellow</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">                      </Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         intxold:=plottools[rectangle]([xold[1],0.],[xold[2],-h2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p[2]:=PLOT(intxold,COLOR(RGB,1,1,0));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # Boundaries of old interval</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p[3]:=plot([[xold[1],-h1],[xold[1],h1]],color=black,thickness=4):        </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p[4]:=plot([[xold[2],-h1],[xold[2],h1]],color=black,thickness=4):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # Labelling for old interval</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p[5]:=textplot([midpoint(xold)[1],-h1,'xold'],align=BELOW);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # Representation of computed new intervals</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         n:=6;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         for i from 1 to 2 do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if xnew[i] &lt;&gt; [] then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             intxnew:=plottools[rectangle]([xnew[i][1],h2],[xnew[i][2],0.]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             p[n]:=PLOT(intxnew,COLOR(RGB,0,1,0));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             n:=n+1:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             p[n]:=plot([[xnew[i][1],-h1],[xnew[i][1],h1]],thickness=4):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             n:=n+1:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             p[n]:=plot([[xnew[i][2],-h1],[xnew[i][2],h1]],thickness=4):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             n:=n+1:
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if i=1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             p[n]:=textplot([midpoint(xnew[i])[1],h1,'xnew1'],align=ABOVE);
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             elif i=2 then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             p[n]:=textplot([midpoint(xnew[i])[1],h1,'xnew2'],align=ABOVE);
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             n:=n+1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         od: </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # representation of tangent - red.</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         c:=midpoint(xold)[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         punkt[1]:=[c,g(c)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # Determination of intersection points</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if nops(ynew)=2 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if is_in(-infinity,ynew[1]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[2]:=[ynew[1][2],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[3]:=[ynew[2][1],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[2]:=[ynew[1][1],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[3]:=[ynew[2][2],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if ynew[1] = [-infinity,infinity] then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              p:=display([seq(p[i],i=1..n-1)],axes=framed,xtickmarks=5,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 view=[xrange,yrange],font=[TIMES,ITALIC,10],axesfont=[TIMES,ROMAN,10],</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 scaling=unconstrained);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              RETURN(p);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           elif is_in(-infinity,ynew[1])  then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[2]:=[ynew[1][2],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[3]:=[0.,g(c)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           elif is_in(infinity,ynew[1]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[2]:=[ynew[1][1],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[3]:=[0.,g(c)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[2]:=[ynew[1][1],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              punkt[3]:=[ynew[1][2],0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tangent1x:=t-&gt;punkt[1][1]+t*(punkt[2][1]-punkt[1][1]);    # alternative implementation of lines </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tangent1y:=t-&gt;punkt[1][2]+t*(punkt[2][2]-punkt[1][2]);    # added in v1.2, 08/2005, M. Grimmer</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tangent2x:=t-&gt;punkt[1][1]+t*(punkt[3][1]-punkt[1][1]);    #</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tangent2y:=t-&gt;punkt[1][2]+t*(punkt[3][2]-punkt[1][2]);    #</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tunit1:=sqrt((punkt[2][1]-punkt[1][1])^2+(punkt[2][2]-punkt[1][2])^2); # normalize unit for line display</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tunit2:=sqrt((punkt[3][1]-punkt[1][1])^2+(punkt[3][2]-punkt[1][2])^2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tunit1:=min(1,tunit1);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         tunit2:=min(1,tunit2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p[n]:=plot([tangent1x(t),tangent1y(t),t=-2*viewrange/tunit1..2*viewrange/tunit1],view=[xrange,yrange],
                     color=red,linestyle=3);                                  # v1.2: plot lines as parametric plot</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         n:=n+1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         p[n]:=plot([tangent2x(t),tangent2y(t),t=-2*viewrange/tunit2..2*viewrange/tunit2],view=[xrange,yrange],
                     color=red,linestyle=3);                                  # v1.2: plot lines as parametric plot</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     # Representation of all graphical elements</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     p:=display([seq(p[i],i=1..n)],axes=framed,xtickmarks=5,view=[xrange,yrange],</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                font=[TIMES,ITALIC,10],axesfont=[TIMES,ROMAN,10],scaling=unconstrained);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     RETURN(p);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE NEWTON_WITH_PLOT</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
Newton-Iteration with graphical representation
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">newton_with_plot:=proc(g,f,df,xold::interval,eps::float,xunique::boolean)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    local c,ynew,xnew,i,j,insert,unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    global zeros,infos,N,iter_counter,max_iter_counter,p,dx;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(type(xold[1],numeric) and type(xold[2],numeric)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN(`Start interval_must_be_real.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(is_in(0.,f(xold))) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Increase number of iteration steps by 1</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    iter_counter:=iter_counter + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Extended interval Newton Step</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    c:=midpoint(xold);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    ynew:=[ext_int_div(f(c),df(xold))];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (nops(ynew) &gt;= 2) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ynew[1]:=c &amp;- ynew[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[1]:=ynew[1] &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ynew[2]:=c &amp;- ynew[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[2]:=ynew[2] &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       unique:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       ynew[1]:=c &amp;- ynew[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[1]:=ynew[1] &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if xnew[1] = [] then RETURN() fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     # Strict inclusion implies existence and uniqueness</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     # of zero in xold</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">
       unique:=xunique or </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               ((xold[1] &lt; xnew[1][1]) and (xnew[1][1] &lt; xold[2]));   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xnew[2]:=[]; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Bisection, if no reduction of interval is achieved
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (xnew[1] = xold) or (xnew[2] = xold) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       c:=c[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if (xold[1] &lt; c) and (c &lt; xold[2]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         xnew[1]:=[xold[1],c];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         xnew[2]:=[c,xold[2]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         N:=N+1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         zeros[N]:=xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         infos[N]:=unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Representation of Newton step</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    xnew:=[xnew[1],xnew[2]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Iteration step `, iter_counter);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    p[iter_counter]:=newton_plot(g,f,xold,ynew,xnew);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    print(p[iter_counter]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Output of computed enclosures or further iteration steps</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    for i from 1 to 2 do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if (xnew[i] &lt;&gt; []) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if (rel_diam(xnew[i]) &lt; eps) or (iter_counter=max_iter_counter) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             if (is_in(0.,f(xnew[i]))) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                if unique=false then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   insert:=true;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Combine enclosure intervals with equal end points </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   for j from 1 to N do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      if ((xnew[i] &amp;intersect zeros[j]) &lt;&gt; []) and</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                         (infos[j] = false) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                           zeros[j]:=zeros[j] &amp;union xnew[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                           insert:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                           break;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    if insert then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      N:=N + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      zeros[N]:=xnew[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                      infos[N]:=unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                else       </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   N:=N + 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   zeros[N]:=xnew[i];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   infos[N]:=unique;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             newton_with_plot(g,f,df,xnew[i],eps,unique);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     od:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    RETURN(); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPUTE_ALL_ZEROS_WITH_PLOT
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Enclosure of the zeros of a continuously differentiable function g with graphical representation</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">compute_all_zeros_with_plot:=proc(g::{function,procedure},xstart::interval,eps)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    global zeros,infos,N,iter_counter,max_iter_counter;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    local f,df,xold,unique,i,x,x1,x2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x:='x';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(simplify(g(x)),numeric) or (simplify(diff(g(x),x)) = 0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`Function is constant = `, simplify(g(x)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Conversion of g and g' into interval functions</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (nargs &gt; 4) and type(args[5],nonnegint) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      max_iter_counter:=args[5];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      max_iter_counter:=readstat("Enter maximal number of iteration steps: ");</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    f:=inapply(g(x),x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    df:=inapply(diff(g(x),x),x);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if not(type(f(xstart),interval)) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      ERROR(`First argument must be real function in one real variable.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x1:=xstart[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    x2:=xstart[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Determine precsion of computation</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if (nargs &gt; 3) and type(args[4],nonnegint) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Digits:=max(args[4],10,Digits);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    while not(is_in(Evalf(x1),x1) and is_in(Evalf(x2),x2)) </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          and (Digits &lt;= 100) do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Digits:=eval(Digits) + 5;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    Digits:= max(ceil(abs(Evalf(log10(eps)))) + 5,Digits);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Digits = `,Digits);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`      `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if width(xstart)=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       xold:=[rd(x1),ru(x2)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       Digits:=Digits+2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else xold:=xstart;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Initialization</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    zeros:=table();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    infos:=table();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    N:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    iter_counter:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    unique:=false;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Perform iteration</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">     newton_with_plot(g,f,df,xold,Evalf(eps),unique);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    # Output</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if N = 0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       lprint(`No zero contained in start interval.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN();</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    for i from 1 to N do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        print(eval(zeros[i]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        if infos[i]=true then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           print(` contains exactly one zero.`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           print(` potential enclosure of zero`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`         `);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Number of enclosures of zeros: `,N);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    lprint(`Number of iteration steps: `,iter_counter);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">COMPLEX DISC ARITHMETIC </Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Type definitions and aouxiliary procedures</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Type definitions --&gt; see init procedure</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Definition of `type/complex_disc`:</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">--&gt; moved to init procedure!</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Definition of `type/complex_interval`:</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">--&gt; moved to init procedure!</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CABS`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">This procedure computes a real interval enclosing the abolute value of a complex number 
or a complex rectangular interval.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;cabs`:=proc(z)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       local w;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if type(z,complex_interval) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          w:=&amp;sqrt( (&amp;sqr(z[1])) &amp;+ (&amp;sqr(z[2])) );</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif type(z,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          w:=&amp;sqrt( (&amp;sqr(Re(z))) &amp;+ (&amp;sqr(Im(z))) );</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          '&amp;cabs(z)';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE COMPLEX_DISC_PLOT</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Graphical representation of a complex disc</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">complex_disc_plot:=proc(z::complex_disc)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local opts, x, y, r;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   opts:=[args[2..nargs]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   x:=z[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   y:=z[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   r:=z[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   plot([x + r*cos(t), y +r*sin(t), t=0..2*Pi],op(opts));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">complex_polynom_plot:=proc(p::polynom(complex,z),u::complex_disc)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  local opts, x, y, r;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  opts:=[args[3..nargs]];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  x:=u[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  y:=u[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  r:=u[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  complexplot(subs(z=x + I*y + r * (cos(t) + I*sin(t)),p),t=0..2*Pi,op(opts));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">BASIC ARITHMETIC OPERATIONS</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CADD`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Centered addition of two Complex discs</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;cadd`:=proc(u::{complex,complex_disc},v::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local cx, cy, c, r;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(u,complex_disc) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cx:= u[1] &amp;+ v[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cy:= u[2] &amp;+ v[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if u[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif v[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=u[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:= u[3] &amp;+ v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:= ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:= ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN([op(c),r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(u,complex) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        [Re(u),Im(u),0] &amp;cadd v;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(u,complex_disc) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        u &amp;cadd [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        [Re(u),Im(u),0] &amp;cadd [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CSUB`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Centered subtraction of two Complex discs
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;csub`:=proc(u::{complex,complex_disc},v::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local cx, cy, c, r;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(u,complex_disc) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cx:=u[1] &amp;- v[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cy:=u[2] &amp;- v[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if u[3] = 0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif v[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=u[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:= u[3] &amp;+ v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:= ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:= ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN([op(c),r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(u,complex) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      [Re(u),Im(u),0] &amp;csub v;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(u,complex_disc) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      u &amp;csub [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      [Re(u),Im(u),0] &amp;csub [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CMULT`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Centered multiplication of two Complex discs</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;cmult`:=proc(u::{complex,complex_disc},v::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local cx, cy, c, r, r1, r2, r3;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(u,complex_disc) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cx:=(u[1] &amp;* v[1]) &amp;- (u[2] &amp;* v[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cy:=(u[1] &amp;* v[2]) &amp;+ (u[2] &amp;* v[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if u[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=(&amp;cabs(u[1]+I*u[2])) &amp;* v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif v[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=(&amp;cabs(v[1]+I*v[2])) &amp;* u[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r1:= (&amp;cabs(u[1]+I*u[2])) &amp;* v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r2:= (&amp;cabs(v[1]+I*v[2])) &amp;* u[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r3:= u[3] &amp;* v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:= r1 &amp;+ r2 &amp;+ r3;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:= ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         r:= ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN([op(c),r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(u,complex) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [Re(u),Im(u),0] &amp;cmult v;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(u,complex_disc) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         u &amp;cmult [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [Re(u),Im(u),0] &amp;cmult [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CDIV`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Centered division of two Complex discs</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;cdiv`:=proc(u::{complex,complex_disc},v::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    local c, cx, cy, r, nenner, a;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    if type(u,complex_disc) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       a:=&amp;cabs(v[1]+I*v[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if (a[1] &lt;= v[3]) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          ERROR(`Denominator contains zero! `):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif (u[1] = 1) and (u[2]=0) and (u[3]=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            nenner:= (&amp;sqr(&amp;cabs((v[1]+I*v[2])))) &amp;- (&amp;sqr(v[3]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if is_in(0,nenner) then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               ERROR(`Formula denominator contains zero! `):</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            else           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               cx:=v[1] &amp;/ nenner;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               cy:=((-1)*v[2]) &amp;/ nenner;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               r:=v[3] &amp;/ nenner;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">               c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            RETURN( u &amp;cmult ( [1,0,0] &amp;cdiv v));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:= ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:= ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN([op(c),r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(u,complex) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [Re(u),Im(u),0] &amp;cdiv v;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(u,complex_disc) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         u &amp;cdiv [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    elif type(u,complex) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [Re(u),Im(u),0] &amp;cdiv [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">    fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE X0_START</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font style="Maple Input">x0_start:=proc(s1::interval,s2::interval)</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          local f, F, xu, xo, s3, s, t;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          s:='s';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          t:='t';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          f:=(s,t)-&gt;(sqrt((1+s^2)*(1+t^2))*s*t - s^2*t^2) / (1+s^2+t^2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          F:=inapply(f(s,t),s,t);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          xu:=F(s1,s2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          xu:=xu[1];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          s3:=s1 &amp;* s2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          xo:=min(s1[2],s2[2],s3[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if xu &lt;= xo then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            RETURN([xu,xo]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             ERROR(`Kann Startintervall nicht bestimmen`);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:

</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CMULT_OPT`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Surface optimal multiplication of two complex discs.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;cmult_opt`:=proc(u::{complex,complex_disc},v::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      local  c,cx, cy, r, x0, s1, s2, r1, r2, r3, z1, z2, z1z2, r1r2,</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">r1z2, r2z1, P, dP,t, i, xold, m;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(u,complex_disc) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if (u[1]=0 and u[2]=0 and u[3]=0) or</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         (v[1]=0 and v[2]=0 and v[3]=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           RETURN([0,0,0]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # if one of the discs is zero, zero is returned </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         
         # u and/or w are circles with radius 0 ("a point") </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif u[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           # Determine midpoint
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           cx:=(u[1] &amp;* v[1]) &amp;- (u[2] &amp;* v[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           cy:=(u[1] &amp;* v[2]) &amp;+ (u[2] &amp;* v[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           # Determine radius</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if v[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              r:=[0,0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              r:= (&amp;cabs(u[1]+I*u[2])) &amp;* v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           RETURN([op(c),r]); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif v[3]=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           # Determine midpoint
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           cx:=(u[1] &amp;* v[1]) &amp;- (u[2] &amp;* v[2]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           cy:=(u[1] &amp;* v[2]) &amp;+ (u[2] &amp;* v[1]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           # Determine radius
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=(&amp;cabs(v[1]+I*v[2])) &amp;* u[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           RETURN([op(c),r]); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      # One factor is circle with midpoint 0.</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif (u[1]=0) and (u[2]=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           c:=[0,0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           if (v[1]=0) and (v[2]=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              r:= u[3] &amp;* v[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              r:= u[3] &amp;* ((&amp;cabs(v[1]+I*v[2])) &amp;+ v[3]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           RETURN([0,0,r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       elif (v[1]=0) and (v[2]=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            c:=[0,0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r:=v[3] &amp;* ((&amp;cabs(u[1]+I*u[2])) &amp;+ u[3]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            RETURN([0,0,r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            s1:= u[3] &amp;/ (&amp;cabs(u[1]+I*u[2]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            s2:= v[3] &amp;/ (&amp;cabs(v[1]+I*v[2]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            z1:=u[1] + I*u[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            z2:=v[1] + I*v[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            x0:=x0_start(s1,s2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            #lprint(x0);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            z1z2:=&amp;intpower(&amp;cabs(z1),2) &amp;* &amp;intpower(&amp;cabs(z2),2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r1r2:=&amp;intpower(u[3],2) &amp;* &amp;intpower(v[3],2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r1z2:=&amp;intpower(u[3],2) &amp;* &amp;intpower(&amp;cabs(z2),2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r2z1:=&amp;intpower(v[3],2) &amp;* &amp;intpower(&amp;cabs(z1),2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          # Determine x0 using Newton method, </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          # start interval = x0start</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            t:='t';</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            P:=(2 &amp;* z1z2 &amp;* (&amp;intpower(t,3))) &amp;+ </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">           ((z1z2 &amp;+ r1z2 &amp;+ r2z1) &amp;* (&amp;intpower(t,2))) &amp;- r1r2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            #lprint(eval(subs(t=x0,P)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            dP:=(6 &amp;* z1z2 &amp;* (&amp;intpower(t,2))) &amp;+ (2 &amp;* (z1z2 &amp;+ r1z2 &amp;+ r2z1) &amp;* t);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            #lprint(`dP=`,eval(subs(t=x0,dP)));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            for i from 1 to 10 do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              #lprint(x0);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              xold:=x0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              m:=midpoint(xold);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              x0:=(m &amp;- </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                   (eval(subs(t=m,P)) &amp;/ eval(subs(t=xold,dP))) );</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              x0:=x0 &amp;intersect xold;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              if x0=xold then break; fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            #lprint(`x0=`,x0);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            # Determine midpoint
</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            cx:=((u[1] &amp;* v[1]) &amp;- (u[2] &amp;* v[2])) &amp;* (1 &amp;+ x0);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            cy:=((u[1] &amp;* v[2]) &amp;+ (u[2] &amp;* v[1])) &amp;* (1 &amp;+ x0);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            #lprint(`c=`,c);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            # Determine radius</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r1:=3 &amp;* z1z2 &amp;* &amp;intpower(x0,2);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r2:=2 &amp;* (z1z2 &amp;+ r1z2 &amp;+ r2z1) &amp;* x0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r3:=r1z2 &amp;+ r2z1 &amp;+ r1r2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r:=&amp;sqrt(r1 &amp;+ r2 &amp;+ r3);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r:=ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            r:=ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            RETURN([op(c),r]); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(u,complex) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        [Re(u),Im(u),0] &amp;cmult_opt v;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   elif type(u,complex_disc) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        u &amp;cmult_opt [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">        [Re(u),Im(u),0] &amp;cmult_opt [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:    </Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE `&amp;CDIV_OPT`</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Surface optimal division of two complex discs.</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">`&amp;cdiv_opt`:=proc(u::{complex,complex_disc},v::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      if type(u,complex_disc) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN( u &amp;cmult_opt ([1,0,0] &amp;cdiv v));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif type(u,complex) and type(v,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [Re(u),Im(u),0] &amp;cdiv_opt v;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      elif type(u,complex_disc) and type(v,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         u &amp;cdiv_opt [Re(v),Im(v),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         [Re(u),Im(u),0] &amp;cdiv_opt [Re(v),Im(v),0]</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      fi; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">RANGE ENCLOSURES FOR COMPLEX POLYNOMIALS
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE HORNER_EVAL_CENT
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Horner-Scheme with centered multiplication</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">horner_eval_cent:=proc(p::polynom(complex,z),u::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         local n, Z, s, i, koeff, sx, sy;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">### WARNING: degree(0,x) now returns -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         n:=degree(p,z);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         # p ist constant polynomial</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if n=0 or n=-infinity then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            RETURN(p);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if type(u,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            Z:=[Re(u),Im(u),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            Z:=u;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         koeff:=coeff(p,z^n);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         s:=[Re(koeff),Im(koeff),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         for i from (n-1) to 0 by -1 do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if i&gt;0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              koeff:=coeff(p,z^i);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              if koeff=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 s:=s &amp;cmult Z;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 s:=(s &amp;cmult Z) &amp;cadd [Re(koeff),Im(koeff),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            elif (i=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">### WARNING: ldegree(0,x) now returns infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 if ldegree(p,z) = 0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    s:= (s &amp;cmult Z) &amp;cadd [Re(tcoeff(p)),Im(tcoeff(p)),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    s:= s &amp;cmult Z;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN(s);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE HORNER_EVAL_OPT</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Horner-Scheme with surface optimal multiplication</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">horner_eval_opt:=proc(p::polynom(complex,z),u::{complex,complex_disc})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         local n, Z, s, i, koeff;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">### WARNING: degree(0,x) now returns -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         n:=degree(p,z);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if n=0 or n=-infinity then </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            RETURN(p);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         if type(u,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            Z:=[Re(u),Im(u),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            Z:=u;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         koeff:=coeff(p,z^n);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         s:=[Re(koeff),Im(koeff),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         for i from (n-1) to 0 by -1 do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            if i&gt;0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              koeff:=coeff(p,z^i);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              if koeff=0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 s:=s &amp;cmult_opt Z;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 s:=(s &amp;cmult_opt Z) &amp;cadd [Re(koeff),Im(koeff),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">              fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            elif (i=0) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">### WARNING: ldegree(0,x) now returns infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 if ldegree(p,z) = 0 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    s:= (s &amp;cmult_opt Z) &amp;cadd [Re(tcoeff(p)),Im(tcoeff(p)),0];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                    s:= s &amp;cmult_opt Z;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">         RETURN(s);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">PROCEDURE CENTRED_FORM_EVAL</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Centered form using centered multiplication</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">centred_form_eval:=proc(p::polynom(complex,z),</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">u::{complex_disc,complex})</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">  local c, cx, cy, r, r1, r2, cu, pc, pcx, pcy, i, poly, n, Z;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"> </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if type(u,complex) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          Z:=[Re(u),Im(u),0]; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          cu:=u;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          Z:=u;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          cu:=u[1]+I*u[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">### WARNING: degree(0,x) now returns -infinity</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       n:=degree(p);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       if n=0 or n=-infinity then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          RETURN(p);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Determine midpont of p(Z)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       pc:=horner_eval_cent(p,cu); </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       cx:=[op(1,pc[1] &amp;- pc[3]),op(2,pc[1] &amp;+ pc[3])];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       cy:=[op(1,pc[2] &amp;- pc[3]),op(2,pc[2] &amp;+ pc[3])];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       # Determine radius of p(Z)</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:=0;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       for i from 1 to n do</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          poly:=diff(p,z$i);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          pc:=horner_eval_cent(poly,cu);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if type(pc,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             pcx:=[op(1,pc[1] &amp;- pc[3]),op(2,pc[1] &amp;+ pc[3])];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             pcy:=[op(1,pc[2] &amp;- pc[3]),op(2,pc[2] &amp;+ pc[3])];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r1:= &amp;cabs( [pcx,pcy] );</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          else</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r1:=&amp;cabs( pc);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi; </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">                 </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          if i&gt;1 then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r2:= (&amp;intpower(Z[3],i));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">             r2:= Z[3];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">          r:= r &amp;+ ((r1 &amp;* r2) &amp;/ (i!));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       od;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:=ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       r:= ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">       RETURN([op(c),r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end:</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">EXPONENTIAL FUNCTION FOR COMPLEX DISCS</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">-----------------------------------------------------------------------------
PROCEDURE CEXP</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input">cexp:=proc(u::{complex,complex_disc})</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   local cx, cy, c, r, r1, r2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   if type(u,complex_disc) then</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      # Bestimmung des Mittelpunktes</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cx:=(&amp;exp(u[1])) &amp;* (&amp;cos(u[2]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cy:=(&amp;exp(u[1])) &amp;* (&amp;sin(u[2]));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      c:=[mid(cx),mid(cy)];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      # Bestimmung des Radius</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">            </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r1:=&amp;cabs( [cx,cy] );</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r2:=(&amp;exp(u[3])) &amp;- 1;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:=r1 &amp;* r2;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:=r[2];</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:=ru(Evalf(r) + width(cx));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      r:=ru(Evalf(r) + width(cy));</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      RETURN([op(c),r]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   else </Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">      cexp([Re(u),Im(u),0]);</Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">   fi;</Text-field><Text-field layout="Normal" prompt="&gt; " style="Normal"><Font style="Maple Input">end:</Font><Font family="Times New Roman">
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" prompt="&gt; " style="Maple Input">end module:</Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"/><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">end package intpakX</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">intpakX v1.2 (c) Scientific Computing/Software Engineering Research Group,
Department of Mathematics, University of Wuppertal, Germany</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Contact: 
kraemer@math.uni-wuppertal.de
markus.grimmer@math.uni-wuppertal.de 
http://www.math.uni-wuppertal.de/wrswt</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">Disclaimer:</Font></Text-field><Text-field layout="_pstyle256" style="_pstyle256">While every effort has been made to validate the solutions in this package,</Text-field><Text-field layout="_pstyle257" style="_pstyle257">Waterloo Maple Inc. and the contributors are not responsible for any errors</Text-field><Text-field layout="_pstyle258" style="_pstyle258">contained and are not liable for any damages resulting from the use of this</Text-field><Text-field layout="_pstyle259" style="_pstyle259">material.</Text-field><Text-field layout="_pstyle260" style="_pstyle260">###########################################################################</Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
</Font></Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input"/></Input></Group><Group><Input><Text-field layout="_pstyle262" style="_pstyle262">###########################################################################</Text-field><Text-field layout="Normal" style="Normal"><Font bold="true" executable="false" family="Times New Roman" size="14">How to create the intpakX library from this worksheet</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">
i) Execute the above package definition by simply going back to the very first line of this worksheet,
placing the cursor behind the "restart;" command and hitting the return key.
</Font></Text-field><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">ii) Tell Maple where to put the library. In the line below, replace "&lt;new-library-path&gt;" by  
a directory path of your choice (e.g. "/usr/Maple/intpakX/lib"); then execute the line.</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">libname:="&lt;new-library-path&gt;", libname;</Text-field><Text-field layout="Normal" style="Text">You can use the directory name of your choice in the above line. An empty directory is recommended.

! ATTENTION WINDOWS(TM) USERS:
! To make Maple (Windows(TM) version) interpret the path specification 
! correctly, you have to modify the path specification by replacing each 
! backslach ("\") by a double backslash ("\\")! 
! For example, to specify "C:\Maple\intpakX\lib" as the 
! desired directory, you'll have to modify the "libname" line to:
!
! libname:="C:\\Maple\\intpakX\\lib", libname;</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">iii) Create the new library by executing the following line:</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">march('create',libname[1],100);</Text-field><Text-field layout="Normal" style="Text"/></Input></Group><Group><Input><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">iv) Save the library by executing the following line:</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">savelib('intpakX');</Text-field><Text-field layout="Normal" style="Text"/></Input></Group><Group><Input><Text-field layout="Normal" style="Normal"><Font family="Times New Roman">###########################################################################<Font bold="true" executable="false" size="14">
How to load intpakX once the library has been created</Font>

Now you can open a new, empty worksheet and load the library as follows, now replacing <Font executable="false">
"&lt;new-library-path&gt;" by  the directory path you chose to save the library in.</Font>
</Font></Text-field><Text-field layout="Normal" prompt="&gt; " style="Maple Input">restart;</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">libname:="&lt;new-library-path&gt;", libname;</Text-field></Input></Group><Group><Input><Text-field layout="Normal" prompt="&gt; " style="Maple Input">with(intpakX):</Text-field></Input></Group><Group><Input><Text-field layout="Normal" style="Text"><Font executable="false">
! ATTENTION WINDOWS(TM) USERS:
! To make Maple (Windows(TM) version) interpret the path specification 
! correctly, you have to modify the path specification by replacing each 
! backslach ("\") by a double backslash ("\\")! 
! For example, to specify "C:\Maple\intpakX\lib" as the 
! desired directory, you'll have to modify the "libname" line to:
!
! libname:="C:\\Maple\\intpakX\\lib", libname;</Font>
</Text-field></Input></Group><Group><Input><Text-field layout="_pstyle261" style="_pstyle261">###########################################################################
</Text-field></Input></Group><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/><Text-field/></Worksheet>