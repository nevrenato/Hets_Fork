{-# OPTIONS -w -O0 #-}
{- |
Module      :  RDF/ATC_RDF.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'RDF.AS.TurtleDocument'
'RDF.AS.Statement'
'RDF.AS.Prefix'
'RDF.AS.Base'
'RDF.AS.Triples'
'RDF.AS.Subject'
'RDF.AS.Predicate'
'RDF.AS.Object'
'RDF.AS.PredicateObjectList'
'RDF.AS.RDFLiteral'
'RDF.AS.Term'
'RDF.AS.Axiom'
'RDF.AS.RDFEntityType'
'RDF.AS.RDFEntity'
'OWL2.AS.IRIType'
'OWL2.AS.QName'
'OWL2.AS.EquivOrDisjoint'
'OWL2.AS.DomainOrRange'
'OWL2.AS.SameOrDifferent'
'OWL2.AS.Relation'
'OWL2.AS.Character'
'OWL2.AS.PositiveOrNegative'
'OWL2.AS.QuantifierType'
'OWL2.AS.DatatypeCat'
'OWL2.AS.CardinalityType'
'OWL2.AS.Cardinality'
'OWL2.AS.JunctionType'
'OWL2.AS.Entity'
'OWL2.AS.EntityType'
'OWL2.AS.TypedOrUntyped'
'OWL2.AS.Literal'
'OWL2.AS.NNInt'
'OWL2.AS.IntLit'
'OWL2.AS.DecLit'
'OWL2.AS.FloatLit'
'OWL2.AS.ObjectPropertyExpression'
'OWL2.AS.DataRange'
'OWL2.AS.ClassExpression'
'OWL2.AS.Annotation'
'OWL2.AS.AnnotationValue'
'RDF.Symbols.SymbItems'
'RDF.Symbols.SymbMapItems'
'RDF.Symbols.RawSymb'
'RDF.Sign.Sign'
'RDF.Morphism.RDFMorphism'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
RDF/AS.hs
OWL2/AS.hs
RDF/Symbols.hs
RDF/Sign.hs
RDF/Morphism.hs
RDF/Sublogic.hs
-}

module RDF.ATC_RDF () where

import ATC.Result
import ATerm.Lib
import Common.DocUtils
import Common.Id
import Common.Result
import Data.Char (intToDigit)
import Data.List
import Data.Maybe
import Data.Typeable
import OWL2.AS
import OWL2.ColonKeywords
import OWL2.Keywords
import RDF.AS
import RDF.Function
import RDF.Morphism
import RDF.Print ()
import RDF.Sign
import RDF.Sublogic
import RDF.Symbols
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for RDF.AS.TurtleDocument derive : Typeable !-}
{-! for RDF.AS.Statement derive : Typeable !-}
{-! for RDF.AS.Prefix derive : Typeable !-}
{-! for RDF.AS.Base derive : Typeable !-}
{-! for RDF.AS.Triples derive : Typeable !-}
{-! for RDF.AS.Subject derive : Typeable !-}
{-! for RDF.AS.Predicate derive : Typeable !-}
{-! for RDF.AS.Object derive : Typeable !-}
{-! for RDF.AS.PredicateObjectList derive : Typeable !-}
{-! for RDF.AS.RDFLiteral derive : Typeable !-}
{-! for RDF.AS.Term derive : Typeable !-}
{-! for RDF.AS.Axiom derive : Typeable !-}
{-! for RDF.AS.RDFEntityType derive : Typeable !-}
{-! for RDF.AS.RDFEntity derive : Typeable !-}
{-! for OWL2.AS.IRIType derive : Typeable !-}
{-! for OWL2.AS.QName derive : Typeable !-}
{-! for OWL2.AS.EquivOrDisjoint derive : Typeable !-}
{-! for OWL2.AS.DomainOrRange derive : Typeable !-}
{-! for OWL2.AS.SameOrDifferent derive : Typeable !-}
{-! for OWL2.AS.Relation derive : Typeable !-}
{-! for OWL2.AS.Character derive : Typeable !-}
{-! for OWL2.AS.PositiveOrNegative derive : Typeable !-}
{-! for OWL2.AS.QuantifierType derive : Typeable !-}
{-! for OWL2.AS.DatatypeCat derive : Typeable !-}
{-! for OWL2.AS.CardinalityType derive : Typeable !-}
{-! for OWL2.AS.Cardinality derive : Typeable !-}
{-! for OWL2.AS.JunctionType derive : Typeable !-}
{-! for OWL2.AS.Entity derive : Typeable !-}
{-! for OWL2.AS.EntityType derive : Typeable !-}
{-! for OWL2.AS.TypedOrUntyped derive : Typeable !-}
{-! for OWL2.AS.Literal derive : Typeable !-}
{-! for OWL2.AS.NNInt derive : Typeable !-}
{-! for OWL2.AS.IntLit derive : Typeable !-}
{-! for OWL2.AS.DecLit derive : Typeable !-}
{-! for OWL2.AS.FloatLit derive : Typeable !-}
{-! for OWL2.AS.ObjectPropertyExpression derive : Typeable !-}
{-! for OWL2.AS.DataRange derive : Typeable !-}
{-! for OWL2.AS.ClassExpression derive : Typeable !-}
{-! for OWL2.AS.Annotation derive : Typeable !-}
{-! for OWL2.AS.AnnotationValue derive : Typeable !-}
{-! for RDF.Symbols.SymbItems derive : Typeable !-}
{-! for RDF.Symbols.SymbMapItems derive : Typeable !-}
{-! for RDF.Symbols.RawSymb derive : Typeable !-}
{-! for RDF.Sign.Sign derive : Typeable !-}
{-! for RDF.Morphism.RDFMorphism derive : Typeable !-}

{-! for RDF.AS.TurtleDocument derive : ShATermConvertible !-}
{-! for RDF.AS.Statement derive : ShATermConvertible !-}
{-! for RDF.AS.Prefix derive : ShATermConvertible !-}
{-! for RDF.AS.Base derive : ShATermConvertible !-}
{-! for RDF.AS.Triples derive : ShATermConvertible !-}
{-! for RDF.AS.Subject derive : ShATermConvertible !-}
{-! for RDF.AS.Predicate derive : ShATermConvertible !-}
{-! for RDF.AS.Object derive : ShATermConvertible !-}
{-! for RDF.AS.PredicateObjectList derive : ShATermConvertible !-}
{-! for RDF.AS.RDFLiteral derive : ShATermConvertible !-}
{-! for RDF.AS.Term derive : ShATermConvertible !-}
{-! for RDF.AS.Axiom derive : ShATermConvertible !-}
{-! for RDF.AS.RDFEntityType derive : ShATermConvertible !-}
{-! for RDF.AS.RDFEntity derive : ShATermConvertible !-}
{-! for OWL2.AS.IRIType derive : ShATermConvertible !-}
{-! for OWL2.AS.QName derive : ShATermConvertible !-}
{-! for OWL2.AS.EquivOrDisjoint derive : ShATermConvertible !-}
{-! for OWL2.AS.DomainOrRange derive : ShATermConvertible !-}
{-! for OWL2.AS.SameOrDifferent derive : ShATermConvertible !-}
{-! for OWL2.AS.Relation derive : ShATermConvertible !-}
{-! for OWL2.AS.Character derive : ShATermConvertible !-}
{-! for OWL2.AS.PositiveOrNegative derive : ShATermConvertible !-}
{-! for OWL2.AS.QuantifierType derive : ShATermConvertible !-}
{-! for OWL2.AS.DatatypeCat derive : ShATermConvertible !-}
{-! for OWL2.AS.CardinalityType derive : ShATermConvertible !-}
{-! for OWL2.AS.Cardinality derive : ShATermConvertible !-}
{-! for OWL2.AS.JunctionType derive : ShATermConvertible !-}
{-! for OWL2.AS.Entity derive : ShATermConvertible !-}
{-! for OWL2.AS.EntityType derive : ShATermConvertible !-}
{-! for OWL2.AS.TypedOrUntyped derive : ShATermConvertible !-}
{-! for OWL2.AS.Literal derive : ShATermConvertible !-}
{-! for OWL2.AS.NNInt derive : ShATermConvertible !-}
{-! for OWL2.AS.IntLit derive : ShATermConvertible !-}
{-! for OWL2.AS.DecLit derive : ShATermConvertible !-}
{-! for OWL2.AS.FloatLit derive : ShATermConvertible !-}
{-! for OWL2.AS.ObjectPropertyExpression derive : ShATermConvertible !-}
{-! for OWL2.AS.DataRange derive : ShATermConvertible !-}
{-! for OWL2.AS.ClassExpression derive : ShATermConvertible !-}
{-! for OWL2.AS.Annotation derive : ShATermConvertible !-}
{-! for OWL2.AS.AnnotationValue derive : ShATermConvertible !-}
{-! for RDF.Symbols.SymbItems derive : ShATermConvertible !-}
{-! for RDF.Symbols.SymbMapItems derive : ShATermConvertible !-}
{-! for RDF.Symbols.RawSymb derive : ShATermConvertible !-}
{-! for RDF.Sign.Sign derive : ShATermConvertible !-}
{-! for RDF.Morphism.RDFMorphism derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcIRITypeTc :: TyCon
_tcIRITypeTc = mkTyCon "OWL2.AS.IRIType"
instance Typeable IRIType where
    typeOf _ = mkTyConApp _tcIRITypeTc []

_tcQNameTc :: TyCon
_tcQNameTc = mkTyCon "OWL2.AS.QName"
instance Typeable QName where
    typeOf _ = mkTyConApp _tcQNameTc []

_tcEquivOrDisjointTc :: TyCon
_tcEquivOrDisjointTc = mkTyCon "OWL2.AS.EquivOrDisjoint"
instance Typeable EquivOrDisjoint where
    typeOf _ = mkTyConApp _tcEquivOrDisjointTc []

_tcDomainOrRangeTc :: TyCon
_tcDomainOrRangeTc = mkTyCon "OWL2.AS.DomainOrRange"
instance Typeable DomainOrRange where
    typeOf _ = mkTyConApp _tcDomainOrRangeTc []

_tcSameOrDifferentTc :: TyCon
_tcSameOrDifferentTc = mkTyCon "OWL2.AS.SameOrDifferent"
instance Typeable SameOrDifferent where
    typeOf _ = mkTyConApp _tcSameOrDifferentTc []

_tcRelationTc :: TyCon
_tcRelationTc = mkTyCon "OWL2.AS.Relation"
instance Typeable Relation where
    typeOf _ = mkTyConApp _tcRelationTc []

_tcCharacterTc :: TyCon
_tcCharacterTc = mkTyCon "OWL2.AS.Character"
instance Typeable Character where
    typeOf _ = mkTyConApp _tcCharacterTc []

_tcPositiveOrNegativeTc :: TyCon
_tcPositiveOrNegativeTc = mkTyCon "OWL2.AS.PositiveOrNegative"
instance Typeable PositiveOrNegative where
    typeOf _ = mkTyConApp _tcPositiveOrNegativeTc []

_tcQuantifierTypeTc :: TyCon
_tcQuantifierTypeTc = mkTyCon "OWL2.AS.QuantifierType"
instance Typeable QuantifierType where
    typeOf _ = mkTyConApp _tcQuantifierTypeTc []

_tcDatatypeCatTc :: TyCon
_tcDatatypeCatTc = mkTyCon "OWL2.AS.DatatypeCat"
instance Typeable DatatypeCat where
    typeOf _ = mkTyConApp _tcDatatypeCatTc []

_tcCardinalityTypeTc :: TyCon
_tcCardinalityTypeTc = mkTyCon "OWL2.AS.CardinalityType"
instance Typeable CardinalityType where
    typeOf _ = mkTyConApp _tcCardinalityTypeTc []

_tcCardinalityTc :: TyCon
_tcCardinalityTc = mkTyCon "OWL2.AS.Cardinality"
instance Typeable2 Cardinality where
    typeOf2 _ = mkTyConApp _tcCardinalityTc []

_tcJunctionTypeTc :: TyCon
_tcJunctionTypeTc = mkTyCon "OWL2.AS.JunctionType"
instance Typeable JunctionType where
    typeOf _ = mkTyConApp _tcJunctionTypeTc []

_tcEntityTc :: TyCon
_tcEntityTc = mkTyCon "OWL2.AS.Entity"
instance Typeable Entity where
    typeOf _ = mkTyConApp _tcEntityTc []

_tcEntityTypeTc :: TyCon
_tcEntityTypeTc = mkTyCon "OWL2.AS.EntityType"
instance Typeable EntityType where
    typeOf _ = mkTyConApp _tcEntityTypeTc []

_tcTypedOrUntypedTc :: TyCon
_tcTypedOrUntypedTc = mkTyCon "OWL2.AS.TypedOrUntyped"
instance Typeable TypedOrUntyped where
    typeOf _ = mkTyConApp _tcTypedOrUntypedTc []

_tcLiteralTc :: TyCon
_tcLiteralTc = mkTyCon "OWL2.AS.Literal"
instance Typeable Literal where
    typeOf _ = mkTyConApp _tcLiteralTc []

_tcNNIntTc :: TyCon
_tcNNIntTc = mkTyCon "OWL2.AS.NNInt"
instance Typeable NNInt where
    typeOf _ = mkTyConApp _tcNNIntTc []

_tcIntLitTc :: TyCon
_tcIntLitTc = mkTyCon "OWL2.AS.IntLit"
instance Typeable IntLit where
    typeOf _ = mkTyConApp _tcIntLitTc []

_tcDecLitTc :: TyCon
_tcDecLitTc = mkTyCon "OWL2.AS.DecLit"
instance Typeable DecLit where
    typeOf _ = mkTyConApp _tcDecLitTc []

_tcFloatLitTc :: TyCon
_tcFloatLitTc = mkTyCon "OWL2.AS.FloatLit"
instance Typeable FloatLit where
    typeOf _ = mkTyConApp _tcFloatLitTc []

_tcObjectPropertyExpressionTc :: TyCon
_tcObjectPropertyExpressionTc = mkTyCon "OWL2.AS.ObjectPropertyExpression"
instance Typeable ObjectPropertyExpression where
    typeOf _ = mkTyConApp _tcObjectPropertyExpressionTc []

_tcDataRangeTc :: TyCon
_tcDataRangeTc = mkTyCon "OWL2.AS.DataRange"
instance Typeable DataRange where
    typeOf _ = mkTyConApp _tcDataRangeTc []

_tcClassExpressionTc :: TyCon
_tcClassExpressionTc = mkTyCon "OWL2.AS.ClassExpression"
instance Typeable ClassExpression where
    typeOf _ = mkTyConApp _tcClassExpressionTc []

_tcAnnotationTc :: TyCon
_tcAnnotationTc = mkTyCon "OWL2.AS.Annotation"
instance Typeable Annotation where
    typeOf _ = mkTyConApp _tcAnnotationTc []

_tcAnnotationValueTc :: TyCon
_tcAnnotationValueTc = mkTyCon "OWL2.AS.AnnotationValue"
instance Typeable AnnotationValue where
    typeOf _ = mkTyConApp _tcAnnotationValueTc []

instance ShATermConvertible IRIType where
  toShATermAux att0 xv = case xv of
    Full -> return $ addATerm (ShAAppl "Full" [] []) att0
    Abbreviated -> return $ addATerm (ShAAppl "Abbreviated" [] []) att0
    NodeID -> return $ addATerm (ShAAppl "NodeID" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Full" [] _ -> (att0, Full)
    ShAAppl "Abbreviated" [] _ -> (att0, Abbreviated)
    ShAAppl "NodeID" [] _ -> (att0, NodeID)
    u -> fromShATermError "IRIType" u

instance ShATermConvertible QName where
  toShATermAux att0 xv = case xv of
    QN a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "QN" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "QN" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, QN a' b' c' d' e') }}}}}
    u -> fromShATermError "QName" u

instance ShATermConvertible EquivOrDisjoint where
  toShATermAux att0 xv = case xv of
    Equivalent -> return $ addATerm (ShAAppl "Equivalent" [] []) att0
    Disjoint -> return $ addATerm (ShAAppl "Disjoint" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Equivalent" [] _ -> (att0, Equivalent)
    ShAAppl "Disjoint" [] _ -> (att0, Disjoint)
    u -> fromShATermError "EquivOrDisjoint" u

instance ShATermConvertible DomainOrRange where
  toShATermAux att0 xv = case xv of
    ADomain -> return $ addATerm (ShAAppl "ADomain" [] []) att0
    ARange -> return $ addATerm (ShAAppl "ARange" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ADomain" [] _ -> (att0, ADomain)
    ShAAppl "ARange" [] _ -> (att0, ARange)
    u -> fromShATermError "DomainOrRange" u

instance ShATermConvertible SameOrDifferent where
  toShATermAux att0 xv = case xv of
    Same -> return $ addATerm (ShAAppl "Same" [] []) att0
    Different -> return $ addATerm (ShAAppl "Different" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Same" [] _ -> (att0, Same)
    ShAAppl "Different" [] _ -> (att0, Different)
    u -> fromShATermError "SameOrDifferent" u

instance ShATermConvertible Relation where
  toShATermAux att0 xv = case xv of
    EDRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "EDRelation" [a'] []) att1
    SubPropertyOf -> return $ addATerm (ShAAppl "SubPropertyOf" [] []) att0
    InverseOf -> return $ addATerm (ShAAppl "InverseOf" [] []) att0
    SubClass -> return $ addATerm (ShAAppl "SubClass" [] []) att0
    Types -> return $ addATerm (ShAAppl "Types" [] []) att0
    DRRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DRRelation" [a'] []) att1
    SDRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SDRelation" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "EDRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, EDRelation a') }
    ShAAppl "SubPropertyOf" [] _ -> (att0, SubPropertyOf)
    ShAAppl "InverseOf" [] _ -> (att0, InverseOf)
    ShAAppl "SubClass" [] _ -> (att0, SubClass)
    ShAAppl "Types" [] _ -> (att0, Types)
    ShAAppl "DRRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DRRelation a') }
    ShAAppl "SDRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SDRelation a') }
    u -> fromShATermError "Relation" u

instance ShATermConvertible Character where
  toShATermAux att0 xv = case xv of
    Functional -> return $ addATerm (ShAAppl "Functional" [] []) att0
    InverseFunctional ->
      return $ addATerm (ShAAppl "InverseFunctional" [] []) att0
    Reflexive -> return $ addATerm (ShAAppl "Reflexive" [] []) att0
    Irreflexive -> return $ addATerm (ShAAppl "Irreflexive" [] []) att0
    Symmetric -> return $ addATerm (ShAAppl "Symmetric" [] []) att0
    Asymmetric -> return $ addATerm (ShAAppl "Asymmetric" [] []) att0
    Antisymmetric -> return $ addATerm (ShAAppl "Antisymmetric" [] []) att0
    Transitive -> return $ addATerm (ShAAppl "Transitive" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Functional" [] _ -> (att0, Functional)
    ShAAppl "InverseFunctional" [] _ -> (att0, InverseFunctional)
    ShAAppl "Reflexive" [] _ -> (att0, Reflexive)
    ShAAppl "Irreflexive" [] _ -> (att0, Irreflexive)
    ShAAppl "Symmetric" [] _ -> (att0, Symmetric)
    ShAAppl "Asymmetric" [] _ -> (att0, Asymmetric)
    ShAAppl "Antisymmetric" [] _ -> (att0, Antisymmetric)
    ShAAppl "Transitive" [] _ -> (att0, Transitive)
    u -> fromShATermError "Character" u

instance ShATermConvertible PositiveOrNegative where
  toShATermAux att0 xv = case xv of
    Positive -> return $ addATerm (ShAAppl "Positive" [] []) att0
    Negative -> return $ addATerm (ShAAppl "Negative" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Positive" [] _ -> (att0, Positive)
    ShAAppl "Negative" [] _ -> (att0, Negative)
    u -> fromShATermError "PositiveOrNegative" u

instance ShATermConvertible QuantifierType where
  toShATermAux att0 xv = case xv of
    AllValuesFrom -> return $ addATerm (ShAAppl "AllValuesFrom" [] []) att0
    SomeValuesFrom -> return $ addATerm (ShAAppl "SomeValuesFrom" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AllValuesFrom" [] _ -> (att0, AllValuesFrom)
    ShAAppl "SomeValuesFrom" [] _ -> (att0, SomeValuesFrom)
    u -> fromShATermError "QuantifierType" u

instance ShATermConvertible DatatypeCat where
  toShATermAux att0 xv = case xv of
    OWL2Number -> return $ addATerm (ShAAppl "OWL2Number" [] []) att0
    OWL2String -> return $ addATerm (ShAAppl "OWL2String" [] []) att0
    OWL2Bool -> return $ addATerm (ShAAppl "OWL2Bool" [] []) att0
    Other -> return $ addATerm (ShAAppl "Other" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "OWL2Number" [] _ -> (att0, OWL2Number)
    ShAAppl "OWL2String" [] _ -> (att0, OWL2String)
    ShAAppl "OWL2Bool" [] _ -> (att0, OWL2Bool)
    ShAAppl "Other" [] _ -> (att0, Other)
    u -> fromShATermError "DatatypeCat" u

instance ShATermConvertible CardinalityType where
  toShATermAux att0 xv = case xv of
    MinCardinality -> return $ addATerm (ShAAppl "MinCardinality" [] []) att0
    MaxCardinality -> return $ addATerm (ShAAppl "MaxCardinality" [] []) att0
    ExactCardinality ->
      return $ addATerm (ShAAppl "ExactCardinality" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "MinCardinality" [] _ -> (att0, MinCardinality)
    ShAAppl "MaxCardinality" [] _ -> (att0, MaxCardinality)
    ShAAppl "ExactCardinality" [] _ -> (att0, ExactCardinality)
    u -> fromShATermError "CardinalityType" u

instance (ShATermConvertible a,
          ShATermConvertible b) => ShATermConvertible (Cardinality a b) where
  toShATermAux att0 xv = case xv of
    Cardinality a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Cardinality" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Cardinality" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Cardinality a' b' c' d') }}}}
    u -> fromShATermError "Cardinality" u

instance ShATermConvertible JunctionType where
  toShATermAux att0 xv = case xv of
    UnionOf -> return $ addATerm (ShAAppl "UnionOf" [] []) att0
    IntersectionOf -> return $ addATerm (ShAAppl "IntersectionOf" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "UnionOf" [] _ -> (att0, UnionOf)
    ShAAppl "IntersectionOf" [] _ -> (att0, IntersectionOf)
    u -> fromShATermError "JunctionType" u

instance ShATermConvertible Entity where
  toShATermAux att0 xv = case xv of
    Entity a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Entity" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Entity" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Entity a' b') }}
    u -> fromShATermError "Entity" u

instance ShATermConvertible EntityType where
  toShATermAux att0 xv = case xv of
    Datatype -> return $ addATerm (ShAAppl "Datatype" [] []) att0
    Class -> return $ addATerm (ShAAppl "Class" [] []) att0
    ObjectProperty -> return $ addATerm (ShAAppl "ObjectProperty" [] []) att0
    DataProperty -> return $ addATerm (ShAAppl "DataProperty" [] []) att0
    AnnotationProperty ->
      return $ addATerm (ShAAppl "AnnotationProperty" [] []) att0
    NamedIndividual -> return $ addATerm (ShAAppl "NamedIndividual" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Datatype" [] _ -> (att0, Datatype)
    ShAAppl "Class" [] _ -> (att0, Class)
    ShAAppl "ObjectProperty" [] _ -> (att0, ObjectProperty)
    ShAAppl "DataProperty" [] _ -> (att0, DataProperty)
    ShAAppl "AnnotationProperty" [] _ -> (att0, AnnotationProperty)
    ShAAppl "NamedIndividual" [] _ -> (att0, NamedIndividual)
    u -> fromShATermError "EntityType" u

instance ShATermConvertible TypedOrUntyped where
  toShATermAux att0 xv = case xv of
    Typed a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Typed" [a'] []) att1
    Untyped a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Untyped" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Typed" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Typed a') }
    ShAAppl "Untyped" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Untyped a') }
    u -> fromShATermError "TypedOrUntyped" u

instance ShATermConvertible Literal where
  toShATermAux att0 xv = case xv of
    Literal a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Literal" [a', b'] []) att2
    NumberLit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NumberLit" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Literal" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Literal a' b') }}
    ShAAppl "NumberLit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NumberLit a') }
    u -> fromShATermError "Literal" u

instance ShATermConvertible NNInt where
  toShATermAux att0 xv = case xv of
    NNInt a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "NNInt" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NNInt" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, NNInt a') }
    u -> fromShATermError "NNInt" u

instance ShATermConvertible IntLit where
  toShATermAux att0 xv = case xv of
    IntLit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "IntLit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "IntLit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, IntLit a' b') }}
    u -> fromShATermError "IntLit" u

instance ShATermConvertible DecLit where
  toShATermAux att0 xv = case xv of
    DecLit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DecLit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DecLit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DecLit a' b') }}
    u -> fromShATermError "DecLit" u

instance ShATermConvertible FloatLit where
  toShATermAux att0 xv = case xv of
    FloatLit a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "FloatLit" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "FloatLit" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, FloatLit a' b') }}
    u -> fromShATermError "FloatLit" u

instance ShATermConvertible ObjectPropertyExpression where
  toShATermAux att0 xv = case xv of
    ObjectProp a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectProp" [a'] []) att1
    ObjectInverseOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectInverseOf" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ObjectProp" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectProp a') }
    ShAAppl "ObjectInverseOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectInverseOf a') }
    u -> fromShATermError "ObjectPropertyExpression" u

instance ShATermConvertible DataRange where
  toShATermAux att0 xv = case xv of
    DataType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DataType" [a', b'] []) att2
    DataJunction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DataJunction" [a', b'] []) att2
    DataComplementOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataComplementOf" [a'] []) att1
    DataOneOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataOneOf" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DataType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DataType a' b') }}
    ShAAppl "DataJunction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DataJunction a' b') }}
    ShAAppl "DataComplementOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataComplementOf a') }
    ShAAppl "DataOneOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataOneOf a') }
    u -> fromShATermError "DataRange" u

instance ShATermConvertible ClassExpression where
  toShATermAux att0 xv = case xv of
    Expression a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Expression" [a'] []) att1
    ObjectJunction a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ObjectJunction" [a', b'] []) att2
    ObjectComplementOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectComplementOf" [a'] []) att1
    ObjectOneOf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectOneOf" [a'] []) att1
    ObjectValuesFrom a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "ObjectValuesFrom" [a', b', c'] []) att3
    ObjectHasValue a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "ObjectHasValue" [a', b'] []) att2
    ObjectHasSelf a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectHasSelf" [a'] []) att1
    ObjectCardinality a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectCardinality" [a'] []) att1
    DataValuesFrom a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "DataValuesFrom" [a', b', c'] []) att3
    DataHasValue a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DataHasValue" [a', b'] []) att2
    DataCardinality a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "DataCardinality" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Expression" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Expression a') }
    ShAAppl "ObjectJunction" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ObjectJunction a' b') }}
    ShAAppl "ObjectComplementOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectComplementOf a') }
    ShAAppl "ObjectOneOf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectOneOf a') }
    ShAAppl "ObjectValuesFrom" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, ObjectValuesFrom a' b' c') }}}
    ShAAppl "ObjectHasValue" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, ObjectHasValue a' b') }}
    ShAAppl "ObjectHasSelf" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectHasSelf a') }
    ShAAppl "ObjectCardinality" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectCardinality a') }
    ShAAppl "DataValuesFrom" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, DataValuesFrom a' b' c') }}}
    ShAAppl "DataHasValue" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DataHasValue a' b') }}
    ShAAppl "DataCardinality" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, DataCardinality a') }
    u -> fromShATermError "ClassExpression" u

instance ShATermConvertible Annotation where
  toShATermAux att0 xv = case xv of
    Annotation a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Annotation" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Annotation" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Annotation a' b' c') }}}
    u -> fromShATermError "Annotation" u

instance ShATermConvertible AnnotationValue where
  toShATermAux att0 xv = case xv of
    AnnValue a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnnValue" [a'] []) att1
    AnnValLit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnnValLit" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "AnnValue" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnnValue a') }
    ShAAppl "AnnValLit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnnValLit a') }
    u -> fromShATermError "AnnotationValue" u

instance ShATermConvertible RDFEntity where
  toShATermAux att0 xv = case xv of
    RDFEntity a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "RDFEntity" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "RDFEntity" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, RDFEntity a' b') }}
    u -> fromShATermError "RDFEntity" u

instance ShATermConvertible RDFEntityType where
  toShATermAux att0 xv = case xv of
    SubjectEntity -> return $ addATerm (ShAAppl "SubjectEntity" [] []) att0
    PredicateEntity -> return $ addATerm (ShAAppl "PredicateEntity" [] []) att0
    ObjectEntity -> return $ addATerm (ShAAppl "ObjectEntity" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SubjectEntity" [] _ -> (att0, SubjectEntity)
    ShAAppl "PredicateEntity" [] _ -> (att0, PredicateEntity)
    ShAAppl "ObjectEntity" [] _ -> (att0, ObjectEntity)
    u -> fromShATermError "RDFEntityType" u

instance ShATermConvertible Axiom where
  toShATermAux att0 xv = case xv of
    Axiom a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Axiom" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Axiom" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Axiom a' b' c') }}}
    u -> fromShATermError "Axiom" u

instance ShATermConvertible Term where
  toShATermAux att0 xv = case xv of
    SubjectTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SubjectTerm" [a'] []) att1
    PredicateTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PredicateTerm" [a'] []) att1
    ObjectTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectTerm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SubjectTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SubjectTerm a') }
    ShAAppl "PredicateTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PredicateTerm a') }
    ShAAppl "ObjectTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectTerm a') }
    u -> fromShATermError "Term" u

instance ShATermConvertible RDFLiteral where
  toShATermAux att0 xv = case xv of
    RDFLiteral a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "RDFLiteral" [a', b', c'] []) att3
    RDFNumberLit a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "RDFNumberLit" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "RDFLiteral" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, RDFLiteral a' b' c') }}}
    ShAAppl "RDFNumberLit" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, RDFNumberLit a') }
    u -> fromShATermError "RDFLiteral" u

instance ShATermConvertible PredicateObjectList where
  toShATermAux att0 xv = case xv of
    PredicateObjectList a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "PredicateObjectList" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PredicateObjectList" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, PredicateObjectList a' b') }}
    u -> fromShATermError "PredicateObjectList" u

instance ShATermConvertible Object where
  toShATermAux att0 xv = case xv of
    Object a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Object" [a'] []) att1
    ObjectLiteral a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ObjectLiteral" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Object" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Object a') }
    ShAAppl "ObjectLiteral" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ObjectLiteral a') }
    u -> fromShATermError "Object" u

instance ShATermConvertible Predicate where
  toShATermAux att0 xv = case xv of
    Predicate a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Predicate" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Predicate" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Predicate a') }
    u -> fromShATermError "Predicate" u

instance ShATermConvertible Subject where
  toShATermAux att0 xv = case xv of
    Subject a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Subject" [a'] []) att1
    SubjectList a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SubjectList" [a'] []) att1
    SubjectCollection a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SubjectCollection" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Subject" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Subject a') }
    ShAAppl "SubjectList" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SubjectList a') }
    ShAAppl "SubjectCollection" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SubjectCollection a') }
    u -> fromShATermError "Subject" u

instance ShATermConvertible Triples where
  toShATermAux att0 xv = case xv of
    Triples a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Triples" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Triples" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Triples a' b') }}
    u -> fromShATermError "Triples" u

instance ShATermConvertible Base where
  toShATermAux att0 xv = case xv of
    Base a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Base" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Base" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Base a') }
    u -> fromShATermError "Base" u

instance ShATermConvertible Prefix where
  toShATermAux att0 xv = case xv of
    Prefix a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Prefix" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Prefix" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Prefix a' b') }}
    u -> fromShATermError "Prefix" u

instance ShATermConvertible Statement where
  toShATermAux att0 xv = case xv of
    Statement a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Statement" [a'] []) att1
    PrefixStatement a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PrefixStatement" [a'] []) att1
    BaseStatement a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "BaseStatement" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Statement" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Statement a') }
    ShAAppl "PrefixStatement" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PrefixStatement a') }
    ShAAppl "BaseStatement" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, BaseStatement a') }
    u -> fromShATermError "Statement" u

instance ShATermConvertible TurtleDocument where
  toShATermAux att0 xv = case xv of
    TurtleDocument a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "TurtleDocument" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TurtleDocument" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, TurtleDocument a' b' c') }}}
    u -> fromShATermError "TurtleDocument" u

_tcRDFEntityTc :: TyCon
_tcRDFEntityTc = mkTyCon "RDF.AS.RDFEntity"
instance Typeable RDFEntity where
    typeOf _ = mkTyConApp _tcRDFEntityTc []

_tcRDFEntityTypeTc :: TyCon
_tcRDFEntityTypeTc = mkTyCon "RDF.AS.RDFEntityType"
instance Typeable RDFEntityType where
    typeOf _ = mkTyConApp _tcRDFEntityTypeTc []

_tcAxiomTc :: TyCon
_tcAxiomTc = mkTyCon "RDF.AS.Axiom"
instance Typeable Axiom where
    typeOf _ = mkTyConApp _tcAxiomTc []

_tcTermTc :: TyCon
_tcTermTc = mkTyCon "RDF.AS.Term"
instance Typeable Term where
    typeOf _ = mkTyConApp _tcTermTc []

_tcRDFLiteralTc :: TyCon
_tcRDFLiteralTc = mkTyCon "RDF.AS.RDFLiteral"
instance Typeable RDFLiteral where
    typeOf _ = mkTyConApp _tcRDFLiteralTc []

_tcPredicateObjectListTc :: TyCon
_tcPredicateObjectListTc = mkTyCon "RDF.AS.PredicateObjectList"
instance Typeable PredicateObjectList where
    typeOf _ = mkTyConApp _tcPredicateObjectListTc []

_tcObjectTc :: TyCon
_tcObjectTc = mkTyCon "RDF.AS.Object"
instance Typeable Object where
    typeOf _ = mkTyConApp _tcObjectTc []

_tcPredicateTc :: TyCon
_tcPredicateTc = mkTyCon "RDF.AS.Predicate"
instance Typeable Predicate where
    typeOf _ = mkTyConApp _tcPredicateTc []

_tcSubjectTc :: TyCon
_tcSubjectTc = mkTyCon "RDF.AS.Subject"
instance Typeable Subject where
    typeOf _ = mkTyConApp _tcSubjectTc []

_tcTriplesTc :: TyCon
_tcTriplesTc = mkTyCon "RDF.AS.Triples"
instance Typeable Triples where
    typeOf _ = mkTyConApp _tcTriplesTc []

_tcBaseTc :: TyCon
_tcBaseTc = mkTyCon "RDF.AS.Base"
instance Typeable Base where
    typeOf _ = mkTyConApp _tcBaseTc []

_tcPrefixTc :: TyCon
_tcPrefixTc = mkTyCon "RDF.AS.Prefix"
instance Typeable Prefix where
    typeOf _ = mkTyConApp _tcPrefixTc []

_tcStatementTc :: TyCon
_tcStatementTc = mkTyCon "RDF.AS.Statement"
instance Typeable Statement where
    typeOf _ = mkTyConApp _tcStatementTc []

_tcTurtleDocumentTc :: TyCon
_tcTurtleDocumentTc = mkTyCon "RDF.AS.TurtleDocument"
instance Typeable TurtleDocument where
    typeOf _ = mkTyConApp _tcTurtleDocumentTc []

instance ShATermConvertible RDFMorphism where
  toShATermAux att0 xv = case xv of
    RDFMorphism a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "RDFMorphism" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "RDFMorphism" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, RDFMorphism a' b' c') }}}
    u -> fromShATermError "RDFMorphism" u

_tcRDFMorphismTc :: TyCon
_tcRDFMorphismTc = mkTyCon "RDF.Morphism.RDFMorphism"
instance Typeable RDFMorphism where
    typeOf _ = mkTyConApp _tcRDFMorphismTc []

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Sign" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Sign a' b' c') }}}
    u -> fromShATermError "Sign" u

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "RDF.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

instance ShATermConvertible RawSymb where
  toShATermAux att0 xv = case xv of
    ASymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "ASymbol" [a'] []) att1
    AnUri a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnUri" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "ASymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, ASymbol a') }
    ShAAppl "AnUri" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnUri a') }
    u -> fromShATermError "RawSymb" u

instance ShATermConvertible SymbMapItems where
  toShATermAux att0 xv = case xv of
    SymbMapItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SymbMapItems" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbMapItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SymbMapItems a' b') }}
    u -> fromShATermError "SymbMapItems" u

instance ShATermConvertible SymbItems where
  toShATermAux att0 xv = case xv of
    SymbItems a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SymbItems" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SymbItems" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SymbItems a' b') }}
    u -> fromShATermError "SymbItems" u

_tcRawSymbTc :: TyCon
_tcRawSymbTc = mkTyCon "RDF.Symbols.RawSymb"
instance Typeable RawSymb where
    typeOf _ = mkTyConApp _tcRawSymbTc []

_tcSymbMapItemsTc :: TyCon
_tcSymbMapItemsTc = mkTyCon "RDF.Symbols.SymbMapItems"
instance Typeable SymbMapItems where
    typeOf _ = mkTyConApp _tcSymbMapItemsTc []

_tcSymbItemsTc :: TyCon
_tcSymbItemsTc = mkTyCon "RDF.Symbols.SymbItems"
instance Typeable SymbItems where
    typeOf _ = mkTyConApp _tcSymbItemsTc []
