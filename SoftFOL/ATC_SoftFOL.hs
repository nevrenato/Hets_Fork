{-# OPTIONS -w -O0 #-}
{- |
Module      :  SoftFOL/ATC_SoftFOL.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'SoftFOL.Sign.Sign'
'SoftFOL.Sign.Generated'
'SoftFOL.Sign.SFSymbol'
'SoftFOL.Sign.SFSymbType'
'SoftFOL.Sign.SPProblem'
'SoftFOL.Sign.SPLogicalPart'
'SoftFOL.Sign.SPSymbolList'
'SoftFOL.Sign.SPSignSym'
'SoftFOL.Sign.SPSortSym'
'SoftFOL.Sign.SPDeclaration'
'SoftFOL.Sign.SPFormulaList'
'SoftFOL.Sign.SPClauseList'
'SoftFOL.Sign.SPOriginType'
'SoftFOL.Sign.SPClauseType'
'SoftFOL.Sign.NSPClause'
'SoftFOL.Sign.NSPClauseBody'
'SoftFOL.Sign.TermWsList'
'SoftFOL.Sign.SPTerm'
'SoftFOL.Sign.SPLiteral'
'SoftFOL.Sign.SPQuantSym'
'SoftFOL.Sign.SPSymbol'
'SoftFOL.Sign.SPProofList'
'SoftFOL.Sign.SPProofStep'
'SoftFOL.Sign.SPReference'
'SoftFOL.Sign.SPResult'
'SoftFOL.Sign.SPRuleAppl'
'SoftFOL.Sign.SPUserRuleAppl'
'SoftFOL.Sign.SPParent'
'SoftFOL.Sign.SPKey'
'SoftFOL.Sign.SPValue'
'SoftFOL.Sign.SPDescription'
'SoftFOL.Sign.SPLogState'
'SoftFOL.Sign.SPSetting'
'SoftFOL.Sign.SPSettingBody'
'SoftFOL.Sign.SPHypothesis'
'SoftFOL.Sign.SPSettingLabel'
'SoftFOL.Sign.SPCRBIND'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
SoftFOL/Sign.hs
-}

module SoftFOL.ATC_SoftFOL () where

import ATC.AS_Annotation
import ATerm.Lib
import Common.AS_Annotation
import Common.DefaultMorphism
import Common.Id
import Data.Char
import Data.Typeable
import SoftFOL.Sign
import qualified Common.Lib.Rel as Rel
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for SoftFOL.Sign.Sign derive : Typeable !-}
{-! for SoftFOL.Sign.Generated derive : Typeable !-}
{-! for SoftFOL.Sign.SFSymbol derive : Typeable !-}
{-! for SoftFOL.Sign.SFSymbType derive : Typeable !-}
{-! for SoftFOL.Sign.SPProblem derive : Typeable !-}
{-! for SoftFOL.Sign.SPLogicalPart derive : Typeable !-}
{-! for SoftFOL.Sign.SPSymbolList derive : Typeable !-}
{-! for SoftFOL.Sign.SPSignSym derive : Typeable !-}
{-! for SoftFOL.Sign.SPSortSym derive : Typeable !-}
{-! for SoftFOL.Sign.SPDeclaration derive : Typeable !-}
{-! for SoftFOL.Sign.SPFormulaList derive : Typeable !-}
{-! for SoftFOL.Sign.SPClauseList derive : Typeable !-}
{-! for SoftFOL.Sign.SPOriginType derive : Typeable !-}
{-! for SoftFOL.Sign.SPClauseType derive : Typeable !-}
{-! for SoftFOL.Sign.NSPClause derive : Typeable !-}
{-! for SoftFOL.Sign.NSPClauseBody derive : Typeable !-}
{-! for SoftFOL.Sign.TermWsList derive : Typeable !-}
{-! for SoftFOL.Sign.SPTerm derive : Typeable !-}
{-! for SoftFOL.Sign.SPLiteral derive : Typeable !-}
{-! for SoftFOL.Sign.SPQuantSym derive : Typeable !-}
{-! for SoftFOL.Sign.SPSymbol derive : Typeable !-}
{-! for SoftFOL.Sign.SPProofList derive : Typeable !-}
{-! for SoftFOL.Sign.SPProofStep derive : Typeable !-}
{-! for SoftFOL.Sign.SPReference derive : Typeable !-}
{-! for SoftFOL.Sign.SPResult derive : Typeable !-}
{-! for SoftFOL.Sign.SPRuleAppl derive : Typeable !-}
{-! for SoftFOL.Sign.SPUserRuleAppl derive : Typeable !-}
{-! for SoftFOL.Sign.SPParent derive : Typeable !-}
{-! for SoftFOL.Sign.SPKey derive : Typeable !-}
{-! for SoftFOL.Sign.SPValue derive : Typeable !-}
{-! for SoftFOL.Sign.SPDescription derive : Typeable !-}
{-! for SoftFOL.Sign.SPLogState derive : Typeable !-}
{-! for SoftFOL.Sign.SPSetting derive : Typeable !-}
{-! for SoftFOL.Sign.SPSettingBody derive : Typeable !-}
{-! for SoftFOL.Sign.SPHypothesis derive : Typeable !-}
{-! for SoftFOL.Sign.SPSettingLabel derive : Typeable !-}
{-! for SoftFOL.Sign.SPCRBIND derive : Typeable !-}

{-! for SoftFOL.Sign.Sign derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.Generated derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SFSymbol derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SFSymbType derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPProblem derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPLogicalPart derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSymbolList derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSignSym derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSortSym derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPDeclaration derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPFormulaList derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPClauseList derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPOriginType derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPClauseType derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.NSPClause derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.NSPClauseBody derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.TermWsList derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPTerm derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPLiteral derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPQuantSym derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSymbol derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPProofList derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPProofStep derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPReference derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPResult derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPRuleAppl derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPUserRuleAppl derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPParent derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPKey derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPValue derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPDescription derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPLogState derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSetting derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSettingBody derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPHypothesis derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPSettingLabel derive : ShATermConvertible !-}
{-! for SoftFOL.Sign.SPCRBIND derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "SoftFOL.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []

_tcGeneratedTc :: TyCon
_tcGeneratedTc = mkTyCon "SoftFOL.Sign.Generated"
instance Typeable Generated where
    typeOf _ = mkTyConApp _tcGeneratedTc []

_tcSFSymbolTc :: TyCon
_tcSFSymbolTc = mkTyCon "SoftFOL.Sign.SFSymbol"
instance Typeable SFSymbol where
    typeOf _ = mkTyConApp _tcSFSymbolTc []

_tcSFSymbTypeTc :: TyCon
_tcSFSymbTypeTc = mkTyCon "SoftFOL.Sign.SFSymbType"
instance Typeable SFSymbType where
    typeOf _ = mkTyConApp _tcSFSymbTypeTc []

_tcSPProblemTc :: TyCon
_tcSPProblemTc = mkTyCon "SoftFOL.Sign.SPProblem"
instance Typeable SPProblem where
    typeOf _ = mkTyConApp _tcSPProblemTc []

_tcSPLogicalPartTc :: TyCon
_tcSPLogicalPartTc = mkTyCon "SoftFOL.Sign.SPLogicalPart"
instance Typeable SPLogicalPart where
    typeOf _ = mkTyConApp _tcSPLogicalPartTc []

_tcSPSymbolListTc :: TyCon
_tcSPSymbolListTc = mkTyCon "SoftFOL.Sign.SPSymbolList"
instance Typeable SPSymbolList where
    typeOf _ = mkTyConApp _tcSPSymbolListTc []

_tcSPSignSymTc :: TyCon
_tcSPSignSymTc = mkTyCon "SoftFOL.Sign.SPSignSym"
instance Typeable SPSignSym where
    typeOf _ = mkTyConApp _tcSPSignSymTc []

_tcSPSortSymTc :: TyCon
_tcSPSortSymTc = mkTyCon "SoftFOL.Sign.SPSortSym"
instance Typeable SPSortSym where
    typeOf _ = mkTyConApp _tcSPSortSymTc []

_tcSPDeclarationTc :: TyCon
_tcSPDeclarationTc = mkTyCon "SoftFOL.Sign.SPDeclaration"
instance Typeable SPDeclaration where
    typeOf _ = mkTyConApp _tcSPDeclarationTc []

_tcSPFormulaListTc :: TyCon
_tcSPFormulaListTc = mkTyCon "SoftFOL.Sign.SPFormulaList"
instance Typeable SPFormulaList where
    typeOf _ = mkTyConApp _tcSPFormulaListTc []

_tcSPClauseListTc :: TyCon
_tcSPClauseListTc = mkTyCon "SoftFOL.Sign.SPClauseList"
instance Typeable SPClauseList where
    typeOf _ = mkTyConApp _tcSPClauseListTc []

_tcSPOriginTypeTc :: TyCon
_tcSPOriginTypeTc = mkTyCon "SoftFOL.Sign.SPOriginType"
instance Typeable SPOriginType where
    typeOf _ = mkTyConApp _tcSPOriginTypeTc []

_tcSPClauseTypeTc :: TyCon
_tcSPClauseTypeTc = mkTyCon "SoftFOL.Sign.SPClauseType"
instance Typeable SPClauseType where
    typeOf _ = mkTyConApp _tcSPClauseTypeTc []

_tcNSPClauseTc :: TyCon
_tcNSPClauseTc = mkTyCon "SoftFOL.Sign.NSPClause"
instance Typeable NSPClause where
    typeOf _ = mkTyConApp _tcNSPClauseTc []

_tcNSPClauseBodyTc :: TyCon
_tcNSPClauseBodyTc = mkTyCon "SoftFOL.Sign.NSPClauseBody"
instance Typeable NSPClauseBody where
    typeOf _ = mkTyConApp _tcNSPClauseBodyTc []

_tcTermWsListTc :: TyCon
_tcTermWsListTc = mkTyCon "SoftFOL.Sign.TermWsList"
instance Typeable TermWsList where
    typeOf _ = mkTyConApp _tcTermWsListTc []

_tcSPTermTc :: TyCon
_tcSPTermTc = mkTyCon "SoftFOL.Sign.SPTerm"
instance Typeable SPTerm where
    typeOf _ = mkTyConApp _tcSPTermTc []

_tcSPLiteralTc :: TyCon
_tcSPLiteralTc = mkTyCon "SoftFOL.Sign.SPLiteral"
instance Typeable SPLiteral where
    typeOf _ = mkTyConApp _tcSPLiteralTc []

_tcSPQuantSymTc :: TyCon
_tcSPQuantSymTc = mkTyCon "SoftFOL.Sign.SPQuantSym"
instance Typeable SPQuantSym where
    typeOf _ = mkTyConApp _tcSPQuantSymTc []

_tcSPSymbolTc :: TyCon
_tcSPSymbolTc = mkTyCon "SoftFOL.Sign.SPSymbol"
instance Typeable SPSymbol where
    typeOf _ = mkTyConApp _tcSPSymbolTc []

_tcSPProofListTc :: TyCon
_tcSPProofListTc = mkTyCon "SoftFOL.Sign.SPProofList"
instance Typeable SPProofList where
    typeOf _ = mkTyConApp _tcSPProofListTc []

_tcSPProofStepTc :: TyCon
_tcSPProofStepTc = mkTyCon "SoftFOL.Sign.SPProofStep"
instance Typeable SPProofStep where
    typeOf _ = mkTyConApp _tcSPProofStepTc []

_tcSPReferenceTc :: TyCon
_tcSPReferenceTc = mkTyCon "SoftFOL.Sign.SPReference"
instance Typeable SPReference where
    typeOf _ = mkTyConApp _tcSPReferenceTc []

_tcSPResultTc :: TyCon
_tcSPResultTc = mkTyCon "SoftFOL.Sign.SPResult"
instance Typeable SPResult where
    typeOf _ = mkTyConApp _tcSPResultTc []

_tcSPRuleApplTc :: TyCon
_tcSPRuleApplTc = mkTyCon "SoftFOL.Sign.SPRuleAppl"
instance Typeable SPRuleAppl where
    typeOf _ = mkTyConApp _tcSPRuleApplTc []

_tcSPUserRuleApplTc :: TyCon
_tcSPUserRuleApplTc = mkTyCon "SoftFOL.Sign.SPUserRuleAppl"
instance Typeable SPUserRuleAppl where
    typeOf _ = mkTyConApp _tcSPUserRuleApplTc []

_tcSPParentTc :: TyCon
_tcSPParentTc = mkTyCon "SoftFOL.Sign.SPParent"
instance Typeable SPParent where
    typeOf _ = mkTyConApp _tcSPParentTc []

_tcSPKeyTc :: TyCon
_tcSPKeyTc = mkTyCon "SoftFOL.Sign.SPKey"
instance Typeable SPKey where
    typeOf _ = mkTyConApp _tcSPKeyTc []

_tcSPValueTc :: TyCon
_tcSPValueTc = mkTyCon "SoftFOL.Sign.SPValue"
instance Typeable SPValue where
    typeOf _ = mkTyConApp _tcSPValueTc []

_tcSPDescriptionTc :: TyCon
_tcSPDescriptionTc = mkTyCon "SoftFOL.Sign.SPDescription"
instance Typeable SPDescription where
    typeOf _ = mkTyConApp _tcSPDescriptionTc []

_tcSPLogStateTc :: TyCon
_tcSPLogStateTc = mkTyCon "SoftFOL.Sign.SPLogState"
instance Typeable SPLogState where
    typeOf _ = mkTyConApp _tcSPLogStateTc []

_tcSPSettingTc :: TyCon
_tcSPSettingTc = mkTyCon "SoftFOL.Sign.SPSetting"
instance Typeable SPSetting where
    typeOf _ = mkTyConApp _tcSPSettingTc []

_tcSPSettingBodyTc :: TyCon
_tcSPSettingBodyTc = mkTyCon "SoftFOL.Sign.SPSettingBody"
instance Typeable SPSettingBody where
    typeOf _ = mkTyConApp _tcSPSettingBodyTc []

_tcSPHypothesisTc :: TyCon
_tcSPHypothesisTc = mkTyCon "SoftFOL.Sign.SPHypothesis"
instance Typeable SPHypothesis where
    typeOf _ = mkTyConApp _tcSPHypothesisTc []

_tcSPSettingLabelTc :: TyCon
_tcSPSettingLabelTc = mkTyCon "SoftFOL.Sign.SPSettingLabel"
instance Typeable SPSettingLabel where
    typeOf _ = mkTyConApp _tcSPSettingLabelTc []

_tcSPCRBINDTc :: TyCon
_tcSPCRBINDTc = mkTyCon "SoftFOL.Sign.SPCRBIND"
instance Typeable SPCRBIND where
    typeOf _ = mkTyConApp _tcSPCRBINDTc []

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "Sign" [a', b', c', d', e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, Sign a' b' c' d' e') }}}}}
    u -> fromShATermError "Sign" u

instance ShATermConvertible Generated where
  toShATermAux att0 xv = case xv of
    Generated a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Generated" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Generated" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Generated a' b') }}
    u -> fromShATermError "Generated" u

instance ShATermConvertible SFSymbol where
  toShATermAux att0 xv = case xv of
    SFSymbol a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SFSymbol" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SFSymbol" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SFSymbol a' b') }}
    u -> fromShATermError "SFSymbol" u

instance ShATermConvertible SFSymbType where
  toShATermAux att0 xv = case xv of
    SFOpType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SFOpType" [a', b'] []) att2
    SFPredType a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SFPredType" [a'] []) att1
    SFSortType -> return $ addATerm (ShAAppl "SFSortType" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SFOpType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SFOpType a' b') }}
    ShAAppl "SFPredType" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SFPredType a') }
    ShAAppl "SFSortType" [] _ -> (att0, SFSortType)
    u -> fromShATermError "SFSymbType" u

instance ShATermConvertible SPProblem where
  toShATermAux att0 xv = case xv of
    SPProblem a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "SPProblem" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPProblem" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, SPProblem a' b' c' d') }}}}
    u -> fromShATermError "SPProblem" u

instance ShATermConvertible SPLogicalPart where
  toShATermAux att0 xv = case xv of
    SPLogicalPart a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "SPLogicalPart" [a', b', c', d',
                                                  e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPLogicalPart" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, SPLogicalPart a' b' c' d' e') }}}}}
    u -> fromShATermError "SPLogicalPart" u

instance ShATermConvertible SPSymbolList where
  toShATermAux att0 xv = case xv of
    SPSymbolList a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SPSymbolList" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPSymbolList" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SPSymbolList a' b' c') }}}
    u -> fromShATermError "SPSymbolList" u

instance ShATermConvertible SPSignSym where
  toShATermAux att0 xv = case xv of
    SPSignSym a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPSignSym" [a', b'] []) att2
    SPSimpleSignSym a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPSimpleSignSym" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPSignSym" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPSignSym a' b') }}
    ShAAppl "SPSimpleSignSym" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPSimpleSignSym a') }
    u -> fromShATermError "SPSignSym" u

instance ShATermConvertible SPSortSym where
  toShATermAux att0 xv = case xv of
    SPSortSym a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPSortSym" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPSortSym" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPSortSym a') }
    u -> fromShATermError "SPSortSym" u

instance ShATermConvertible SPDeclaration where
  toShATermAux att0 xv = case xv of
    SPSubsortDecl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPSubsortDecl" [a', b'] []) att2
    SPTermDecl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPTermDecl" [a', b'] []) att2
    SPSimpleTermDecl a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPSimpleTermDecl" [a'] []) att1
    SPPredDecl a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPPredDecl" [a', b'] []) att2
    SPGenDecl a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SPGenDecl" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPSubsortDecl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPSubsortDecl a' b') }}
    ShAAppl "SPTermDecl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPTermDecl a' b') }}
    ShAAppl "SPSimpleTermDecl" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPSimpleTermDecl a') }
    ShAAppl "SPPredDecl" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPPredDecl a' b') }}
    ShAAppl "SPGenDecl" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SPGenDecl a' b' c') }}}
    u -> fromShATermError "SPDeclaration" u

instance ShATermConvertible SPFormulaList where
  toShATermAux att0 xv = case xv of
    SPFormulaList a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPFormulaList" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPFormulaList" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPFormulaList a' b') }}
    u -> fromShATermError "SPFormulaList" u

instance ShATermConvertible SPClauseList where
  toShATermAux att0 xv = case xv of
    SPClauseList a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SPClauseList" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPClauseList" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SPClauseList a' b' c') }}}
    u -> fromShATermError "SPClauseList" u

instance ShATermConvertible SPOriginType where
  toShATermAux att0 xv = case xv of
    SPOriginAxioms -> return $ addATerm (ShAAppl "SPOriginAxioms" [] []) att0
    SPOriginConjectures ->
      return $ addATerm (ShAAppl "SPOriginConjectures" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPOriginAxioms" [] _ -> (att0, SPOriginAxioms)
    ShAAppl "SPOriginConjectures" [] _ -> (att0, SPOriginConjectures)
    u -> fromShATermError "SPOriginType" u

instance ShATermConvertible SPClauseType where
  toShATermAux att0 xv = case xv of
    SPCNF -> return $ addATerm (ShAAppl "SPCNF" [] []) att0
    SPDNF -> return $ addATerm (ShAAppl "SPDNF" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPCNF" [] _ -> (att0, SPCNF)
    ShAAppl "SPDNF" [] _ -> (att0, SPDNF)
    u -> fromShATermError "SPClauseType" u

instance ShATermConvertible NSPClause where
  toShATermAux att0 xv = case xv of
    QuanClause a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "QuanClause" [a', b'] []) att2
    SimpleClause a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SimpleClause" [a'] []) att1
    BriefClause a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "BriefClause" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "QuanClause" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, QuanClause a' b') }}
    ShAAppl "SimpleClause" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SimpleClause a') }
    ShAAppl "BriefClause" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, BriefClause a' b' c') }}}
    u -> fromShATermError "NSPClause" u

instance ShATermConvertible NSPClauseBody where
  toShATermAux att0 xv = case xv of
    NSPClauseBody a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "NSPClauseBody" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "NSPClauseBody" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, NSPClauseBody a' b') }}
    u -> fromShATermError "NSPClauseBody" u

instance ShATermConvertible TermWsList where
  toShATermAux att0 xv = case xv of
    TWL a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "TWL" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "TWL" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, TWL a' b') }}
    u -> fromShATermError "TermWsList" u

instance ShATermConvertible SPTerm where
  toShATermAux att0 xv = case xv of
    SPQuantTerm a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SPQuantTerm" [a', b', c'] []) att3
    SPComplexTerm a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPComplexTerm" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPQuantTerm" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SPQuantTerm a' b' c') }}}
    ShAAppl "SPComplexTerm" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPComplexTerm a' b') }}
    u -> fromShATermError "SPTerm" u

instance ShATermConvertible SPLiteral where
  toShATermAux att0 xv = case xv of
    SPLiteral a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPLiteral" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPLiteral" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPLiteral a' b') }}
    u -> fromShATermError "SPLiteral" u

instance ShATermConvertible SPQuantSym where
  toShATermAux att0 xv = case xv of
    SPForall -> return $ addATerm (ShAAppl "SPForall" [] []) att0
    SPExists -> return $ addATerm (ShAAppl "SPExists" [] []) att0
    SPCustomQuantSym a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPCustomQuantSym" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPForall" [] _ -> (att0, SPForall)
    ShAAppl "SPExists" [] _ -> (att0, SPExists)
    ShAAppl "SPCustomQuantSym" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPCustomQuantSym a') }
    u -> fromShATermError "SPQuantSym" u

instance ShATermConvertible SPSymbol where
  toShATermAux att0 xv = case xv of
    SPEqual -> return $ addATerm (ShAAppl "SPEqual" [] []) att0
    SPTrue -> return $ addATerm (ShAAppl "SPTrue" [] []) att0
    SPFalse -> return $ addATerm (ShAAppl "SPFalse" [] []) att0
    SPOr -> return $ addATerm (ShAAppl "SPOr" [] []) att0
    SPAnd -> return $ addATerm (ShAAppl "SPAnd" [] []) att0
    SPNot -> return $ addATerm (ShAAppl "SPNot" [] []) att0
    SPImplies -> return $ addATerm (ShAAppl "SPImplies" [] []) att0
    SPImplied -> return $ addATerm (ShAAppl "SPImplied" [] []) att0
    SPEquiv -> return $ addATerm (ShAAppl "SPEquiv" [] []) att0
    SPID -> return $ addATerm (ShAAppl "SPID" [] []) att0
    SPDiv -> return $ addATerm (ShAAppl "SPDiv" [] []) att0
    SPComp -> return $ addATerm (ShAAppl "SPComp" [] []) att0
    SPSum -> return $ addATerm (ShAAppl "SPSum" [] []) att0
    SPConv -> return $ addATerm (ShAAppl "SPConv" [] []) att0
    SPCustomSymbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPCustomSymbol" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPEqual" [] _ -> (att0, SPEqual)
    ShAAppl "SPTrue" [] _ -> (att0, SPTrue)
    ShAAppl "SPFalse" [] _ -> (att0, SPFalse)
    ShAAppl "SPOr" [] _ -> (att0, SPOr)
    ShAAppl "SPAnd" [] _ -> (att0, SPAnd)
    ShAAppl "SPNot" [] _ -> (att0, SPNot)
    ShAAppl "SPImplies" [] _ -> (att0, SPImplies)
    ShAAppl "SPImplied" [] _ -> (att0, SPImplied)
    ShAAppl "SPEquiv" [] _ -> (att0, SPEquiv)
    ShAAppl "SPID" [] _ -> (att0, SPID)
    ShAAppl "SPDiv" [] _ -> (att0, SPDiv)
    ShAAppl "SPComp" [] _ -> (att0, SPComp)
    ShAAppl "SPSum" [] _ -> (att0, SPSum)
    ShAAppl "SPConv" [] _ -> (att0, SPConv)
    ShAAppl "SPCustomSymbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPCustomSymbol a') }
    u -> fromShATermError "SPSymbol" u

instance ShATermConvertible SPProofList where
  toShATermAux att0 xv = case xv of
    SPProofList a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "SPProofList" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPProofList" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, SPProofList a' b' c') }}}
    u -> fromShATermError "SPProofList" u

instance ShATermConvertible SPProofStep where
  toShATermAux att0 xv = case xv of
    SPProofStep a b c d e -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      return $ addATerm (ShAAppl "SPProofStep" [a', b', c', d',
                                                e'] []) att5
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPProofStep" [a, b, c, d, e] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      (att5, SPProofStep a' b' c' d' e') }}}}}
    u -> fromShATermError "SPProofStep" u

instance ShATermConvertible SPReference where
  toShATermAux att0 xv = case xv of
    PRefTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PRefTerm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PRefTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PRefTerm a') }
    u -> fromShATermError "SPReference" u

instance ShATermConvertible SPResult where
  toShATermAux att0 xv = case xv of
    PResTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PResTerm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PResTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PResTerm a') }
    u -> fromShATermError "SPResult" u

instance ShATermConvertible SPRuleAppl where
  toShATermAux att0 xv = case xv of
    PRuleTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PRuleTerm" [a'] []) att1
    PRuleUser a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PRuleUser" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PRuleTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PRuleTerm a') }
    ShAAppl "PRuleUser" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PRuleUser a') }
    u -> fromShATermError "SPRuleAppl" u

instance ShATermConvertible SPUserRuleAppl where
  toShATermAux att0 xv = case xv of
    GeR -> return $ addATerm (ShAAppl "GeR" [] []) att0
    SpL -> return $ addATerm (ShAAppl "SpL" [] []) att0
    SpR -> return $ addATerm (ShAAppl "SpR" [] []) att0
    EqF -> return $ addATerm (ShAAppl "EqF" [] []) att0
    Rew -> return $ addATerm (ShAAppl "Rew" [] []) att0
    Obv -> return $ addATerm (ShAAppl "Obv" [] []) att0
    EmS -> return $ addATerm (ShAAppl "EmS" [] []) att0
    SoR -> return $ addATerm (ShAAppl "SoR" [] []) att0
    EqR -> return $ addATerm (ShAAppl "EqR" [] []) att0
    Mpm -> return $ addATerm (ShAAppl "Mpm" [] []) att0
    SPm -> return $ addATerm (ShAAppl "SPm" [] []) att0
    OPm -> return $ addATerm (ShAAppl "OPm" [] []) att0
    SHy -> return $ addATerm (ShAAppl "SHy" [] []) att0
    OHy -> return $ addATerm (ShAAppl "OHy" [] []) att0
    URR -> return $ addATerm (ShAAppl "URR" [] []) att0
    Fac -> return $ addATerm (ShAAppl "Fac" [] []) att0
    Spt -> return $ addATerm (ShAAppl "Spt" [] []) att0
    Inp -> return $ addATerm (ShAAppl "Inp" [] []) att0
    Con -> return $ addATerm (ShAAppl "Con" [] []) att0
    RRE -> return $ addATerm (ShAAppl "RRE" [] []) att0
    SSi -> return $ addATerm (ShAAppl "SSi" [] []) att0
    ClR -> return $ addATerm (ShAAppl "ClR" [] []) att0
    UnC -> return $ addATerm (ShAAppl "UnC" [] []) att0
    Ter -> return $ addATerm (ShAAppl "Ter" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "GeR" [] _ -> (att0, GeR)
    ShAAppl "SpL" [] _ -> (att0, SpL)
    ShAAppl "SpR" [] _ -> (att0, SpR)
    ShAAppl "EqF" [] _ -> (att0, EqF)
    ShAAppl "Rew" [] _ -> (att0, Rew)
    ShAAppl "Obv" [] _ -> (att0, Obv)
    ShAAppl "EmS" [] _ -> (att0, EmS)
    ShAAppl "SoR" [] _ -> (att0, SoR)
    ShAAppl "EqR" [] _ -> (att0, EqR)
    ShAAppl "Mpm" [] _ -> (att0, Mpm)
    ShAAppl "SPm" [] _ -> (att0, SPm)
    ShAAppl "OPm" [] _ -> (att0, OPm)
    ShAAppl "SHy" [] _ -> (att0, SHy)
    ShAAppl "OHy" [] _ -> (att0, OHy)
    ShAAppl "URR" [] _ -> (att0, URR)
    ShAAppl "Fac" [] _ -> (att0, Fac)
    ShAAppl "Spt" [] _ -> (att0, Spt)
    ShAAppl "Inp" [] _ -> (att0, Inp)
    ShAAppl "Con" [] _ -> (att0, Con)
    ShAAppl "RRE" [] _ -> (att0, RRE)
    ShAAppl "SSi" [] _ -> (att0, SSi)
    ShAAppl "ClR" [] _ -> (att0, ClR)
    ShAAppl "UnC" [] _ -> (att0, UnC)
    ShAAppl "Ter" [] _ -> (att0, Ter)
    u -> fromShATermError "SPUserRuleAppl" u

instance ShATermConvertible SPParent where
  toShATermAux att0 xv = case xv of
    PParTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PParTerm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PParTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PParTerm a') }
    u -> fromShATermError "SPParent" u

instance ShATermConvertible SPKey where
  toShATermAux att0 xv = case xv of
    PKeyTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PKeyTerm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PKeyTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PKeyTerm a') }
    u -> fromShATermError "SPKey" u

instance ShATermConvertible SPValue where
  toShATermAux att0 xv = case xv of
    PValTerm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "PValTerm" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "PValTerm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, PValTerm a') }
    u -> fromShATermError "SPValue" u

instance ShATermConvertible SPDescription where
  toShATermAux att0 xv = case xv of
    SPDescription a b c d e f g -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      (att5, e') <- toShATerm' att4 e
      (att6, f') <- toShATerm' att5 f
      (att7, g') <- toShATerm' att6 g
      return $ addATerm (ShAAppl "SPDescription" [a', b', c', d', e', f',
                                                  g'] []) att7
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPDescription" [a, b, c, d, e, f, g] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      case fromShATerm' e att4 of
      { (att5, e') ->
      case fromShATerm' f att5 of
      { (att6, f') ->
      case fromShATerm' g att6 of
      { (att7, g') ->
      (att7, SPDescription a' b' c' d' e' f' g') }}}}}}}
    u -> fromShATermError "SPDescription" u

instance ShATermConvertible SPLogState where
  toShATermAux att0 xv = case xv of
    SPStateSatisfiable ->
      return $ addATerm (ShAAppl "SPStateSatisfiable" [] []) att0
    SPStateUnsatisfiable ->
      return $ addATerm (ShAAppl "SPStateUnsatisfiable" [] []) att0
    SPStateUnknown -> return $ addATerm (ShAAppl "SPStateUnknown" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPStateSatisfiable" [] _ -> (att0, SPStateSatisfiable)
    ShAAppl "SPStateUnsatisfiable" [] _ -> (att0, SPStateUnsatisfiable)
    ShAAppl "SPStateUnknown" [] _ -> (att0, SPStateUnknown)
    u -> fromShATermError "SPLogState" u

instance ShATermConvertible SPSetting where
  toShATermAux att0 xv = case xv of
    SPGeneralSettings a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPGeneralSettings" [a'] []) att1
    SPSettings a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPSettings" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPGeneralSettings" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPGeneralSettings a') }
    ShAAppl "SPSettings" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPSettings a' b') }}
    u -> fromShATermError "SPSetting" u

instance ShATermConvertible SPSettingBody where
  toShATermAux att0 xv = case xv of
    SPClauseRelation a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPClauseRelation" [a'] []) att1
    SPFlag a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPFlag" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPClauseRelation" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPClauseRelation a') }
    ShAAppl "SPFlag" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPFlag a' b') }}
    u -> fromShATermError "SPSettingBody" u

instance ShATermConvertible SPHypothesis where
  toShATermAux att0 xv = case xv of
    SPHypothesis a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "SPHypothesis" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPHypothesis" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, SPHypothesis a') }
    u -> fromShATermError "SPHypothesis" u

instance ShATermConvertible SPSettingLabel where
  toShATermAux att0 xv = case xv of
    KIV -> return $ addATerm (ShAAppl "KIV" [] []) att0
    LEM -> return $ addATerm (ShAAppl "LEM" [] []) att0
    OTTER -> return $ addATerm (ShAAppl "OTTER" [] []) att0
    PROTEIN -> return $ addATerm (ShAAppl "PROTEIN" [] []) att0
    SATURATE -> return $ addATerm (ShAAppl "SATURATE" [] []) att0
    ThreeTAP -> return $ addATerm (ShAAppl "ThreeTAP" [] []) att0
    SETHEO -> return $ addATerm (ShAAppl "SETHEO" [] []) att0
    SPASS -> return $ addATerm (ShAAppl "SPASS" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "KIV" [] _ -> (att0, KIV)
    ShAAppl "LEM" [] _ -> (att0, LEM)
    ShAAppl "OTTER" [] _ -> (att0, OTTER)
    ShAAppl "PROTEIN" [] _ -> (att0, PROTEIN)
    ShAAppl "SATURATE" [] _ -> (att0, SATURATE)
    ShAAppl "ThreeTAP" [] _ -> (att0, ThreeTAP)
    ShAAppl "SETHEO" [] _ -> (att0, SETHEO)
    ShAAppl "SPASS" [] _ -> (att0, SPASS)
    u -> fromShATermError "SPSettingLabel" u

instance ShATermConvertible SPCRBIND where
  toShATermAux att0 xv = case xv of
    SPCRBIND a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "SPCRBIND" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SPCRBIND" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, SPCRBIND a' b') }}
    u -> fromShATermError "SPCRBIND" u
