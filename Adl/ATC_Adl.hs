{-# OPTIONS -w -O0 #-}
{- |
Module      :  Adl/ATC_Adl.der.hs
Description :  generated Typeable, ShATermConvertible instances
Copyright   :  (c) DFKI Bremen 2008
License     :  GPLv2 or higher, see LICENSE.txt

Maintainer  :  Christian.Maeder@dfki.de
Stability   :  provisional
Portability :  non-portable(overlapping Typeable instances)

Automatic derivation of instances via DrIFT-rule Typeable, ShATermConvertible
  for the type(s):
'Adl.As.Concept'
'Adl.As.RelType'
'Adl.As.Relation'
'Adl.As.UnOp'
'Adl.As.MulOp'
'Adl.As.Rule'
'Adl.As.Prop'
'Adl.As.RangedProp'
'Adl.As.Object'
'Adl.As.KeyAtt'
'Adl.As.KeyDef'
'Adl.As.RuleKind'
'Adl.As.RuleHeader'
'Adl.As.Pair'
'Adl.As.Plugin'
'Adl.As.PatElem'
'Adl.As.Context'
'Adl.Sign.Sign'
'Adl.Sign.Symbol'
'Adl.Sign.RawSymbol'
'Adl.Sign.Sen'
-}

{-
  Generated by 'genRules' (automatic rule generation for DrIFT). Don't touch!!
  dependency files:
Adl/As.hs
Adl/Sign.hs
-}

module Adl.ATC_Adl () where

import ATC.AS_Annotation
import ATerm.Lib
import Adl.As
import Adl.Print ()
import Adl.Sign
import Common.AS_Annotation
import Common.Doc
import Common.DocUtils
import Common.Id
import Common.Keywords
import Common.Result
import Data.Char
import Data.List (sortBy)
import Data.Typeable
import qualified Common.Lib.Rel as Rel
import qualified Data.Map as Map
import qualified Data.Set as Set

{-! for Adl.As.Concept derive : Typeable !-}
{-! for Adl.As.RelType derive : Typeable !-}
{-! for Adl.As.Relation derive : Typeable !-}
{-! for Adl.As.UnOp derive : Typeable !-}
{-! for Adl.As.MulOp derive : Typeable !-}
{-! for Adl.As.Rule derive : Typeable !-}
{-! for Adl.As.Prop derive : Typeable !-}
{-! for Adl.As.RangedProp derive : Typeable !-}
{-! for Adl.As.Object derive : Typeable !-}
{-! for Adl.As.KeyAtt derive : Typeable !-}
{-! for Adl.As.KeyDef derive : Typeable !-}
{-! for Adl.As.RuleKind derive : Typeable !-}
{-! for Adl.As.RuleHeader derive : Typeable !-}
{-! for Adl.As.Pair derive : Typeable !-}
{-! for Adl.As.Plugin derive : Typeable !-}
{-! for Adl.As.PatElem derive : Typeable !-}
{-! for Adl.As.Context derive : Typeable !-}
{-! for Adl.Sign.Sign derive : Typeable !-}
{-! for Adl.Sign.Symbol derive : Typeable !-}
{-! for Adl.Sign.RawSymbol derive : Typeable !-}
{-! for Adl.Sign.Sen derive : Typeable !-}

{-! for Adl.As.Concept derive : ShATermConvertible !-}
{-! for Adl.As.RelType derive : ShATermConvertible !-}
{-! for Adl.As.Relation derive : ShATermConvertible !-}
{-! for Adl.As.UnOp derive : ShATermConvertible !-}
{-! for Adl.As.MulOp derive : ShATermConvertible !-}
{-! for Adl.As.Rule derive : ShATermConvertible !-}
{-! for Adl.As.Prop derive : ShATermConvertible !-}
{-! for Adl.As.RangedProp derive : ShATermConvertible !-}
{-! for Adl.As.Object derive : ShATermConvertible !-}
{-! for Adl.As.KeyAtt derive : ShATermConvertible !-}
{-! for Adl.As.KeyDef derive : ShATermConvertible !-}
{-! for Adl.As.RuleKind derive : ShATermConvertible !-}
{-! for Adl.As.RuleHeader derive : ShATermConvertible !-}
{-! for Adl.As.Pair derive : ShATermConvertible !-}
{-! for Adl.As.Plugin derive : ShATermConvertible !-}
{-! for Adl.As.PatElem derive : ShATermConvertible !-}
{-! for Adl.As.Context derive : ShATermConvertible !-}
{-! for Adl.Sign.Sign derive : ShATermConvertible !-}
{-! for Adl.Sign.Symbol derive : ShATermConvertible !-}
{-! for Adl.Sign.RawSymbol derive : ShATermConvertible !-}
{-! for Adl.Sign.Sen derive : ShATermConvertible !-}

-- Generated by DrIFT, look but don't touch!

instance ShATermConvertible Context where
  toShATermAux att0 xv = case xv of
    Context a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Context" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Context" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Context a' b') }}
    u -> fromShATermError "Context" u

instance ShATermConvertible PatElem where
  toShATermAux att0 xv = case xv of
    Pr a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Pr" [a', b'] []) att2
    Pg a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Pg" [a', b'] []) att2
    Pk a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Pk" [a'] []) att1
    Pm a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Pm" [a', b', c'] []) att3
    Plug a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Plug" [a', b'] []) att2
    Population a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "Population" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Pr" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Pr a' b') }}
    ShAAppl "Pg" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Pg a' b') }}
    ShAAppl "Pk" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Pk a') }
    ShAAppl "Pm" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Pm a' b' c') }}}
    ShAAppl "Plug" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Plug a' b') }}
    ShAAppl "Population" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, Population a' b' c') }}}
    u -> fromShATermError "PatElem" u

instance ShATermConvertible Plugin where
  toShATermAux att0 xv = case xv of
    Service -> return $ addATerm (ShAAppl "Service" [] []) att0
    Sqlplug -> return $ addATerm (ShAAppl "Sqlplug" [] []) att0
    Phpplug -> return $ addATerm (ShAAppl "Phpplug" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Service" [] _ -> (att0, Service)
    ShAAppl "Sqlplug" [] _ -> (att0, Sqlplug)
    ShAAppl "Phpplug" [] _ -> (att0, Phpplug)
    u -> fromShATermError "Plugin" u

instance ShATermConvertible Pair where
  toShATermAux att0 xv = case xv of
    Pair a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Pair" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Pair" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Pair a' b') }}
    u -> fromShATermError "Pair" u

instance ShATermConvertible RuleHeader where
  toShATermAux att0 xv = case xv of
    Always -> return $ addATerm (ShAAppl "Always" [] []) att0
    RuleHeader a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "RuleHeader" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Always" [] _ -> (att0, Always)
    ShAAppl "RuleHeader" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, RuleHeader a' b') }}
    u -> fromShATermError "RuleHeader" u

instance ShATermConvertible RuleKind where
  toShATermAux att0 xv = case xv of
    SignalOn -> return $ addATerm (ShAAppl "SignalOn" [] []) att0
    Signals -> return $ addATerm (ShAAppl "Signals" [] []) att0
    Maintains -> return $ addATerm (ShAAppl "Maintains" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "SignalOn" [] _ -> (att0, SignalOn)
    ShAAppl "Signals" [] _ -> (att0, Signals)
    ShAAppl "Maintains" [] _ -> (att0, Maintains)
    u -> fromShATermError "RuleKind" u

instance ShATermConvertible KeyDef where
  toShATermAux att0 xv = case xv of
    KeyDef a b c -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      return $ addATerm (ShAAppl "KeyDef" [a', b', c'] []) att3
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "KeyDef" [a, b, c] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      (att3, KeyDef a' b' c') }}}
    u -> fromShATermError "KeyDef" u

instance ShATermConvertible KeyAtt where
  toShATermAux att0 xv = case xv of
    KeyAtt a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "KeyAtt" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "KeyAtt" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, KeyAtt a' b') }}
    u -> fromShATermError "KeyAtt" u

instance ShATermConvertible Object where
  toShATermAux att0 xv = case xv of
    Object a b c d -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      (att3, c') <- toShATerm' att2 c
      (att4, d') <- toShATerm' att3 d
      return $ addATerm (ShAAppl "Object" [a', b', c', d'] []) att4
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Object" [a, b, c, d] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      case fromShATerm' c att2 of
      { (att3, c') ->
      case fromShATerm' d att3 of
      { (att4, d') ->
      (att4, Object a' b' c' d') }}}}
    u -> fromShATermError "Object" u

instance ShATermConvertible RangedProp where
  toShATermAux att0 xv = case xv of
    RangedProp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "RangedProp" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "RangedProp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, RangedProp a' b') }}
    u -> fromShATermError "RangedProp" u

instance ShATermConvertible Prop where
  toShATermAux att0 xv = case xv of
    Uni -> return $ addATerm (ShAAppl "Uni" [] []) att0
    Inj -> return $ addATerm (ShAAppl "Inj" [] []) att0
    Sur -> return $ addATerm (ShAAppl "Sur" [] []) att0
    Tot -> return $ addATerm (ShAAppl "Tot" [] []) att0
    Sym -> return $ addATerm (ShAAppl "Sym" [] []) att0
    Asy -> return $ addATerm (ShAAppl "Asy" [] []) att0
    Trn -> return $ addATerm (ShAAppl "Trn" [] []) att0
    Rfx -> return $ addATerm (ShAAppl "Rfx" [] []) att0
    Prop -> return $ addATerm (ShAAppl "Prop" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Uni" [] _ -> (att0, Uni)
    ShAAppl "Inj" [] _ -> (att0, Inj)
    ShAAppl "Sur" [] _ -> (att0, Sur)
    ShAAppl "Tot" [] _ -> (att0, Tot)
    ShAAppl "Sym" [] _ -> (att0, Sym)
    ShAAppl "Asy" [] _ -> (att0, Asy)
    ShAAppl "Trn" [] _ -> (att0, Trn)
    ShAAppl "Rfx" [] _ -> (att0, Rfx)
    ShAAppl "Prop" [] _ -> (att0, Prop)
    u -> fromShATermError "Prop" u

instance ShATermConvertible Rule where
  toShATermAux att0 xv = case xv of
    Tm a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Tm" [a'] []) att1
    MulExp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "MulExp" [a', b'] []) att2
    UnExp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "UnExp" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Tm" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Tm a') }
    ShAAppl "MulExp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, MulExp a' b') }}
    ShAAppl "UnExp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, UnExp a' b') }}
    u -> fromShATermError "Rule" u

instance ShATermConvertible MulOp where
  toShATermAux att0 xv = case xv of
    Fc -> return $ addATerm (ShAAppl "Fc" [] []) att0
    Fd -> return $ addATerm (ShAAppl "Fd" [] []) att0
    Fi -> return $ addATerm (ShAAppl "Fi" [] []) att0
    Fu -> return $ addATerm (ShAAppl "Fu" [] []) att0
    Ri -> return $ addATerm (ShAAppl "Ri" [] []) att0
    Rr -> return $ addATerm (ShAAppl "Rr" [] []) att0
    Re -> return $ addATerm (ShAAppl "Re" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Fc" [] _ -> (att0, Fc)
    ShAAppl "Fd" [] _ -> (att0, Fd)
    ShAAppl "Fi" [] _ -> (att0, Fi)
    ShAAppl "Fu" [] _ -> (att0, Fu)
    ShAAppl "Ri" [] _ -> (att0, Ri)
    ShAAppl "Rr" [] _ -> (att0, Rr)
    ShAAppl "Re" [] _ -> (att0, Re)
    u -> fromShATermError "MulOp" u

instance ShATermConvertible UnOp where
  toShATermAux att0 xv = case xv of
    K0 -> return $ addATerm (ShAAppl "K0" [] []) att0
    K1 -> return $ addATerm (ShAAppl "K1" [] []) att0
    Cp -> return $ addATerm (ShAAppl "Cp" [] []) att0
    Co -> return $ addATerm (ShAAppl "Co" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "K0" [] _ -> (att0, K0)
    ShAAppl "K1" [] _ -> (att0, K1)
    ShAAppl "Cp" [] _ -> (att0, Cp)
    ShAAppl "Co" [] _ -> (att0, Co)
    u -> fromShATermError "UnOp" u

instance ShATermConvertible Relation where
  toShATermAux att0 xv = case xv of
    Sgn a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Sgn" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sgn" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Sgn a' b') }}
    u -> fromShATermError "Relation" u

instance ShATermConvertible RelType where
  toShATermAux att0 xv = case xv of
    RelType a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "RelType" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "RelType" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, RelType a' b') }}
    u -> fromShATermError "RelType" u

instance ShATermConvertible Concept where
  toShATermAux att0 xv = case xv of
    C a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "C" [a'] []) att1
    Anything -> return $ addATerm (ShAAppl "Anything" [] []) att0
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "C" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, C a') }
    ShAAppl "Anything" [] _ -> (att0, Anything)
    u -> fromShATermError "Concept" u

_tcContextTc :: TyCon
_tcContextTc = mkTyCon "Adl.As.Context"
instance Typeable Context where
    typeOf _ = mkTyConApp _tcContextTc []

_tcPatElemTc :: TyCon
_tcPatElemTc = mkTyCon "Adl.As.PatElem"
instance Typeable PatElem where
    typeOf _ = mkTyConApp _tcPatElemTc []

_tcPluginTc :: TyCon
_tcPluginTc = mkTyCon "Adl.As.Plugin"
instance Typeable Plugin where
    typeOf _ = mkTyConApp _tcPluginTc []

_tcPairTc :: TyCon
_tcPairTc = mkTyCon "Adl.As.Pair"
instance Typeable Pair where
    typeOf _ = mkTyConApp _tcPairTc []

_tcRuleHeaderTc :: TyCon
_tcRuleHeaderTc = mkTyCon "Adl.As.RuleHeader"
instance Typeable RuleHeader where
    typeOf _ = mkTyConApp _tcRuleHeaderTc []

_tcRuleKindTc :: TyCon
_tcRuleKindTc = mkTyCon "Adl.As.RuleKind"
instance Typeable RuleKind where
    typeOf _ = mkTyConApp _tcRuleKindTc []

_tcKeyDefTc :: TyCon
_tcKeyDefTc = mkTyCon "Adl.As.KeyDef"
instance Typeable KeyDef where
    typeOf _ = mkTyConApp _tcKeyDefTc []

_tcKeyAttTc :: TyCon
_tcKeyAttTc = mkTyCon "Adl.As.KeyAtt"
instance Typeable KeyAtt where
    typeOf _ = mkTyConApp _tcKeyAttTc []

_tcObjectTc :: TyCon
_tcObjectTc = mkTyCon "Adl.As.Object"
instance Typeable Object where
    typeOf _ = mkTyConApp _tcObjectTc []

_tcRangedPropTc :: TyCon
_tcRangedPropTc = mkTyCon "Adl.As.RangedProp"
instance Typeable RangedProp where
    typeOf _ = mkTyConApp _tcRangedPropTc []

_tcPropTc :: TyCon
_tcPropTc = mkTyCon "Adl.As.Prop"
instance Typeable Prop where
    typeOf _ = mkTyConApp _tcPropTc []

_tcRuleTc :: TyCon
_tcRuleTc = mkTyCon "Adl.As.Rule"
instance Typeable Rule where
    typeOf _ = mkTyConApp _tcRuleTc []

_tcMulOpTc :: TyCon
_tcMulOpTc = mkTyCon "Adl.As.MulOp"
instance Typeable MulOp where
    typeOf _ = mkTyConApp _tcMulOpTc []

_tcUnOpTc :: TyCon
_tcUnOpTc = mkTyCon "Adl.As.UnOp"
instance Typeable UnOp where
    typeOf _ = mkTyConApp _tcUnOpTc []

_tcRelationTc :: TyCon
_tcRelationTc = mkTyCon "Adl.As.Relation"
instance Typeable Relation where
    typeOf _ = mkTyConApp _tcRelationTc []

_tcRelTypeTc :: TyCon
_tcRelTypeTc = mkTyCon "Adl.As.RelType"
instance Typeable RelType where
    typeOf _ = mkTyConApp _tcRelTypeTc []

_tcConceptTc :: TyCon
_tcConceptTc = mkTyCon "Adl.As.Concept"
instance Typeable Concept where
    typeOf _ = mkTyConApp _tcConceptTc []

instance ShATermConvertible Sen where
  toShATermAux att0 xv = case xv of
    DeclProp a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "DeclProp" [a', b'] []) att2
    Assertion a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Assertion" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "DeclProp" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, DeclProp a' b') }}
    ShAAppl "Assertion" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Assertion a' b') }}
    u -> fromShATermError "Sen" u

instance ShATermConvertible RawSymbol where
  toShATermAux att0 xv = case xv of
    Symbol a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Symbol" [a'] []) att1
    AnId a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "AnId" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Symbol" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Symbol a') }
    ShAAppl "AnId" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, AnId a') }
    u -> fromShATermError "RawSymbol" u

instance ShATermConvertible Symbol where
  toShATermAux att0 xv = case xv of
    Con a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Con" [a'] []) att1
    Rel a -> do
      (att1, a') <- toShATerm' att0 a
      return $ addATerm (ShAAppl "Rel" [a'] []) att1
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Con" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Con a') }
    ShAAppl "Rel" [a] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      (att1, Rel a') }
    u -> fromShATermError "Symbol" u

instance ShATermConvertible Sign where
  toShATermAux att0 xv = case xv of
    Sign a b -> do
      (att1, a') <- toShATerm' att0 a
      (att2, b') <- toShATerm' att1 b
      return $ addATerm (ShAAppl "Sign" [a', b'] []) att2
  fromShATermAux ix att0 = case getShATerm ix att0 of
    ShAAppl "Sign" [a, b] _ ->
      case fromShATerm' a att0 of
      { (att1, a') ->
      case fromShATerm' b att1 of
      { (att2, b') ->
      (att2, Sign a' b') }}
    u -> fromShATermError "Sign" u

_tcSenTc :: TyCon
_tcSenTc = mkTyCon "Adl.Sign.Sen"
instance Typeable Sen where
    typeOf _ = mkTyConApp _tcSenTc []

_tcRawSymbolTc :: TyCon
_tcRawSymbolTc = mkTyCon "Adl.Sign.RawSymbol"
instance Typeable RawSymbol where
    typeOf _ = mkTyConApp _tcRawSymbolTc []

_tcSymbolTc :: TyCon
_tcSymbolTc = mkTyCon "Adl.Sign.Symbol"
instance Typeable Symbol where
    typeOf _ = mkTyConApp _tcSymbolTc []

_tcSignTc :: TyCon
_tcSignTc = mkTyCon "Adl.Sign.Sign"
instance Typeable Sign where
    typeOf _ = mkTyConApp _tcSignTc []
